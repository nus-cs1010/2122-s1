{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Lecture 9 In this lecture, we will explore two basic computing problems: searching and sorting . In particular, you will learn about binary search, bubble sort, and insertion sort. video | slides | quiz Assignment 6 and Exercise 9 Assignment 6 has been released. This assignment is worth 4% and is due next Tuesday 11:59pm. Start early! Exercise 9 is also available to be completed during the lab session this week. Lecture 8 We will cover three different topics this week. First, we will wrap up our discussion on arrays with Unit 19 on multi-dimensional arrays . Then, we will explore deeper into compilation process, particular on several useful pre-processing directives . Finally, we will prepare you for the next segments of CS1010, by exploring how we can measure the efficiency of an algorithm using the Big-O notation. video | slides | quiz Assignment 5 Assignment 5 has been released. This assignment is worth 3% and is due next Tuesday 11:59pm. Exercise 8 Exercise 8 is now posted. This exercise consists of three questions on string operations. Lecture 7 In this jam-packed lecture, we delve deeper into pointers, memory, and arrays. We will start by introducing the referencing and dereferencing operators , and show how they can be used to pass an argument by reference . We then explore heap memory management , and use it as the basis for dynamically-sized arrays. Finally, we will look at a special type of arrays -- the strings . THis lecture covers Units 15-18. video | slides | quiz Assignment 4 Assignment 4 is posted. Due to the coming PE, this assignment is released a day ealier, is due a day later, and has only two questions. The assignment is due on Wednesday midnight, on 6 October, 2359. Assignment 3 Assignment 3 is posted. This assignment is due after the recess week, on 28 September, 2359. Exercise 6 Exercise 6 is posted. This consists of the PE I question from AY 2021/22 Semester 1. Exercise 5 Exercise 5 is posted. Give it a try after completing your Assignment 3. Exercise 5 contains very simple problems that you can solve with fixed-length arrays. If you are new to programming, we encourage you to try it out before completing Assignment 3. Lecture 6 Lecture 6 consists of two parts. In Part 1, we will delve deeper into how functions are called in C (and other languages), to get a better understanding of the behavior of your program. We will learn how call stacks works. In Part 2, we will start exploring arrays in C. We will focus on fixed-length arrays for this lecture. video | slides | quiz Exercise 3 Exercise 3 is posted. Give it a try after completing your Assignment 2. Exercise 3 contains very simple problems that you can solve with five commonly used \"patterns\" of loops. If you are new to programming, we encourage you to try it out before Exercise 4 and Assignment 2, which builds upon these patterns to solve more complex problems. Lecture 5 In Lecture 5, we will discuss how we can reason about our code using assertions , how we can control the flow of C programs with loops , and how to reason about the behavior of loops with invariants . video | slides | quiz Assignment 1 Assignment 1 is released. The assignment is due on 7 September 2021, 11:59 PM, and contributes to 3% of your final grade. Lecture 4 In Lecture 4, we will see how we can control the flow of C programs with conditional if-else statements , how to expression conditions with logical expressions , and how we can reason about our code with assertions . video | slides | quiz Lecture 3 In our third lecture, we will start to write some simple C programs. We will learn about how to write C functions , how to read and write , and how to perform arithmetic operations . video | slides | quiz Lecture 2 This week, we will examine two concepts that are central to programming: functions and types . video | slides | quiz Lecture 1 Given that the first lecture for CS1010 falls on the National Day, I have recorded the lecture and have posted it on LumiNUS Multimedia. We covered lots of adminsitrative details today, and started with Units 1 and 2 on what is a program, what are computational problems, and what is an algorithms. As a concrete example, we went through finding the largest value from a given list. Here are the videos, slides, and self-diagnostic quiz (due on Wednesday 2359). video | slides | quiz Getting Ready for CS1010 Welcome to CS1010! Here are some things that you can do while waiting for the semester to start. Take a Look at General CS1010 Information Take a look at the crucial information about CS1010 here. Scan through the learning outcomes to know what you are expected to learn in this module. Note down the important dates on your calendar. Read about CS1010 Policies The general policies for CS1010 is posted. Go through it to see what is expected. Enable Your Piazza Account You should have received an email inviting you to create a Piazza account and enroll in the module Q&A forum. Please join CS1010 on Piazza. Enable Your SoC Account Go to https://mysoc.nus.edu.sg/~newacct and create your SoC Unix Account if you have not done so. Activate \"General Unix Servers\" and \"The SoC Compute Cluster\" in MySoC here: https://mysoc.nus.edu.sg/~myacct/services.cgi Create a GitHub Account Create a GitHub account if you do not have one. This account should stay with you for your professional career. So choose the username wisely. Then, tells us your GitHub Username here before 13 August 2021, Friday. Get a Head-Start with Unix and Vim You can check out the content for SoC Unix@Home Workshop , which was held last year. The website contains notes with examples, which you can follow through. If you have questions or face any issues, ask on Piazza. You can also find more notes under \"Software/Tools\". Read Feedback on CS1010 from Last Year Ago This semester's CS1010 will be conducted in a similar style with the version in AY2020/21. Read the comments from that batch of students to know what to expect. Explore Some Additional Readings Some extra reading materials curated by Wei Tsang are available . If you have some programming background and are wondering why we are teaching C, read the articles under Why C section.","title":"Home"},{"location":"01-program.html","text":"Unit 1: What is a Program? Learning Outcomes After this unit, students should: have an idea of what is a program and how a program is executed by a computer understand the basic terminologies: machine code, assembly language, and higher-level programming languages What is a (computer) program? Despite all the wonderful and amazing things that computers can do, computers are not very smart. In fact, they are pretty dumb. Computers can only follow the instructions given by a human. A computer program is a sequence of step-by-step instructions given to computers to manipulate data in order to perform a certain task. Programming is the art and science of writing a computer program, and that is what you will learn to do in CS1010. How computer executes a program In order to learn how to write a program, it is important to have an overview of how a computer executes a program. You will learn in details how this is done in CS2100/CS2106 or EE2024/CG2271, but for CS1010, we will take a very simplistic and high-level view of this process. The two important components of a computer we will discuss for CS1010 is the CPU, or central processing unit and the memory, which is a generalized term for where we store the data to be processed or manipulated by the CPU, as well as the instructions to do so. A memory location is addressable using a memory address . The instructions to the CPU comes in the form of machine code , a sequence of bits (1s and 0s) that is interpreted and then followed by the CPU to do certain things. These machine code could instruct the CPU, for instance, to compare if a particular number at a certain memory location is more than 0, to add one number to another, or to execute another instruction at another memory location. The data stored in the memory is also stored as a sequence of 1s and 0s. From Machine Code to High-level Programming Language While it is possible for us, human, to write machine code directly, few actually do since it is challenging to do so. Different CPUs understand different sets of machine code; it is tedious to figure out where each piece of data is located in the memory (this location is actually determined by the operating system). The resulting code, even when it is correct and easy to read and understand by the machine, are often hard to decipher for a human. Simple operations such as comparing two numbers to see which one is bigger might require several instructions to perform. To get around the readability problem, programmers can code in assembly language -- a human-readable form of machine code, where each instruction, instead of represented by 0s and 1s, is represented by a mnemonic (such as decr , incr , store , add , etc.) Writing assembly code does not address the issues of machine-dependent code and the tediousness of programming. Early programmers (in the fifties) understood this and designed high-level programming languages , where programmers can describe the operations that they wish to do in a language closer to their intention that is machine independent. A program written in one of these programming languages is then compiled into machine code for a specific CPU for execution using a compiler. The first commercially available language is FORTRAN from IBM in the 1950s. Among many early programming languages, C (birth year 1972) is the only one that is still popular and widely used today, For many reasons , C is the language of choice for CS1010. The Goals of CS1010 This brings us to the goals of CS1010. First, you will learn the most important syntax element of the C programming language. Second, you will learn how a C program behaves, in relation to how a program is executed and how data are stored and manipulated in memory. Third, you will learn the various tools and techniques that will help you produce good and correct C programs. The last, and the most important and challenging goal of CS1010, however, is that you will learn how to write programs to solve computational problems. Learning to write a program that does what you want it to do is actually not difficult. Knowing what you want your program to do is the more challenging part!","title":"1. What is a Program?"},{"location":"01-program.html#unit-1-what-is-a-program","text":"","title":"Unit 1: What is a Program?"},{"location":"01-program.html#learning-outcomes","text":"After this unit, students should: have an idea of what is a program and how a program is executed by a computer understand the basic terminologies: machine code, assembly language, and higher-level programming languages","title":"Learning Outcomes"},{"location":"01-program.html#what-is-a-computer-program","text":"Despite all the wonderful and amazing things that computers can do, computers are not very smart. In fact, they are pretty dumb. Computers can only follow the instructions given by a human. A computer program is a sequence of step-by-step instructions given to computers to manipulate data in order to perform a certain task. Programming is the art and science of writing a computer program, and that is what you will learn to do in CS1010.","title":"What is a (computer) program?"},{"location":"01-program.html#how-computer-executes-a-program","text":"In order to learn how to write a program, it is important to have an overview of how a computer executes a program. You will learn in details how this is done in CS2100/CS2106 or EE2024/CG2271, but for CS1010, we will take a very simplistic and high-level view of this process. The two important components of a computer we will discuss for CS1010 is the CPU, or central processing unit and the memory, which is a generalized term for where we store the data to be processed or manipulated by the CPU, as well as the instructions to do so. A memory location is addressable using a memory address . The instructions to the CPU comes in the form of machine code , a sequence of bits (1s and 0s) that is interpreted and then followed by the CPU to do certain things. These machine code could instruct the CPU, for instance, to compare if a particular number at a certain memory location is more than 0, to add one number to another, or to execute another instruction at another memory location. The data stored in the memory is also stored as a sequence of 1s and 0s.","title":"How computer executes a program"},{"location":"01-program.html#from-machine-code-to-high-level-programming-language","text":"While it is possible for us, human, to write machine code directly, few actually do since it is challenging to do so. Different CPUs understand different sets of machine code; it is tedious to figure out where each piece of data is located in the memory (this location is actually determined by the operating system). The resulting code, even when it is correct and easy to read and understand by the machine, are often hard to decipher for a human. Simple operations such as comparing two numbers to see which one is bigger might require several instructions to perform. To get around the readability problem, programmers can code in assembly language -- a human-readable form of machine code, where each instruction, instead of represented by 0s and 1s, is represented by a mnemonic (such as decr , incr , store , add , etc.) Writing assembly code does not address the issues of machine-dependent code and the tediousness of programming. Early programmers (in the fifties) understood this and designed high-level programming languages , where programmers can describe the operations that they wish to do in a language closer to their intention that is machine independent. A program written in one of these programming languages is then compiled into machine code for a specific CPU for execution using a compiler. The first commercially available language is FORTRAN from IBM in the 1950s. Among many early programming languages, C (birth year 1972) is the only one that is still popular and widely used today, For many reasons , C is the language of choice for CS1010.","title":"From Machine Code to High-level Programming Language"},{"location":"01-program.html#the-goals-of-cs1010","text":"This brings us to the goals of CS1010. First, you will learn the most important syntax element of the C programming language. Second, you will learn how a C program behaves, in relation to how a program is executed and how data are stored and manipulated in memory. Third, you will learn the various tools and techniques that will help you produce good and correct C programs. The last, and the most important and challenging goal of CS1010, however, is that you will learn how to write programs to solve computational problems. Learning to write a program that does what you want it to do is actually not difficult. Knowing what you want your program to do is the more challenging part!","title":"The Goals of CS1010"},{"location":"02-algo.html","text":"Unit 2: Computational Problems and Algorithms Learning Outcomes: After this unit, students should: be able to differentiate between a computational and a non-computational problem; understand the basic terminologies: computational problem solving, algorithm, flowchart, debugging, testing, variables, value, assignment; be familiar with the algorithm to find the maximum among a list of numbers; be able to express an algorithm using a flowchart; be able to trace through flowcharts that involves branching, looping, and updates of variables; understand the notion of the \"correctness\" of an algorithm. Computational Problems So, what is computational problem solving? Let's start with the question, what is a computational problem ? A computational problem is a problem that can be solved step-by-step with a computer. These problems usually have a well-defined input, constraints, and conditions that the output must satisfied. Here are some types of computational problems: A decision problem is one where the answer is yes or no. For instance, \"given a number \\(n\\) , is \\(n\\) even?\" is a decision problem. Some decision problems take more steps to solve than others. For instance, \"given a number \\(n\\) , is \\(n\\) prime?\" takes more steps than just checking the parity of a number. A search problem is one where the solution consists of one or more values that satisfies a given condition. For instance, we may want to compute a path from one geographical location to another on a map. A counting problem is one where the answer is the number of solutions to a search problem. An optimization problem is one where the solution is the \"best\" possible solution, where the \"best\" can be defined in a different way. For instance, we may want to compute the fastest route from one location to another. Questions such as \"what is the meaning of life?\" \"do I look good in this outfit?\" 1 are not computational problems, because they do not have well-defined input, constraints, and conditions that the output must satisfy. In CS1010 (followed by CS2040C and CS3230), you will learn how to solve computational problems computationally -- this means that you learn to come up with step-by-step instructions meant for computers that you can translate into computer programs, to solve a given problem. Example: Finding the maximum Let's start with a simple problem. Given a finite list \\(L\\) of \\(k\\) integers ( \\(k\\) > 0), find the maximum integer from the list. First, let's consider if this is a computational problem. The input is very well defined. We know what an integer is. We are told we have at least one, and we have a finite number of them 2 . Second, let's consider the output. What conditions must the output satisfy? First, it has to be equal or larger than every other integer on the list. Second, it must be an integer in the list. This is well defined by the problem statement, so we can say that it is a computational problem. Here is an example. Suppose the input consists of: 4 1 -4 0 9 9 3 5 8 The output should be 9 . Now, you should pause reading and think about how you would solve this step-by-step. Algorithm One way to solve this problem is to check through the integers in the list, one-by-one, and keep track of the maximum value so far. When you reach the end of the list, your \"maximum value so far\" will also be the maximum for the whole list. Let's look at an example: Integers Scanned Maximum So Far 4 4 4 1 4 4 1 -4 4 4 1 -4 0 4 4 1 -4 0 9 9 4 1 -4 0 9 9 9 4 1 -4 0 9 9 3 9 4 1 -4 0 9 9 3 5 9 4 1 -4 0 9 9 3 5 8 9 The English description above, however, is not detailed enough for computers to understand. What is the meaning of \"check one-by-one\"? \"keep track of maximum so far\"? how to tell if we have reached \"the end of the list\"? Let's work out all the details. First, we need a concise way of representing the integers in the list. Borrowing from mathematical notation, let's say that the list \\(L\\) contains the integers \\(\\langle l_0, l_1, ..., l_{k-1} \\rangle\\) . To \"check one-by-one,\" we introduce another notation \\(l_i\\) , which is the integer currently being \"checked\". We begin with \\(i = 0\\) , then \\(i = 1\\) , then \\(i = 2\\) , etc, until \\(i = k-1\\) . At every step, we increase \\(i\\) by 1. Second, we need a concise way of keeping track of the maximum so far. We introduce another notation, \\(m\\) , to represent the maximum value so far. When \\(i = 0\\) , \\(m = l_0\\) . Since we only scan a single integer, it has to be the maximum. When we check another integer \\(l_i (i > 0)\\) , only two things can happen: if this \\(l_i\\) is larger than \\(m\\) , then \\(l_i\\) has to be the maximum so far, so we update \\(m\\) to be \\(l_i\\) . if \\(l_i\\) is equal to or smaller than \\(m\\) , then \\(m\\) is still the maximum value so far. We keep doing the above and increase \\(i\\) , until we reach the end of the list when (after increasing \\(i\\) ) we find that \\(i\\) is \\(k\\) . Now, we have enough details to describe step-by-step, how to find the maximum value from a list of integers. Such steps, which the computer can take to solve a problem, is called an algorithm . Flowchart There are different ways one can describe an algorithm. The easiest way I find is to use a diagram called a flowchart . The flowchart for the algorithm above looks like this. There are several components to a flowchart. We will use the following convention in CS1010: An arrow indicates the direction of the flow, i.e., what is the next step of the algorithm. A rounded rectangle denotes either the starting (inputs) or ending point (output) of the algorithm. A diamond box represents a \"question\" that can be true or false (yes or no). It indicates a \"branch\" in the flow. Which branch we follow is deteremined the answer to the question in the box. A rectangle represents one or more \"operations\" (such as initialization or manipulation of data) To understand the flowchart above, let's trace through it with the sample input. We will maintain the following table as we trace through the flowchart. At the beginning, just before entering \" \\(i\\) equals \\(k\\) ?\", we have the following: Integers Scanned \\(i\\) \\(l_i\\) \\(k\\) Maximum So Far ( \\(m\\) ) 4 1 1 9 4 Subsequently, we enter a \"loop\", and the values assigned to the symbols at the point after \" \\(i\\) equals \\(k\\) ?\" can be traced as follows: Integers Scanned \\(i\\) \\(l_i\\) \\(k\\) Maximum So Far ( \\(m\\) ) 4 1 1 1 9 4 4 1 -4 2 -4 9 4 4 1 -4 0 3 0 9 4 4 1 -4 0 9 4 9 9 4 4 1 -4 0 9 9 5 9 9 9 4 1 -4 0 9 9 3 6 3 9 9 4 1 -4 0 9 9 3 5 7 5 9 9 4 1 -4 0 9 9 3 5 8 8 8 9 9 4 1 -4 0 9 9 3 5 8 9 `` 9 9 Please spend some time to trace through the flowchart above. Variables There are a few important things to take note here. \\(m\\) , \\(i\\) , \\(k\\) , and the list \\(L\\) are what we called states or variables . While in the above, we can think of them as mathematical variables which we can assign values to, in a computer program, a variable is a location in the memory which holds a value. We can perform two very basic operations on the variables: reading and writing. In other words, we can set their values and we can retrieve their values. We can assign the value of one variable to a constant (e.g., set \\(i\\) to 1) or to the value of another variable (e.g., set \\(m\\) to \\(l_i\\) ). In the latter example, we first read the value of \\(l_i\\) , from \\(l_i\\) 's memory location and then we write that value to the memory location of \\(m\\) . Once written, the value of \\(m\\) will not change until the next time we update the value of \\(m\\) . It is important to note that, when \\(i\\) changes, \\(m\\) does not change automatically to the new \\(l_i\\) This behavior is different from that which you may be familiar with in spreadsheet software -- if you set the value of a cell, say A1 to be =B1 , when the value in cell B1 changes, the value A1 also changes automatically. We can also compare the values of two variables. We see two examples above: \" \\(i\\) equals \\(k\\) ?\" \" \\(l_i > m\\) ?\" When we compare, we read the values of the variables from their memory location and checks their relations. We can perform arithmetic operations on the variables: addition, subtraction, etc. We see one example above: \"increment \\(i\\) \". This operation is actually an assignment operation in disguise. We can write it as \"set \\(i\\) to \\(i\\) + 1\". Here, you see that \\(i\\) is referred to twice. This operation reads the value from the memory location of \\(i\\) , adds 1 to it, and then writes the resulting value back to the location of \\(i\\) . Bugs If you follow the execution of the algorithm above, step-by-step, using the example input 4 1 -4 0 9 9 3 5 above, you will obtain the correct maximum value \\(m\\) of 9 . But does that mean that the algorithm is correct? The answer is NO. For an algorithm to correctly solve the given problem, it has to produce the correct result for all valid inputs to the problem. If we can find one counterexample, one input where the algorithm does not produce the correct output, then the algorithm is incorrect. Note that I say does not produce the correct output , which means that either the algorithm produces the wrong output or does not produce any output at all . In this case, we say that the algorithm or the program has a bug . A bug is a defect that causes the algorithm to behave incorrectly. As a software developer, you will spend some time finding bugs in your code, a process known as debugging . A debugger is a tool that helps programmers find bugs in their code. Before we even start the process of debugging, we first have to know if our algorithm is correct. Remember that an algorithm is correct only if it produces the correct output only all possible valid inputs. So, one way to check if an algorithm is correct is to try it with all possible valid inputs. For the problem we are solving above, however, even though the list is finite, there are infinitely many possible inputs, and so, it is impossible to try all possible valid inputs. In practice, we craft a smaller set of test inputs to check if the algorithm behaves correctly for these test inputs, and hope that it is correct for all possible inputs. With experience, you will choose the right set of test inputs to maximize that chances that you will find a bug in your code. There are also systematic ways of deriving test cases so that the test cases cover different paths of execution of the algorithm, but we won't be covering it in CS1010 3 . Another way of checking if an algorithm is correct, is to reason about the behavior of the algorithm. We will do this rather informally in CS1010, starting in 1-2 lectures from now. You get to rigorously prove that an algorithm is correct in a higher level module (CS3230 Design and Analysis of Algorithms). Finally, even if an algorithm is correct, the corresponding program might not be. Recall that an algorithm is a step-by-step process to solve a problem. It is what you want your program to do. You still have to write a program (in C, or other languages) to actually have the computer do what you want it to do (in other words, to implement the algorithm ). This process of translating the algorithm to a computer program, called coding may introduce bugs as well. But we will worry about this later when we learn to program. In the problem set at the end of this lecture, you will see slight variations of the algorithm above. You should check through them to see whether they are correct or not. Problem Set Problem 1.1 The following algorithms are slight variations of the one in the notes above. The differences are highlighted in red. Do they correctly find the maximum integer from a finite list of \\(k\\) integers ( \\(k > 0\\) )? If an algorithm is buggy, give a counter-example where the output is incorrect. In addition, give an example input where the algorithm still produces the correct output, where possible. (a) (b) (c) (d) (e) Problem 1.2 Change the algorithm above to find the minimum value instead of the maximum value from the given list \\(L = \\langle l_0, ..., l_{k-1}\\rangle\\) . You can also assume that the list \\(L\\) is finite and \\(k > 0\\) for this question. Problem 1.3 Draw the flowchart for an algorithm, that takes in a list of integers \\(L = \\langle l_0, ..., l_{k-1}\\rangle, k > 0\\) , and compute the sum of all the integers. Think about what variable(s) do you need. The answer is, by the way, always \"Yes.\" \u21a9 Think about why it is important to have a finite number of integers in the input. \u21a9 Software testing is a body of knowledge worthy of an advanced module by itself -- we offer one in CS4218. \u21a9","title":"2. Computational Problem & Algorithms"},{"location":"02-algo.html#unit-2-computational-problems-and-algorithms","text":"","title":"Unit 2: Computational Problems and Algorithms"},{"location":"02-algo.html#learning-outcomes","text":"After this unit, students should: be able to differentiate between a computational and a non-computational problem; understand the basic terminologies: computational problem solving, algorithm, flowchart, debugging, testing, variables, value, assignment; be familiar with the algorithm to find the maximum among a list of numbers; be able to express an algorithm using a flowchart; be able to trace through flowcharts that involves branching, looping, and updates of variables; understand the notion of the \"correctness\" of an algorithm.","title":"Learning Outcomes:"},{"location":"02-algo.html#computational-problems","text":"So, what is computational problem solving? Let's start with the question, what is a computational problem ? A computational problem is a problem that can be solved step-by-step with a computer. These problems usually have a well-defined input, constraints, and conditions that the output must satisfied. Here are some types of computational problems: A decision problem is one where the answer is yes or no. For instance, \"given a number \\(n\\) , is \\(n\\) even?\" is a decision problem. Some decision problems take more steps to solve than others. For instance, \"given a number \\(n\\) , is \\(n\\) prime?\" takes more steps than just checking the parity of a number. A search problem is one where the solution consists of one or more values that satisfies a given condition. For instance, we may want to compute a path from one geographical location to another on a map. A counting problem is one where the answer is the number of solutions to a search problem. An optimization problem is one where the solution is the \"best\" possible solution, where the \"best\" can be defined in a different way. For instance, we may want to compute the fastest route from one location to another. Questions such as \"what is the meaning of life?\" \"do I look good in this outfit?\" 1 are not computational problems, because they do not have well-defined input, constraints, and conditions that the output must satisfy. In CS1010 (followed by CS2040C and CS3230), you will learn how to solve computational problems computationally -- this means that you learn to come up with step-by-step instructions meant for computers that you can translate into computer programs, to solve a given problem.","title":"Computational Problems"},{"location":"02-algo.html#example-finding-the-maximum","text":"Let's start with a simple problem. Given a finite list \\(L\\) of \\(k\\) integers ( \\(k\\) > 0), find the maximum integer from the list. First, let's consider if this is a computational problem. The input is very well defined. We know what an integer is. We are told we have at least one, and we have a finite number of them 2 . Second, let's consider the output. What conditions must the output satisfy? First, it has to be equal or larger than every other integer on the list. Second, it must be an integer in the list. This is well defined by the problem statement, so we can say that it is a computational problem. Here is an example. Suppose the input consists of: 4 1 -4 0 9 9 3 5 8 The output should be 9 . Now, you should pause reading and think about how you would solve this step-by-step.","title":"Example: Finding the maximum"},{"location":"02-algo.html#algorithm","text":"One way to solve this problem is to check through the integers in the list, one-by-one, and keep track of the maximum value so far. When you reach the end of the list, your \"maximum value so far\" will also be the maximum for the whole list. Let's look at an example: Integers Scanned Maximum So Far 4 4 4 1 4 4 1 -4 4 4 1 -4 0 4 4 1 -4 0 9 9 4 1 -4 0 9 9 9 4 1 -4 0 9 9 3 9 4 1 -4 0 9 9 3 5 9 4 1 -4 0 9 9 3 5 8 9 The English description above, however, is not detailed enough for computers to understand. What is the meaning of \"check one-by-one\"? \"keep track of maximum so far\"? how to tell if we have reached \"the end of the list\"? Let's work out all the details. First, we need a concise way of representing the integers in the list. Borrowing from mathematical notation, let's say that the list \\(L\\) contains the integers \\(\\langle l_0, l_1, ..., l_{k-1} \\rangle\\) . To \"check one-by-one,\" we introduce another notation \\(l_i\\) , which is the integer currently being \"checked\". We begin with \\(i = 0\\) , then \\(i = 1\\) , then \\(i = 2\\) , etc, until \\(i = k-1\\) . At every step, we increase \\(i\\) by 1. Second, we need a concise way of keeping track of the maximum so far. We introduce another notation, \\(m\\) , to represent the maximum value so far. When \\(i = 0\\) , \\(m = l_0\\) . Since we only scan a single integer, it has to be the maximum. When we check another integer \\(l_i (i > 0)\\) , only two things can happen: if this \\(l_i\\) is larger than \\(m\\) , then \\(l_i\\) has to be the maximum so far, so we update \\(m\\) to be \\(l_i\\) . if \\(l_i\\) is equal to or smaller than \\(m\\) , then \\(m\\) is still the maximum value so far. We keep doing the above and increase \\(i\\) , until we reach the end of the list when (after increasing \\(i\\) ) we find that \\(i\\) is \\(k\\) . Now, we have enough details to describe step-by-step, how to find the maximum value from a list of integers. Such steps, which the computer can take to solve a problem, is called an algorithm .","title":"Algorithm"},{"location":"02-algo.html#flowchart","text":"There are different ways one can describe an algorithm. The easiest way I find is to use a diagram called a flowchart . The flowchart for the algorithm above looks like this. There are several components to a flowchart. We will use the following convention in CS1010: An arrow indicates the direction of the flow, i.e., what is the next step of the algorithm. A rounded rectangle denotes either the starting (inputs) or ending point (output) of the algorithm. A diamond box represents a \"question\" that can be true or false (yes or no). It indicates a \"branch\" in the flow. Which branch we follow is deteremined the answer to the question in the box. A rectangle represents one or more \"operations\" (such as initialization or manipulation of data) To understand the flowchart above, let's trace through it with the sample input. We will maintain the following table as we trace through the flowchart. At the beginning, just before entering \" \\(i\\) equals \\(k\\) ?\", we have the following: Integers Scanned \\(i\\) \\(l_i\\) \\(k\\) Maximum So Far ( \\(m\\) ) 4 1 1 9 4 Subsequently, we enter a \"loop\", and the values assigned to the symbols at the point after \" \\(i\\) equals \\(k\\) ?\" can be traced as follows: Integers Scanned \\(i\\) \\(l_i\\) \\(k\\) Maximum So Far ( \\(m\\) ) 4 1 1 1 9 4 4 1 -4 2 -4 9 4 4 1 -4 0 3 0 9 4 4 1 -4 0 9 4 9 9 4 4 1 -4 0 9 9 5 9 9 9 4 1 -4 0 9 9 3 6 3 9 9 4 1 -4 0 9 9 3 5 7 5 9 9 4 1 -4 0 9 9 3 5 8 8 8 9 9 4 1 -4 0 9 9 3 5 8 9 `` 9 9 Please spend some time to trace through the flowchart above.","title":"Flowchart"},{"location":"02-algo.html#variables","text":"There are a few important things to take note here. \\(m\\) , \\(i\\) , \\(k\\) , and the list \\(L\\) are what we called states or variables . While in the above, we can think of them as mathematical variables which we can assign values to, in a computer program, a variable is a location in the memory which holds a value. We can perform two very basic operations on the variables: reading and writing. In other words, we can set their values and we can retrieve their values. We can assign the value of one variable to a constant (e.g., set \\(i\\) to 1) or to the value of another variable (e.g., set \\(m\\) to \\(l_i\\) ). In the latter example, we first read the value of \\(l_i\\) , from \\(l_i\\) 's memory location and then we write that value to the memory location of \\(m\\) . Once written, the value of \\(m\\) will not change until the next time we update the value of \\(m\\) . It is important to note that, when \\(i\\) changes, \\(m\\) does not change automatically to the new \\(l_i\\) This behavior is different from that which you may be familiar with in spreadsheet software -- if you set the value of a cell, say A1 to be =B1 , when the value in cell B1 changes, the value A1 also changes automatically. We can also compare the values of two variables. We see two examples above: \" \\(i\\) equals \\(k\\) ?\" \" \\(l_i > m\\) ?\" When we compare, we read the values of the variables from their memory location and checks their relations. We can perform arithmetic operations on the variables: addition, subtraction, etc. We see one example above: \"increment \\(i\\) \". This operation is actually an assignment operation in disguise. We can write it as \"set \\(i\\) to \\(i\\) + 1\". Here, you see that \\(i\\) is referred to twice. This operation reads the value from the memory location of \\(i\\) , adds 1 to it, and then writes the resulting value back to the location of \\(i\\) .","title":"Variables"},{"location":"02-algo.html#bugs","text":"If you follow the execution of the algorithm above, step-by-step, using the example input 4 1 -4 0 9 9 3 5 above, you will obtain the correct maximum value \\(m\\) of 9 . But does that mean that the algorithm is correct? The answer is NO. For an algorithm to correctly solve the given problem, it has to produce the correct result for all valid inputs to the problem. If we can find one counterexample, one input where the algorithm does not produce the correct output, then the algorithm is incorrect. Note that I say does not produce the correct output , which means that either the algorithm produces the wrong output or does not produce any output at all . In this case, we say that the algorithm or the program has a bug . A bug is a defect that causes the algorithm to behave incorrectly. As a software developer, you will spend some time finding bugs in your code, a process known as debugging . A debugger is a tool that helps programmers find bugs in their code. Before we even start the process of debugging, we first have to know if our algorithm is correct. Remember that an algorithm is correct only if it produces the correct output only all possible valid inputs. So, one way to check if an algorithm is correct is to try it with all possible valid inputs. For the problem we are solving above, however, even though the list is finite, there are infinitely many possible inputs, and so, it is impossible to try all possible valid inputs. In practice, we craft a smaller set of test inputs to check if the algorithm behaves correctly for these test inputs, and hope that it is correct for all possible inputs. With experience, you will choose the right set of test inputs to maximize that chances that you will find a bug in your code. There are also systematic ways of deriving test cases so that the test cases cover different paths of execution of the algorithm, but we won't be covering it in CS1010 3 . Another way of checking if an algorithm is correct, is to reason about the behavior of the algorithm. We will do this rather informally in CS1010, starting in 1-2 lectures from now. You get to rigorously prove that an algorithm is correct in a higher level module (CS3230 Design and Analysis of Algorithms). Finally, even if an algorithm is correct, the corresponding program might not be. Recall that an algorithm is a step-by-step process to solve a problem. It is what you want your program to do. You still have to write a program (in C, or other languages) to actually have the computer do what you want it to do (in other words, to implement the algorithm ). This process of translating the algorithm to a computer program, called coding may introduce bugs as well. But we will worry about this later when we learn to program. In the problem set at the end of this lecture, you will see slight variations of the algorithm above. You should check through them to see whether they are correct or not.","title":"Bugs"},{"location":"02-algo.html#problem-set","text":"","title":"Problem Set"},{"location":"02-algo.html#problem-11","text":"The following algorithms are slight variations of the one in the notes above. The differences are highlighted in red. Do they correctly find the maximum integer from a finite list of \\(k\\) integers ( \\(k > 0\\) )? If an algorithm is buggy, give a counter-example where the output is incorrect. In addition, give an example input where the algorithm still produces the correct output, where possible. (a) (b) (c) (d) (e)","title":"Problem 1.1"},{"location":"02-algo.html#problem-12","text":"Change the algorithm above to find the minimum value instead of the maximum value from the given list \\(L = \\langle l_0, ..., l_{k-1}\\rangle\\) . You can also assume that the list \\(L\\) is finite and \\(k > 0\\) for this question.","title":"Problem 1.2"},{"location":"02-algo.html#problem-13","text":"Draw the flowchart for an algorithm, that takes in a list of integers \\(L = \\langle l_0, ..., l_{k-1}\\rangle, k > 0\\) , and compute the sum of all the integers. Think about what variable(s) do you need. The answer is, by the way, always \"Yes.\" \u21a9 Think about why it is important to have a finite number of integers in the input. \u21a9 Software testing is a body of knowledge worthy of an advanced module by itself -- we offer one in CS4218. \u21a9","title":"Problem 1.3"},{"location":"03-func.html","text":"Unit 3: Functions Learning Outcomes: After this unit, students should: understand the concept of a function: (i) function as a high-level abstraction of lower-level operations; (ii) function as a well-defined solution to a sub-problem with zero or more inputs and (possibly) a returned value. be able to see how a problem can be decomposed into sub-problems, each solvable by a function; the functions can then be composed together to solve the original problem; understand the concept of local variables that are internal within a function; be able to apply \"wishful thinking\" in decomposing a problem into sub-problems; apply wishful thinking in solving a problem recursively -- by making a function invokes itself to solve a simpler version of the same problem. Problem: Finding the Range Let's start with another problem. The range of a finite list of at least one integers \\(L\\) is defined as the difference between the maximum and the minimum integers in \\(L\\) . For example, the range for 4 1 -4 0 9 9 3 5 8 is 13 . How do we find the range of a given list? To find the range of a list, we can break the solution down into three subtasks: first, find the maximum, then, find the minimum, and finally, find the difference between the two. From the previous lecture, you already know how to find the maximum and the minimum (from Problem 1.2)! So, in expressing the algorithm to find the range, we can refer to a previous solution to a sub-problem, which we assume we already know how to solve . Let's call our solution to find the maximum value from a given list \\(L\\) as \\(max\\) . \\(max\\) takes as input (i) a list \\(L\\) and (ii) \\(k\\) , the number of integers in \\(L\\) . It produces, or returns , the maximum value among the integers in \\(L\\) . Borrowing from mathematical notation, we use the notation \\(max(L, k)\\) to represent the maximum value of \\(L\\) . Note that, now, we no longer worry about \\(i\\) and \\(m\\) -- these two variables are now internal, or local , to \\(max(L,k)\\) . Suppose that \\(min(L,k)\\) returns the minimum value among the integers in \\(L\\) , then, the algorithm to find the range of \\(L\\) can be written in a single line: \\[max(L, k) - min(L, k)\\] Functions \\(max\\) and \\(min\\) are examples of a powerful and important concept with many names: function , procedure , subroutine , method , subprogram 1 . In the context of CS1010, we will use the term function . Functions allow us to solve a problem by thinking about the solution at a higher level. We no longer concern with the implementation details. For instance, in the example above, we no longer have to think about checking through the items in the list one-by-one and maintaining the maximum so far, or the minimum so far. We just have to think about how to compute the range, assuming that we already know how to compute the maximum and the minimum value. Such an assumption, that we already know how to solve a subproblem, is known as wishful thinking . Sometimes, it is useful to solve a problem assuming that you know how to solve the subproblem first, then worry about solving the subproblem later. For instance, consider the following problem: Given a finite list of \\(k\\) integers ( \\(k > 0\\) ), find the mean. The algorithm again can be written in one line: \\[sum(L, k) / k\\] if we assume that we have a function \\(sum\\) that can help us find the total of all \\(k\\) integers. It turns out, in this case, that you should also know how to solve the subproblem \\(sum\\) since it is Problem 1.3 from last week. We can then make this into a function itself, \\(mean(L, k)\\) , which we can now use to solve other more complex problems. Thinking in terms of functions also has another advantage: given a function, we only need to worry about what it does, but not how it is done. In the \\(max(L,k)\\) example above, we do not care if it scans the list \\(L\\) from \\(l_0\\) to \\(l_{k-1}\\) , or from \\(l_{k-1}\\) to \\(l_0\\) . We can treat a function as a black box with well-defined behavior -- given one or more inputs, it will produce a value satisfying certain conditions, i.e., it solves a computational problem. Many programming languages, including C which we will be using in CS1010, come with a rich set of predefined functions that we can use to help us solve computational problems. In CS1010, we will also provide you with some functions to help you with your lab assignments. You will also define your own functions when solving problems with C. In fact, a C program is just a collection of functions calling each other. Note, however, that in C, a function is more general than the description above: a C function may not take in any input, and it may not return any value. Before we continue, let's simplify the functions we have written so far. Let's suppose that we have another function \\(len(L)\\) that takes in a list as an input, and returns the number of items in the list. With this function, we can remove \\(k\\) as one of the inputs to the function \\(max\\) , \\(min\\) , \\(sum\\) and \\(mean\\) . Instead of defining \\(mean(L, k)\\) to be \\(sum(L, k)/k\\) , we can define the function to be \\(mean(L) = sum(L)/len(L)\\) . We can define \\(k\\) to be a local variable within \\(max\\) , \\(min\\) and \\(sum\\) , initialize it before we start computing the respective answers. Problem: Finding Standard Deviation Let's look at another problem: Given \\(L\\) , a finite list of \\(k\\) integers ( \\(k \\ge 1\\) ), find the standard deviation of the integers in \\(L\\) . First, recall that the (population) standard deviation is given by \\[\\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}}\\] where \\(\\mu\\) is the mean of the integers in \\(L\\) . To compute the standard deviation, we first need to compute \\(\\mu\\) , the mean. We already know how to do that: \\(mean(L)\\) . Then, we need to compute \\(\\sum_{i=0}^{k-1} (l_i - \\mu)^2\\) . We can break it down into two subproblems: Given a list \\(L\\) and a constant value \\(x\\) , subtract \\(x\\) from every number in \\(L\\) , giving us a new list. Given a list, square every number in the list, giving us a new list. For now, let's apply wishful thinking and assume that we know how to compute the above two steps with functions \\(subtract(L, x)\\) and \\(square(L)\\) , then, the formula \\(\\sum_{i=0}^{k-1} (l_i - \\mu)^2\\) can be computed by the following steps: set \\(\\mu\\) to \\(mean(L)\\) set \\(L'\\) to \\(subtract(L, \\mu)\\) set \\(L''\\) to \\(square(L')\\) set \\(total\\) to \\(sum(L'')\\) . We can also write it in one line: set \\(total\\) to \\(sum(square(subtract(L, mean(L))))\\) Now, to compute the standard deviation, we need to divide \\(total\\) by \\(len(L)\\) and find the square root. But, finding \\(total\\) and dividing the result by \\(len(L)\\) is just \\(mean\\) . To compute square root, we again apply wishful thinking and assume that there is a function \\(sqrt\\) to do so. We can now compute the standard deviation with one line: \\[sqrt(mean(square(subtract(L, mean(L)))))\\] Using functions, we can easily pass the output from one function as input to another, essentially chain the functions together, like Lego blocks, to solve problems. We also see an example of reuse here -- \\(mean\\) is used twice with different inputs. Returning a list While the above one-liner is an elegant solution, when we actually implement this in C later, it will not so simple and elegant. Let's worry about that later. Now that we have seen how to compute standard deviation by breaking it down the four subproblems, \\(sqrt\\) , \\(mean\\) , \\(square\\) , and \\(subtract\\) , we have to make sure that things we wish can be done can actually be done. The C library, and many programming languages, provide a pre-defined method to compute \\(sqrt\\) . We already know how to compute \\(mean\\) . Computing \\(square\\) can be done as follows: The implementation of \\(subtract\\) is similar. Another Two Solutions for Finding Maximum In the previous lecture, you have seen an algorithm to find the maximum value from a list of integers, which involves checking the elements one-by-one and keeping track of the maximum value so far. Now that we have seen what a function is, we can use the concept of wishful thinking to help us solve this problem in a different way and more elegant way. Let's suppose that we have a function \\(max'(L, i, j)\\) , that finds the maximum integer among the elements \\(l_i, l_{i+1}, ... l_j\\) . The function \\(max(L, k)\\) , which finds the maximum among all elements of \\(L\\) , is therefore the same as \\(max'(L, 0, k-1)\\) . Do we know how to solve \\(max'(L, i, j)\\) without checking the integers in \\(L\\) one-by-one? Well, if \\(i\\) equals to \\(j\\) , i.e., there is only one element in the range of \\(l_i, ..., l_j\\) , then yes, the function should simply return the value of \\(l_i\\) . But, what if there are multiple elements in the range? (i.e., \\(i < j\\) )? By wishful thinking, we assume that we already know how to solve smaller (as in a shorter list) problem -- \\(max'(L, i+1, j)\\) , so the maximum value for the range of \\(l_i, ..., l_j\\) is the larger of the two: either \\(l_i\\) or \\(max'(L, i+1, j)\\) . We can express this algorithm as follows: Let's trace through the algorithm above, using our previous example: 4 1 -4 0 9 9 3 5 8 . Given this list, we compare the first element, 4 , with the maximum of the rest of the list 1 -4 0 9 9 3 5 8 , computed with \\(max'(L, 1,8)\\) . With wishful thinking, we know how to solve \\(max'\\) already -- we get \\(max'(L,1,8)\\) = 9 as the maximum value of 1 -4 0 9 9 3 5 8 . Comparing 4 and 9 , 9 is larger. Thus, the maximum of the whole list is 9 . The solution above involves \\(max'\\) calling itself once to solve the problem. It breaks the problem of finding the maximum in a list of \\(k\\) items into the problem of finding the maximum in a list of \\(k-1\\) items. Now, let's consider a second possibility. What if we break the list into two lists of (roughly) equal length? Let's consider the example 4 1 -4 0 9 9 3 5 . We keep the list to eight items this time so that it is neater example. We can break the list into two smaller lists: 4 1 -4 0 and 9 9 3 5 . By wishful thinking, we know how to find the maximum among 4 1 -4 0 (which is 4 ) and 9 9 3 5 (which is 9 ). What remains is just to pick the larger of the two and we have the maximum of the two lists! Given \\(max'(L, i, j)\\) , if we let \\(n = \\left\\lfloor(i+j)/2\\right\\rfloor\\) , then we can solve \\(max'(L,i,j)\\) by solving two smaller, almost equally sized, sub-problems, \\(max'(L,i,n)\\) and \\(max'(L,n+1,j)\\) . We can express this algorithm as follows: This problem solving technique is called divide-and-conquer . You will see this technique again many times in CS1010, CS2040C, CS3230, and the rest of your computing career. A nice property of this technique is that, if we have more than one processing units, we can ask them to compute \\(max'(L,i,n)\\) and \\(max'(L,n+1,j)\\) in parallel, and thus getting the answer we are looking for, earlier! Example: Finding a Factorial Let us look at another example of a function before we move on to another topic. Suppose we want to write a function \\(factorial(n)\\) for an integer \\(n\\) ( \\(n \\ge 0\\) ) that computes \\(n!\\) . Recall that \\(n! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)!\\) . As a special case, \\(0!\\) is defined to be \\(1\\) . The algorithm to do this can be expressed by the following diagram: Let's look at an example. Let's say we want to compute \\(factorial(4)\\) . We assume we know how to solve this for a smaller problem -- \\(factorial(3)\\) , which is 6. \\(factorial(4)\\) is thus 4 \\(\\times\\) 6, i.e., 24. Recursion: Function Calling Itself \\(max'\\) and \\(factorial\\) are examples of functions that calls itself to solve a simpler version of the problem. This is known as recursion . We will revisit this concept in much greater detail in the later part of CS1010. Problem Set Problem 3.1 : Getting MAD The mean absolute deviation, or MAD, of a set of integers measures how spread out a set of data is. The absolute deviation is the absolute difference between an element in the list with the mean of values of the list. The mean absolute deviation is the mean of all the absolute difference. In other words, given \\(L = \\{l_0, ... l_{k-1}\\}\\) , the MAD of \\(L\\) is: \\[\\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k}\\] How do you find MAD by composing various functions we have seen? Do you need a new function? Problem 3.2 : Ownself calls ownself (a) Give an algorithm for finding the sum of all the integers in the list \\(L\\) with \\(k\\) ( \\(k > 0\\) ) integers that is recursive. (b) The function \\(pow(i, j)\\) computes \\(i^j\\) . Give an algorithm to compute \\(pow(i, j)\\) recursively. There are subtle differences between these terms -- but they are all a form of functional abstraction , where we abstract out the detailed operations and represent it with a single higher-level \"action\". \u21a9","title":"3. Functions"},{"location":"03-func.html#unit-3-functions","text":"","title":"Unit 3: Functions"},{"location":"03-func.html#learning-outcomes","text":"After this unit, students should: understand the concept of a function: (i) function as a high-level abstraction of lower-level operations; (ii) function as a well-defined solution to a sub-problem with zero or more inputs and (possibly) a returned value. be able to see how a problem can be decomposed into sub-problems, each solvable by a function; the functions can then be composed together to solve the original problem; understand the concept of local variables that are internal within a function; be able to apply \"wishful thinking\" in decomposing a problem into sub-problems; apply wishful thinking in solving a problem recursively -- by making a function invokes itself to solve a simpler version of the same problem.","title":"Learning Outcomes:"},{"location":"03-func.html#problem-finding-the-range","text":"Let's start with another problem. The range of a finite list of at least one integers \\(L\\) is defined as the difference between the maximum and the minimum integers in \\(L\\) . For example, the range for 4 1 -4 0 9 9 3 5 8 is 13 . How do we find the range of a given list? To find the range of a list, we can break the solution down into three subtasks: first, find the maximum, then, find the minimum, and finally, find the difference between the two. From the previous lecture, you already know how to find the maximum and the minimum (from Problem 1.2)! So, in expressing the algorithm to find the range, we can refer to a previous solution to a sub-problem, which we assume we already know how to solve . Let's call our solution to find the maximum value from a given list \\(L\\) as \\(max\\) . \\(max\\) takes as input (i) a list \\(L\\) and (ii) \\(k\\) , the number of integers in \\(L\\) . It produces, or returns , the maximum value among the integers in \\(L\\) . Borrowing from mathematical notation, we use the notation \\(max(L, k)\\) to represent the maximum value of \\(L\\) . Note that, now, we no longer worry about \\(i\\) and \\(m\\) -- these two variables are now internal, or local , to \\(max(L,k)\\) . Suppose that \\(min(L,k)\\) returns the minimum value among the integers in \\(L\\) , then, the algorithm to find the range of \\(L\\) can be written in a single line: \\[max(L, k) - min(L, k)\\]","title":"Problem: Finding the Range"},{"location":"03-func.html#functions","text":"\\(max\\) and \\(min\\) are examples of a powerful and important concept with many names: function , procedure , subroutine , method , subprogram 1 . In the context of CS1010, we will use the term function . Functions allow us to solve a problem by thinking about the solution at a higher level. We no longer concern with the implementation details. For instance, in the example above, we no longer have to think about checking through the items in the list one-by-one and maintaining the maximum so far, or the minimum so far. We just have to think about how to compute the range, assuming that we already know how to compute the maximum and the minimum value. Such an assumption, that we already know how to solve a subproblem, is known as wishful thinking . Sometimes, it is useful to solve a problem assuming that you know how to solve the subproblem first, then worry about solving the subproblem later. For instance, consider the following problem: Given a finite list of \\(k\\) integers ( \\(k > 0\\) ), find the mean. The algorithm again can be written in one line: \\[sum(L, k) / k\\] if we assume that we have a function \\(sum\\) that can help us find the total of all \\(k\\) integers. It turns out, in this case, that you should also know how to solve the subproblem \\(sum\\) since it is Problem 1.3 from last week. We can then make this into a function itself, \\(mean(L, k)\\) , which we can now use to solve other more complex problems. Thinking in terms of functions also has another advantage: given a function, we only need to worry about what it does, but not how it is done. In the \\(max(L,k)\\) example above, we do not care if it scans the list \\(L\\) from \\(l_0\\) to \\(l_{k-1}\\) , or from \\(l_{k-1}\\) to \\(l_0\\) . We can treat a function as a black box with well-defined behavior -- given one or more inputs, it will produce a value satisfying certain conditions, i.e., it solves a computational problem. Many programming languages, including C which we will be using in CS1010, come with a rich set of predefined functions that we can use to help us solve computational problems. In CS1010, we will also provide you with some functions to help you with your lab assignments. You will also define your own functions when solving problems with C. In fact, a C program is just a collection of functions calling each other. Note, however, that in C, a function is more general than the description above: a C function may not take in any input, and it may not return any value. Before we continue, let's simplify the functions we have written so far. Let's suppose that we have another function \\(len(L)\\) that takes in a list as an input, and returns the number of items in the list. With this function, we can remove \\(k\\) as one of the inputs to the function \\(max\\) , \\(min\\) , \\(sum\\) and \\(mean\\) . Instead of defining \\(mean(L, k)\\) to be \\(sum(L, k)/k\\) , we can define the function to be \\(mean(L) = sum(L)/len(L)\\) . We can define \\(k\\) to be a local variable within \\(max\\) , \\(min\\) and \\(sum\\) , initialize it before we start computing the respective answers.","title":"Functions"},{"location":"03-func.html#problem-finding-standard-deviation","text":"Let's look at another problem: Given \\(L\\) , a finite list of \\(k\\) integers ( \\(k \\ge 1\\) ), find the standard deviation of the integers in \\(L\\) . First, recall that the (population) standard deviation is given by \\[\\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}}\\] where \\(\\mu\\) is the mean of the integers in \\(L\\) . To compute the standard deviation, we first need to compute \\(\\mu\\) , the mean. We already know how to do that: \\(mean(L)\\) . Then, we need to compute \\(\\sum_{i=0}^{k-1} (l_i - \\mu)^2\\) . We can break it down into two subproblems: Given a list \\(L\\) and a constant value \\(x\\) , subtract \\(x\\) from every number in \\(L\\) , giving us a new list. Given a list, square every number in the list, giving us a new list. For now, let's apply wishful thinking and assume that we know how to compute the above two steps with functions \\(subtract(L, x)\\) and \\(square(L)\\) , then, the formula \\(\\sum_{i=0}^{k-1} (l_i - \\mu)^2\\) can be computed by the following steps: set \\(\\mu\\) to \\(mean(L)\\) set \\(L'\\) to \\(subtract(L, \\mu)\\) set \\(L''\\) to \\(square(L')\\) set \\(total\\) to \\(sum(L'')\\) . We can also write it in one line: set \\(total\\) to \\(sum(square(subtract(L, mean(L))))\\) Now, to compute the standard deviation, we need to divide \\(total\\) by \\(len(L)\\) and find the square root. But, finding \\(total\\) and dividing the result by \\(len(L)\\) is just \\(mean\\) . To compute square root, we again apply wishful thinking and assume that there is a function \\(sqrt\\) to do so. We can now compute the standard deviation with one line: \\[sqrt(mean(square(subtract(L, mean(L)))))\\] Using functions, we can easily pass the output from one function as input to another, essentially chain the functions together, like Lego blocks, to solve problems. We also see an example of reuse here -- \\(mean\\) is used twice with different inputs. Returning a list While the above one-liner is an elegant solution, when we actually implement this in C later, it will not so simple and elegant. Let's worry about that later. Now that we have seen how to compute standard deviation by breaking it down the four subproblems, \\(sqrt\\) , \\(mean\\) , \\(square\\) , and \\(subtract\\) , we have to make sure that things we wish can be done can actually be done. The C library, and many programming languages, provide a pre-defined method to compute \\(sqrt\\) . We already know how to compute \\(mean\\) . Computing \\(square\\) can be done as follows: The implementation of \\(subtract\\) is similar.","title":"Problem: Finding Standard Deviation"},{"location":"03-func.html#another-two-solutions-for-finding-maximum","text":"In the previous lecture, you have seen an algorithm to find the maximum value from a list of integers, which involves checking the elements one-by-one and keeping track of the maximum value so far. Now that we have seen what a function is, we can use the concept of wishful thinking to help us solve this problem in a different way and more elegant way. Let's suppose that we have a function \\(max'(L, i, j)\\) , that finds the maximum integer among the elements \\(l_i, l_{i+1}, ... l_j\\) . The function \\(max(L, k)\\) , which finds the maximum among all elements of \\(L\\) , is therefore the same as \\(max'(L, 0, k-1)\\) . Do we know how to solve \\(max'(L, i, j)\\) without checking the integers in \\(L\\) one-by-one? Well, if \\(i\\) equals to \\(j\\) , i.e., there is only one element in the range of \\(l_i, ..., l_j\\) , then yes, the function should simply return the value of \\(l_i\\) . But, what if there are multiple elements in the range? (i.e., \\(i < j\\) )? By wishful thinking, we assume that we already know how to solve smaller (as in a shorter list) problem -- \\(max'(L, i+1, j)\\) , so the maximum value for the range of \\(l_i, ..., l_j\\) is the larger of the two: either \\(l_i\\) or \\(max'(L, i+1, j)\\) . We can express this algorithm as follows: Let's trace through the algorithm above, using our previous example: 4 1 -4 0 9 9 3 5 8 . Given this list, we compare the first element, 4 , with the maximum of the rest of the list 1 -4 0 9 9 3 5 8 , computed with \\(max'(L, 1,8)\\) . With wishful thinking, we know how to solve \\(max'\\) already -- we get \\(max'(L,1,8)\\) = 9 as the maximum value of 1 -4 0 9 9 3 5 8 . Comparing 4 and 9 , 9 is larger. Thus, the maximum of the whole list is 9 . The solution above involves \\(max'\\) calling itself once to solve the problem. It breaks the problem of finding the maximum in a list of \\(k\\) items into the problem of finding the maximum in a list of \\(k-1\\) items. Now, let's consider a second possibility. What if we break the list into two lists of (roughly) equal length? Let's consider the example 4 1 -4 0 9 9 3 5 . We keep the list to eight items this time so that it is neater example. We can break the list into two smaller lists: 4 1 -4 0 and 9 9 3 5 . By wishful thinking, we know how to find the maximum among 4 1 -4 0 (which is 4 ) and 9 9 3 5 (which is 9 ). What remains is just to pick the larger of the two and we have the maximum of the two lists! Given \\(max'(L, i, j)\\) , if we let \\(n = \\left\\lfloor(i+j)/2\\right\\rfloor\\) , then we can solve \\(max'(L,i,j)\\) by solving two smaller, almost equally sized, sub-problems, \\(max'(L,i,n)\\) and \\(max'(L,n+1,j)\\) . We can express this algorithm as follows: This problem solving technique is called divide-and-conquer . You will see this technique again many times in CS1010, CS2040C, CS3230, and the rest of your computing career. A nice property of this technique is that, if we have more than one processing units, we can ask them to compute \\(max'(L,i,n)\\) and \\(max'(L,n+1,j)\\) in parallel, and thus getting the answer we are looking for, earlier!","title":"Another Two Solutions for Finding Maximum"},{"location":"03-func.html#example-finding-a-factorial","text":"Let us look at another example of a function before we move on to another topic. Suppose we want to write a function \\(factorial(n)\\) for an integer \\(n\\) ( \\(n \\ge 0\\) ) that computes \\(n!\\) . Recall that \\(n! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)!\\) . As a special case, \\(0!\\) is defined to be \\(1\\) . The algorithm to do this can be expressed by the following diagram: Let's look at an example. Let's say we want to compute \\(factorial(4)\\) . We assume we know how to solve this for a smaller problem -- \\(factorial(3)\\) , which is 6. \\(factorial(4)\\) is thus 4 \\(\\times\\) 6, i.e., 24.","title":"Example: Finding a Factorial"},{"location":"03-func.html#recursion-function-calling-itself","text":"\\(max'\\) and \\(factorial\\) are examples of functions that calls itself to solve a simpler version of the problem. This is known as recursion . We will revisit this concept in much greater detail in the later part of CS1010.","title":"Recursion: Function Calling Itself"},{"location":"03-func.html#problem-set","text":"","title":"Problem Set"},{"location":"03-func.html#problem-31-getting-mad","text":"The mean absolute deviation, or MAD, of a set of integers measures how spread out a set of data is. The absolute deviation is the absolute difference between an element in the list with the mean of values of the list. The mean absolute deviation is the mean of all the absolute difference. In other words, given \\(L = \\{l_0, ... l_{k-1}\\}\\) , the MAD of \\(L\\) is: \\[\\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k}\\] How do you find MAD by composing various functions we have seen? Do you need a new function?","title":"Problem 3.1 : Getting MAD"},{"location":"03-func.html#problem-32-ownself-calls-ownself","text":"(a) Give an algorithm for finding the sum of all the integers in the list \\(L\\) with \\(k\\) ( \\(k > 0\\) ) integers that is recursive. (b) The function \\(pow(i, j)\\) computes \\(i^j\\) . Give an algorithm to compute \\(pow(i, j)\\) recursively. There are subtle differences between these terms -- but they are all a form of functional abstraction , where we abstract out the detailed operations and represent it with a single higher-level \"action\". \u21a9","title":"Problem 3.2 : Ownself calls ownself"},{"location":"04-type.html","text":"Unit 4: Types Learning Outcomes: After this unit, students should: understand the concept of type as a way to interpret the meaning of bits in the memory; be able to calculate the number of different possible values that can be represented by a given number of bits; understand that different types require a different number of bits for representation; be aware that real numbers may not be represented precisely in a computer, and so real numbers should never be used as a type of an integer value; be aware that C is a statically-typed language, in contrast to Python and Javascript, which are dynamically-typed; be aware that the type for all C variables and functions must be declared; be aware that choosing the wrong type could lead to an incorrect implementation of an algorithm. Bits and Bytes Recall from Unit 1 that machine code and data manipulated by machine code are all stored as a sequence of 1s and 0s in the memory. Each unit of either 1 or 0 is known as a bit . 8 bits form a byte . Remember from Unit 2 that a variable is a memory location that stores a value, as a sequence of bits. The bits stored in the memory has no meaning by itself. It has to be interpreted by the machine code. Does a sequence of 1s and 0s represent an integer? A pixel of an image? A sound sample in an audio clip? A month? As a programmer, we have to tag the variable with its type , so that the machine code knows how to interpret the sequence of bits. In addition, the type also tells the machine code, how many bits \"belong\" to this variable. The number of bits of a type is also known as the size of a type. The size of a type determines how many different values a variable of that type can hold. For instance, a type of one bit can only hold two possible values (e.g., 0 or 1 , true or false , black or white ). A type of two bits can hold four values, represented as 00 , 01 , 10 , 11 . In general, a type of \\(k\\) bits can hold \\(2^k\\) values. Integers To represent integers, a type of 8 bits can represent 256 different values. If the type only represents non-negative integers (called unsigned ), then it can hold any value between 0 to 255. If it represents both positive and negative integers (called signed ), it can hold any value between -128 to 127. Depending on the needs (how much memory we have, how big is the number we need to represent), programmers have to decide on the size of the type used for a variable in their programs. With 64 bits, a signed integer can store any value between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807. This might look big enough for you -- but we can't even fit the results from \\(factorial(21)\\) here! We have to go to 128 bits to represent larger integers. Characters To represent a character (i.e., a symbol representing a letter, number, punctuation, etc), we use 8 bits for English characters. The ASCII standard maps 127 binary sequences to common characters you can type on your keyboard (including 0-9, A-Z, a-z, all sorts of punctuations: <>?:\"{}!@#$%^&*()_+-=[]\\';/., and special characters like return and escape). The Unicode standard uses up to 32 bits per character, allowing many non-English letter characters (e.g., Emoticons , Braille , Mahjong Tiles ) to be represented. Real Numbers For real numbers, because we need to represent a huge number of possible values, we normally use 32 bits or 64 bits. In CS1231, you will learn that there are uncountably many possible real numbers. But, no matter how many bits we use, we can only represent a finite number of possible values for real numbers. Here, we run into a limit of digitizing information into 0s and 1s -- we can never represent all possible real numbers in a computer! Because of this, programs that manipulate real numbers leads to weird answers (such as 1.1 + 2.2 becomes 3.3000000000000003 ) and so, we have to take special care when dealing with real numbers when writing programs (not just in C, but in many other languages as well). Hence, if we only expect a variable to hold an integer, we should not choose a type that represents real numbers . The details of how a sequence of bits can represent integers and real numbers (both positive and negative numbers) are covered in CS2100. You should have also noticed that in the discussion above, we talk about types that are 8, 16, 32, 64, 128 bits -- all power of twos. We do not have a type of size, say, 41 bits. The reason for this has to do with how memory location is addressed. This will again be explained in CS2100. Compound Types In programming, we can represent more complex concepts with compound types , that consists of primitive types such as integers, real numbers, and characters. A sentence, for instance, can be represented as a sequence of characters (called string ). A point, for instance, can be represent a pair of real numbers \\((x,y)\\) . Type Declaration In C, which we will use in CS1010, we have to associate every variable with a type, and once a variable is declared with a type, the type cannot be changed. This behavior is known as static typing. Some programming languages, such as Javascript and Python, are dynamically typed. The type of a variable may change depending on the value the variable is assigned to. When we write a function, we have to declare the types of each of the parameters and the return value as well. Take the function \\(mean(L, k)\\) as an example. We have said that \\(L\\) is a list 1 of integers. So each element in \\(L\\) should have an integer type (how many bits to use will depend on the range of numbers we want the program to possibly handle and how frugal we are about memory usage). What about \\(k\\) ? \\(k\\) refers to the number of elements in \\(L\\) , so it has to be an integer. As for the value returned by \\(mean(L, k)\\) , even when the inputs are all integers (and thus, the sum is an integer), the mean value can be a real number. So we should choose a type that represents a real number for the return value. Importance of Type Choosing the wrong type to represent a variable can lead to buggy code. Suppose we say that \\(mean(L, k)\\) returns an integer, then when we call \\(mean\\) on the input 1 2 3 4 , we will get 2 as the answer, instead of 2.5 as it should. We have not talked about how to represent a list yet. I will do that in a later unit. \u21a9","title":"4. Types"},{"location":"04-type.html#unit-4-types","text":"","title":"Unit 4: Types"},{"location":"04-type.html#learning-outcomes","text":"After this unit, students should: understand the concept of type as a way to interpret the meaning of bits in the memory; be able to calculate the number of different possible values that can be represented by a given number of bits; understand that different types require a different number of bits for representation; be aware that real numbers may not be represented precisely in a computer, and so real numbers should never be used as a type of an integer value; be aware that C is a statically-typed language, in contrast to Python and Javascript, which are dynamically-typed; be aware that the type for all C variables and functions must be declared; be aware that choosing the wrong type could lead to an incorrect implementation of an algorithm.","title":"Learning Outcomes:"},{"location":"04-type.html#bits-and-bytes","text":"Recall from Unit 1 that machine code and data manipulated by machine code are all stored as a sequence of 1s and 0s in the memory. Each unit of either 1 or 0 is known as a bit . 8 bits form a byte . Remember from Unit 2 that a variable is a memory location that stores a value, as a sequence of bits. The bits stored in the memory has no meaning by itself. It has to be interpreted by the machine code. Does a sequence of 1s and 0s represent an integer? A pixel of an image? A sound sample in an audio clip? A month? As a programmer, we have to tag the variable with its type , so that the machine code knows how to interpret the sequence of bits. In addition, the type also tells the machine code, how many bits \"belong\" to this variable. The number of bits of a type is also known as the size of a type. The size of a type determines how many different values a variable of that type can hold. For instance, a type of one bit can only hold two possible values (e.g., 0 or 1 , true or false , black or white ). A type of two bits can hold four values, represented as 00 , 01 , 10 , 11 . In general, a type of \\(k\\) bits can hold \\(2^k\\) values.","title":"Bits and Bytes"},{"location":"04-type.html#integers","text":"To represent integers, a type of 8 bits can represent 256 different values. If the type only represents non-negative integers (called unsigned ), then it can hold any value between 0 to 255. If it represents both positive and negative integers (called signed ), it can hold any value between -128 to 127. Depending on the needs (how much memory we have, how big is the number we need to represent), programmers have to decide on the size of the type used for a variable in their programs. With 64 bits, a signed integer can store any value between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807. This might look big enough for you -- but we can't even fit the results from \\(factorial(21)\\) here! We have to go to 128 bits to represent larger integers.","title":"Integers"},{"location":"04-type.html#characters","text":"To represent a character (i.e., a symbol representing a letter, number, punctuation, etc), we use 8 bits for English characters. The ASCII standard maps 127 binary sequences to common characters you can type on your keyboard (including 0-9, A-Z, a-z, all sorts of punctuations: <>?:\"{}!@#$%^&*()_+-=[]\\';/., and special characters like return and escape). The Unicode standard uses up to 32 bits per character, allowing many non-English letter characters (e.g., Emoticons , Braille , Mahjong Tiles ) to be represented.","title":"Characters"},{"location":"04-type.html#real-numbers","text":"For real numbers, because we need to represent a huge number of possible values, we normally use 32 bits or 64 bits. In CS1231, you will learn that there are uncountably many possible real numbers. But, no matter how many bits we use, we can only represent a finite number of possible values for real numbers. Here, we run into a limit of digitizing information into 0s and 1s -- we can never represent all possible real numbers in a computer! Because of this, programs that manipulate real numbers leads to weird answers (such as 1.1 + 2.2 becomes 3.3000000000000003 ) and so, we have to take special care when dealing with real numbers when writing programs (not just in C, but in many other languages as well). Hence, if we only expect a variable to hold an integer, we should not choose a type that represents real numbers . The details of how a sequence of bits can represent integers and real numbers (both positive and negative numbers) are covered in CS2100. You should have also noticed that in the discussion above, we talk about types that are 8, 16, 32, 64, 128 bits -- all power of twos. We do not have a type of size, say, 41 bits. The reason for this has to do with how memory location is addressed. This will again be explained in CS2100.","title":"Real Numbers"},{"location":"04-type.html#compound-types","text":"In programming, we can represent more complex concepts with compound types , that consists of primitive types such as integers, real numbers, and characters. A sentence, for instance, can be represented as a sequence of characters (called string ). A point, for instance, can be represent a pair of real numbers \\((x,y)\\) .","title":"Compound Types"},{"location":"04-type.html#type-declaration","text":"In C, which we will use in CS1010, we have to associate every variable with a type, and once a variable is declared with a type, the type cannot be changed. This behavior is known as static typing. Some programming languages, such as Javascript and Python, are dynamically typed. The type of a variable may change depending on the value the variable is assigned to. When we write a function, we have to declare the types of each of the parameters and the return value as well. Take the function \\(mean(L, k)\\) as an example. We have said that \\(L\\) is a list 1 of integers. So each element in \\(L\\) should have an integer type (how many bits to use will depend on the range of numbers we want the program to possibly handle and how frugal we are about memory usage). What about \\(k\\) ? \\(k\\) refers to the number of elements in \\(L\\) , so it has to be an integer. As for the value returned by \\(mean(L, k)\\) , even when the inputs are all integers (and thus, the sum is an integer), the mean value can be a real number. So we should choose a type that represents a real number for the return value. Importance of Type Choosing the wrong type to represent a variable can lead to buggy code. Suppose we say that \\(mean(L, k)\\) returns an integer, then when we call \\(mean\\) on the input 1 2 3 4 , we will get 2 as the answer, instead of 2.5 as it should. We have not talked about how to represent a list yet. I will do that in a later unit. \u21a9","title":"Type Declaration"},{"location":"05-first-c.html","text":"Unit 5: First C Program Learning Objectives: After this unit, students should: be able to define functions in C, including the definition of: the function name, the parameters of the function, return statement type, the body of the function, and the return statement; understand the usage of the main function in C programs; be able to make function calls in C programs; understand how values are assigned to the parameters of functions; understand the concept of variable scope; be able to write statements in C programs, including: variable declarations, assignment statements, and statements that include simple expressions (e.g., arithmetic expressions); understand the need and the purpose of including header files; be aware of the different numeric types in C and their respective value ranges; be able to use man to lookup information about functions provided by other C libraries be aware that CS1010 bans the use of global variables and only allows long and double as numeric types. Your First C Function In this unit, we will write and compile your first C program. You have already learned, conceptually, what is a variable, what is a type, and what is a function. Let's see how we apply these concepts to C. To start, let's look at a simple snippet of C code: 1 2 3 4 int square ( int x ) { return x * x ; } The code above defines a function named square . The word int appears before the name square . int is used to signify an integer type. Appearing before the name square tells the compiler that square is returning a value of type int . After the word square , we write the parameters to the function in parenthesis ( and ) . In between ( and ) is int x : x is the name of the parameter, int is the type of that parameter. To summarize, in Line 1, int square(int x) defines a function named square that takes in an integer parameter x and is returning a value, which is also an integer. This line is known as the header of the function. The next three lines are written in between curly brackets { and } . You will see these used a lot in C and other programming languages with C-like syntaxes, such as Javascript, C++, and Java. These curly brackets group a block of statements together. In this example, this block defines how the function square computes the square of x , and what it returns. This is the body of the function. In this function body, there is only one statement return x * x; within the block. A statement is a unit in a programming language that expresses either a command to be executed or declares a new variable or function. The word return says that this function square should return the following value, computed as x * x ( x multiply by x ). This statement is terminated by a semicolon ; . You also see that the line that starts with return is indented. We use indentation extensively to indicate the body of a block. Since we can have nested blocks, indentation makes our code easier to read and understand. The words int and return that appear above are keywords defined in the C programming language, and they are reserved for the special meaning that they represent (a type and a command to return a value from a function). We cannot repurpose keywords in C. For instance, we cannot introduce a variable called int . We are now ready to write our first C program. The first program computes the square of the hypotenuse of a right-angled triangle with a base of 4 and a height of 3. 1 2 3 4 5 6 7 8 9 10 11 12 int square ( int x ) { return x * x ; } int main () { int hypotenuse_square ; hypotenuse_square = square ( 3 ) + square ( 4 ); return 0 ; } Remember that a C program consists of a bunch of functions, calling each other. The most important function is called main , and it is the entry point to the program. It is where the operating system will begin to execute the program. Every program must define exactly one function called main . 1 2 3 4 int main () { : } main returns an integer of type int to the operating system, to signal to the operating system whether the program exits successfully or not. In this case, we always return 0 (success) assuming that nothing goes wrong for simplicity. This is the second example where you see the keyword return in action. In modern C, the main always returns 0 when it exits. So, we will skip this statement return 0; from now on. Variable Declaration In the example above, you also see the lines 1 int hypotenuse_square ; This is a declaration statement (terminated with a semicolon, again). Each statement declares a variable with its corresponding type ( int here). We gave each variable a name, here we call the variable hypotenuse_square . All variables must be declared with its corresponding type before used in C . What declaration does is that it causes a slot in the computing device memory to be reserved for the value of this variable. The type indicates how many bits should be reserved (i.e., how big should the slot be). Each declaration is valid only within the scope of its declaration. A variable is only visible within the innermost block that encloses the declaration, as specified by the { and } . In the example above, the variable hypotenuse_square is visible only in the body of main , but not in the body of square . We cannot redeclare the same variable (i.e., with the same name), with the same type or otherwise, within the same scope. Two variables in different blocks, however, are allowed to have the same name. 1 2 3 4 5 6 7 8 int main () { int hypotenuse_square ; hypotenuse_square = square ( 3 ) + square ( 4 ); int hypotenuse_square ; // <-- redeclaration return 0 ; } The example above would lead to an error on Line 7. The C language allows the declaration of a variable outside of any block. In this case, the scope of the variable is the entire file -- which means that the variable can be accessed and modified from anywhere in the code. Such a variable is called global variable . 1 2 3 4 5 6 7 8 9 10 11 12 int square ( int x ) { return x * x ; } int hypotenuse_square ; // <- global variable int main () { hypotenuse_square = square ( 3 ) + square ( 4 ); return 0 ; } While C allows global variables to be declared and used. The use of global variables is banned in CS1010. CS1010 allows only a subset of C to be used. Particularly, C features that are common pitfalls for beginners and bug-prone are banned. This is so that we can focus this module on problem-solving techniques, rather than the idiosyncrasy of C. Function Declaration In C, a function must be either defined or declared before used as well. In the example above, we define square before main . If we switch the order of the two, the compiler will complain. Unless we declare the function first. Declaring a function means that we simply state the return type, the name, and the parameters, without the body. Here is an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int square ( int x ); // declaring the function square int main () { int hypotenuse_square ; hypotenuse_square = square ( 3 ) + square ( 4 ); return 0 ; } int square ( int x ) // defining the function square { return x * x ; } Assignment Statement The next line of the code shows an example of an assignment statement. 1 hypotenuse_square = square ( 3 ) + square ( 4 ); An assignment operator takes the form of: 1 left_hand_side = right_hand_side ; The left_hand_side must be the name of a variable. We first evaluate the right_hand_side of the assignment statement, find its value, then assign the value to the variable named on the left_hand_side . Essentially, this step updates the bits in the memory location reserved for the variable left_hand_side to the given value. Here, on the right-hand side, we call the function square , which we defined earlier. We call square with arguments 3 and 4 respectively. When we call square with argument 3 , we are assigning the parameter x to a value 3 before we execute the body of square . We use the operator + to add the two results together. The right-hand side should give the value 25, which we then assign to the variable hypotenuse_square . Note that we use = equal sign for assignment, NOT for checking equality. The C notation for checking for equality is == (we will come back to this later). All variables must have an assigned value before it is evaluated. Otherwise, the variable holds an indeterminate value. Declaring a variable only reserves the slot in the memory. The value of an uninitialized variable is therefore determined by whatever bit values that happen to occupy that memory slot at the time. Recap Before we move on, let's recap some concepts: A C program consists of functions, invoking each other. The function called main is the entry point and is the first function invoked. Each function is defined by its returned type, followed by its name, its parameter(s) (within a pair of parenthesis), and its body (within a pair of curly brackets). Each function must be defined or declared before it is used. The function body consists of one or more statements. We have seen assignment statements (using the = operator) and return statements, using return as the keyword. Each variable must be declared before it is used. A declaration starts with its type followed by its name. A variable is only visible within its scope. A variable must be assigned a value before it is evaluated. Global variables are banned in CS1010. Example 2 Let's change the program slightly, so that instead of computing the square of the hypotenuse, we compute the hypotenuse itself. Recall that we said C provides a bunch of predefined functions, include sqrt , which computes the square root of a given number. Since a square root of a number is not necessarily an integer, we need to use a variable with a type that can store a real number. To represent real numbers, we commonly use the type float (which is short for a floating-point number -- named so due to how a real number is represented in bits). A float type can store 32 bits. To double the precision (64 bits), we can use the type double . A long double type can store either 80-bits or 128-bits, depending on the implementation. But which one does sqrt returns? To find out the exact specification of a pre-defined function, we can consult the manual (or man for short) pages for the function. If you type man sqrt on the command line (or place the cursor on sqrt in vim and type Shift + K in command mode), you will see that the sqrt method has the following specification: 1 double sqrt ( double x ); The sqrt function returns a double precision real number. We can now modify the program above to the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 double sqrt ( double x ); // not recommended long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { hypotenuse_of ( 3 , 4 ); } Note that the first line declares the function sqrt because we need to declare a function before it is used. Since sqrt is pre-defined elsewhere, we do not have to supply the function body here. Such practice of declaring a predefined function ourselves, however, is not recommended. Different platforms, compilers, libraries, may provide a different specification for the same function. As such, it is better to use the declaration from the library that provides the predefined function itself. A library usually provides one or more header files , a set of files that contain function declarations, type definitions, and constant definitions. In the case of sqrt , its declaration is contained in a header file called math.h (which we found out through consulting the man pages). To include this file, you add the line #include <math.h> at the top of the program. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <math.h> long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { hypotenuse_of ( 3 , 4 ); } You might notice the same line appear in the man page for sqrt . Thus, the man pages tell us which header file to include if you want to use a certain function. File Extension The convention for file extension for a C program is .c and for a C header file is .h . Even though you are allowed to name the files with any extension you like, you should stick to the convention so that it is clear to other tools/programmers what is the purpose of each file. Other Types in C An int variable is usually 32-bits long. If we only need 16 bits, we use the type short int , or just short . If we only need 8-bits, we use the type char (short for character). Note that in the above, I said an int is usually 32 bits. Remember (from Unit 1 that a C program gets compiled into machine code for a specific CPU architecture. The C standard only guarantees that an int is at least 16 bits. Although most C compilers compile int to 32 bits, there is no guarantee! If we need something more than an int , we can use long int , or just long . The C standard guarantees that a long is at least 32 bits. Depending on the implementation, it sometimes compiled to 32-bits, sometimes 64-bits. To get even longer, we can use the type long long int , or just long long , which is guaranteed to be at least 64 bits 1 . Signed vs. Unsigned We have seen earlier that interpreting the same sequence of bits as signed or unsigned would result in a different value. By default, all types in C refer to signed types. If you want a variable that holds only non-negative integers, you can add the keyword unsigned to the front of the type. Doing so would mean that the range of values you can store in the variable is doubled, without adding more bits (since the bit used to present the + or - sign is no longer needed). For instance, since we know that square can only return a non-zero integer, we can declare it as: 1 2 3 4 unsigned long square ( long x ) { return x * x ; } For most practical purposes in CS1010, a (signed) long suffices. We introduce the notion of signed vs. unsigned for your information so that you know what they are when you come across them in other source code. Mixing signed and unsigned can lead to subtle bugs in your code. As such, we will only use signed long for CS1010 . You may choose to use them appropriately in another context, especially for an embedded system or low-level programming. In CS1010, we will only use long and double to represent integers and floating-point numbers. Again, this is to allow us to focus on problem-solving techniques rather than on issues related to precision. The only place we should use other types is if the functions that we use requires it (e.g., main must return int so we have no choice there). Unsigned Real Numbers? There are no unsigned versions of float and double . To understand the reason, we have to go further into how floating points numbers are represented in bits. That is a topic for another module. C Pro Tips For Beyond CS1010: stdint.h Since the number of bits for int , long , and long long could differ, to write a C program that is portable (i.e., works on different platforms, architecture, operating systems), we have two options: Do not write a program that assumes a specific number of bits is used for a certain type, or Use the type defined in the header file stdint.h : int8_t , uint8_t , int16_t , uint16_t , int32_t , uint32_t , int64_t , uint64_t . The suffix _t is a convention to indicate that this is a customized type (more on this in later units). The prefix u indicates that the type is an unsigned type. The numbers 8 , 16 , 32 , and 64 indicate the number of bits for each type. Thus, uint32_t is guaranteed to be of size 32 bits, and can hold unsigned integer values from \\(0\\) to \\(2^{32}-1\\) . Problem Set 5 Problem 5.1 In the following valid in C? Try to compile the program and see if you encounter any compilation error. What can you infer about what is allowed or not allowed in C? What could go wrong even if C allows? (a) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <math.h> long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { hypotenuse_of ( 3.0 , 4.0 ); // <- use 3.0 and 4.0 instead of int. } (b) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <math.h> long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { long h = hypotenuse_of ( 3 , 4 ); // <-- assign to a long variable } (c) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <math.h> long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { Hypotenuse_Of ( 3 , 4 ); // <-- use a different case } (d) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <math.h> long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { long base ; // <-- declare a new base return sqrt ( square ( base ) + square ( height )); } int main () { hypotenuse_of ( 3 , 4 ); } (e) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <math.h> long square ( long x ) { long sqr = x * x ; // <-- declare and assign in one go return sqr ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { hypotenuse_of ( 3 , 4 ); } (f) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <math.h> long sqr ; // <-- use global variable long square ( long x ) { sqr = x * x ; return sqr ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { hypotenuse_of ( 3 , 4 ); } (g) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <math.h> int main () { long square ( long x ) // <-- define function within function. { return x * x ; } double hypotenuse_of ( long base , long height ) // <-- { return sqrt ( square ( base ) + square ( height )); } hypotenuse_of ( 3 , 4 ); } Adding more long does not make the integer longer, i.e., there is no long long long int . \u21a9","title":"5. First C Program"},{"location":"05-first-c.html#unit-5-first-c-program","text":"","title":"Unit 5: First C Program"},{"location":"05-first-c.html#learning-objectives","text":"After this unit, students should: be able to define functions in C, including the definition of: the function name, the parameters of the function, return statement type, the body of the function, and the return statement; understand the usage of the main function in C programs; be able to make function calls in C programs; understand how values are assigned to the parameters of functions; understand the concept of variable scope; be able to write statements in C programs, including: variable declarations, assignment statements, and statements that include simple expressions (e.g., arithmetic expressions); understand the need and the purpose of including header files; be aware of the different numeric types in C and their respective value ranges; be able to use man to lookup information about functions provided by other C libraries be aware that CS1010 bans the use of global variables and only allows long and double as numeric types.","title":"Learning Objectives:"},{"location":"05-first-c.html#your-first-c-function","text":"In this unit, we will write and compile your first C program. You have already learned, conceptually, what is a variable, what is a type, and what is a function. Let's see how we apply these concepts to C. To start, let's look at a simple snippet of C code: 1 2 3 4 int square ( int x ) { return x * x ; } The code above defines a function named square . The word int appears before the name square . int is used to signify an integer type. Appearing before the name square tells the compiler that square is returning a value of type int . After the word square , we write the parameters to the function in parenthesis ( and ) . In between ( and ) is int x : x is the name of the parameter, int is the type of that parameter. To summarize, in Line 1, int square(int x) defines a function named square that takes in an integer parameter x and is returning a value, which is also an integer. This line is known as the header of the function. The next three lines are written in between curly brackets { and } . You will see these used a lot in C and other programming languages with C-like syntaxes, such as Javascript, C++, and Java. These curly brackets group a block of statements together. In this example, this block defines how the function square computes the square of x , and what it returns. This is the body of the function. In this function body, there is only one statement return x * x; within the block. A statement is a unit in a programming language that expresses either a command to be executed or declares a new variable or function. The word return says that this function square should return the following value, computed as x * x ( x multiply by x ). This statement is terminated by a semicolon ; . You also see that the line that starts with return is indented. We use indentation extensively to indicate the body of a block. Since we can have nested blocks, indentation makes our code easier to read and understand. The words int and return that appear above are keywords defined in the C programming language, and they are reserved for the special meaning that they represent (a type and a command to return a value from a function). We cannot repurpose keywords in C. For instance, we cannot introduce a variable called int . We are now ready to write our first C program. The first program computes the square of the hypotenuse of a right-angled triangle with a base of 4 and a height of 3. 1 2 3 4 5 6 7 8 9 10 11 12 int square ( int x ) { return x * x ; } int main () { int hypotenuse_square ; hypotenuse_square = square ( 3 ) + square ( 4 ); return 0 ; } Remember that a C program consists of a bunch of functions, calling each other. The most important function is called main , and it is the entry point to the program. It is where the operating system will begin to execute the program. Every program must define exactly one function called main . 1 2 3 4 int main () { : } main returns an integer of type int to the operating system, to signal to the operating system whether the program exits successfully or not. In this case, we always return 0 (success) assuming that nothing goes wrong for simplicity. This is the second example where you see the keyword return in action. In modern C, the main always returns 0 when it exits. So, we will skip this statement return 0; from now on.","title":"Your First C Function"},{"location":"05-first-c.html#variable-declaration","text":"In the example above, you also see the lines 1 int hypotenuse_square ; This is a declaration statement (terminated with a semicolon, again). Each statement declares a variable with its corresponding type ( int here). We gave each variable a name, here we call the variable hypotenuse_square . All variables must be declared with its corresponding type before used in C . What declaration does is that it causes a slot in the computing device memory to be reserved for the value of this variable. The type indicates how many bits should be reserved (i.e., how big should the slot be). Each declaration is valid only within the scope of its declaration. A variable is only visible within the innermost block that encloses the declaration, as specified by the { and } . In the example above, the variable hypotenuse_square is visible only in the body of main , but not in the body of square . We cannot redeclare the same variable (i.e., with the same name), with the same type or otherwise, within the same scope. Two variables in different blocks, however, are allowed to have the same name. 1 2 3 4 5 6 7 8 int main () { int hypotenuse_square ; hypotenuse_square = square ( 3 ) + square ( 4 ); int hypotenuse_square ; // <-- redeclaration return 0 ; } The example above would lead to an error on Line 7. The C language allows the declaration of a variable outside of any block. In this case, the scope of the variable is the entire file -- which means that the variable can be accessed and modified from anywhere in the code. Such a variable is called global variable . 1 2 3 4 5 6 7 8 9 10 11 12 int square ( int x ) { return x * x ; } int hypotenuse_square ; // <- global variable int main () { hypotenuse_square = square ( 3 ) + square ( 4 ); return 0 ; } While C allows global variables to be declared and used. The use of global variables is banned in CS1010. CS1010 allows only a subset of C to be used. Particularly, C features that are common pitfalls for beginners and bug-prone are banned. This is so that we can focus this module on problem-solving techniques, rather than the idiosyncrasy of C.","title":"Variable Declaration"},{"location":"05-first-c.html#function-declaration","text":"In C, a function must be either defined or declared before used as well. In the example above, we define square before main . If we switch the order of the two, the compiler will complain. Unless we declare the function first. Declaring a function means that we simply state the return type, the name, and the parameters, without the body. Here is an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int square ( int x ); // declaring the function square int main () { int hypotenuse_square ; hypotenuse_square = square ( 3 ) + square ( 4 ); return 0 ; } int square ( int x ) // defining the function square { return x * x ; }","title":"Function Declaration"},{"location":"05-first-c.html#assignment-statement","text":"The next line of the code shows an example of an assignment statement. 1 hypotenuse_square = square ( 3 ) + square ( 4 ); An assignment operator takes the form of: 1 left_hand_side = right_hand_side ; The left_hand_side must be the name of a variable. We first evaluate the right_hand_side of the assignment statement, find its value, then assign the value to the variable named on the left_hand_side . Essentially, this step updates the bits in the memory location reserved for the variable left_hand_side to the given value. Here, on the right-hand side, we call the function square , which we defined earlier. We call square with arguments 3 and 4 respectively. When we call square with argument 3 , we are assigning the parameter x to a value 3 before we execute the body of square . We use the operator + to add the two results together. The right-hand side should give the value 25, which we then assign to the variable hypotenuse_square . Note that we use = equal sign for assignment, NOT for checking equality. The C notation for checking for equality is == (we will come back to this later). All variables must have an assigned value before it is evaluated. Otherwise, the variable holds an indeterminate value. Declaring a variable only reserves the slot in the memory. The value of an uninitialized variable is therefore determined by whatever bit values that happen to occupy that memory slot at the time.","title":"Assignment Statement"},{"location":"05-first-c.html#recap","text":"Before we move on, let's recap some concepts: A C program consists of functions, invoking each other. The function called main is the entry point and is the first function invoked. Each function is defined by its returned type, followed by its name, its parameter(s) (within a pair of parenthesis), and its body (within a pair of curly brackets). Each function must be defined or declared before it is used. The function body consists of one or more statements. We have seen assignment statements (using the = operator) and return statements, using return as the keyword. Each variable must be declared before it is used. A declaration starts with its type followed by its name. A variable is only visible within its scope. A variable must be assigned a value before it is evaluated. Global variables are banned in CS1010.","title":"Recap"},{"location":"05-first-c.html#example-2","text":"Let's change the program slightly, so that instead of computing the square of the hypotenuse, we compute the hypotenuse itself. Recall that we said C provides a bunch of predefined functions, include sqrt , which computes the square root of a given number. Since a square root of a number is not necessarily an integer, we need to use a variable with a type that can store a real number. To represent real numbers, we commonly use the type float (which is short for a floating-point number -- named so due to how a real number is represented in bits). A float type can store 32 bits. To double the precision (64 bits), we can use the type double . A long double type can store either 80-bits or 128-bits, depending on the implementation. But which one does sqrt returns? To find out the exact specification of a pre-defined function, we can consult the manual (or man for short) pages for the function. If you type man sqrt on the command line (or place the cursor on sqrt in vim and type Shift + K in command mode), you will see that the sqrt method has the following specification: 1 double sqrt ( double x ); The sqrt function returns a double precision real number. We can now modify the program above to the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 double sqrt ( double x ); // not recommended long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { hypotenuse_of ( 3 , 4 ); } Note that the first line declares the function sqrt because we need to declare a function before it is used. Since sqrt is pre-defined elsewhere, we do not have to supply the function body here. Such practice of declaring a predefined function ourselves, however, is not recommended. Different platforms, compilers, libraries, may provide a different specification for the same function. As such, it is better to use the declaration from the library that provides the predefined function itself. A library usually provides one or more header files , a set of files that contain function declarations, type definitions, and constant definitions. In the case of sqrt , its declaration is contained in a header file called math.h (which we found out through consulting the man pages). To include this file, you add the line #include <math.h> at the top of the program. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <math.h> long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { hypotenuse_of ( 3 , 4 ); } You might notice the same line appear in the man page for sqrt . Thus, the man pages tell us which header file to include if you want to use a certain function. File Extension The convention for file extension for a C program is .c and for a C header file is .h . Even though you are allowed to name the files with any extension you like, you should stick to the convention so that it is clear to other tools/programmers what is the purpose of each file.","title":"Example 2"},{"location":"05-first-c.html#other-types-in-c","text":"An int variable is usually 32-bits long. If we only need 16 bits, we use the type short int , or just short . If we only need 8-bits, we use the type char (short for character). Note that in the above, I said an int is usually 32 bits. Remember (from Unit 1 that a C program gets compiled into machine code for a specific CPU architecture. The C standard only guarantees that an int is at least 16 bits. Although most C compilers compile int to 32 bits, there is no guarantee! If we need something more than an int , we can use long int , or just long . The C standard guarantees that a long is at least 32 bits. Depending on the implementation, it sometimes compiled to 32-bits, sometimes 64-bits. To get even longer, we can use the type long long int , or just long long , which is guaranteed to be at least 64 bits 1 .","title":"Other Types in C"},{"location":"05-first-c.html#signed-vs-unsigned","text":"We have seen earlier that interpreting the same sequence of bits as signed or unsigned would result in a different value. By default, all types in C refer to signed types. If you want a variable that holds only non-negative integers, you can add the keyword unsigned to the front of the type. Doing so would mean that the range of values you can store in the variable is doubled, without adding more bits (since the bit used to present the + or - sign is no longer needed). For instance, since we know that square can only return a non-zero integer, we can declare it as: 1 2 3 4 unsigned long square ( long x ) { return x * x ; } For most practical purposes in CS1010, a (signed) long suffices. We introduce the notion of signed vs. unsigned for your information so that you know what they are when you come across them in other source code. Mixing signed and unsigned can lead to subtle bugs in your code. As such, we will only use signed long for CS1010 . You may choose to use them appropriately in another context, especially for an embedded system or low-level programming. In CS1010, we will only use long and double to represent integers and floating-point numbers. Again, this is to allow us to focus on problem-solving techniques rather than on issues related to precision. The only place we should use other types is if the functions that we use requires it (e.g., main must return int so we have no choice there). Unsigned Real Numbers? There are no unsigned versions of float and double . To understand the reason, we have to go further into how floating points numbers are represented in bits. That is a topic for another module. C Pro Tips For Beyond CS1010: stdint.h Since the number of bits for int , long , and long long could differ, to write a C program that is portable (i.e., works on different platforms, architecture, operating systems), we have two options: Do not write a program that assumes a specific number of bits is used for a certain type, or Use the type defined in the header file stdint.h : int8_t , uint8_t , int16_t , uint16_t , int32_t , uint32_t , int64_t , uint64_t . The suffix _t is a convention to indicate that this is a customized type (more on this in later units). The prefix u indicates that the type is an unsigned type. The numbers 8 , 16 , 32 , and 64 indicate the number of bits for each type. Thus, uint32_t is guaranteed to be of size 32 bits, and can hold unsigned integer values from \\(0\\) to \\(2^{32}-1\\) .","title":"Signed vs. Unsigned"},{"location":"05-first-c.html#problem-set-5","text":"","title":"Problem Set 5"},{"location":"05-first-c.html#problem-51","text":"In the following valid in C? Try to compile the program and see if you encounter any compilation error. What can you infer about what is allowed or not allowed in C? What could go wrong even if C allows? (a) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <math.h> long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { hypotenuse_of ( 3.0 , 4.0 ); // <- use 3.0 and 4.0 instead of int. } (b) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <math.h> long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { long h = hypotenuse_of ( 3 , 4 ); // <-- assign to a long variable } (c) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <math.h> long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { Hypotenuse_Of ( 3 , 4 ); // <-- use a different case } (d) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <math.h> long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { long base ; // <-- declare a new base return sqrt ( square ( base ) + square ( height )); } int main () { hypotenuse_of ( 3 , 4 ); } (e) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <math.h> long square ( long x ) { long sqr = x * x ; // <-- declare and assign in one go return sqr ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { hypotenuse_of ( 3 , 4 ); } (f) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <math.h> long sqr ; // <-- use global variable long square ( long x ) { sqr = x * x ; return sqr ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { hypotenuse_of ( 3 , 4 ); } (g) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <math.h> int main () { long square ( long x ) // <-- define function within function. { return x * x ; } double hypotenuse_of ( long base , long height ) // <-- { return sqrt ( square ( base ) + square ( height )); } hypotenuse_of ( 3 , 4 ); } Adding more long does not make the integer longer, i.e., there is no long long long int . \u21a9","title":"Problem 5.1"},{"location":"06-cs1010-io.html","text":"Unit 6: The CS1010 I/O Library Learning Objectives After this unit, students should: understand the notion of standard input ( stdin ) and output ( stdout ) channels in Unix; be able to use the various print and read functions available in libcs1010 to perform I/O. be aware that there exist pitfalls in using printf and scanf functions provided by C and they should only use these functions if they know what they are doing. Interacting with Users Our first C program that computes the hypotenuse doesn't do much -- it simply computes \\(\\sqrt{3^2 + 4^2}\\) . The value to be computed is hard-coded, and the result computed is not displayed. To make this program more general and useful, we need to do two things. First, we need to compute the hypotenuse for any length of the base and the height of a right-angled triangle. We cannot hard-code the length in the program. We should read these values from the users. Second, we need to output the result of the computation to the users. In other words, to make the program more general and useful, we need to add input and output, or I/O, functions. Standard Input and Standard Output Before we talk about how to read the input values and display the output values, we have to first talk about where input comes from and where the output goes. In Unix-flavored operating systems, the input is read from an abstract channel called the standard input or stdin for short, and an output is sent to an abstract channel called the standard output or stdout for short. The fact that these channels are abstract is a powerful concept -- when we write our code, we do not have to worry about where the inputs come from and where the outputs go to. It will depend on how the user runs our program. Thus, it allows the users of our program the flexibility to control where the data comes from or goes to. For instance, the standard input, by default, reads from the keyboard. But the user can choose to read from a file, using the redirection < operator from the command line or from the output of another process, using the pipe | operator from the command line . Similarly, the standard output, by default, writes to the terminal. But the user can choose to write to a file using the redirection > operator on the command line or to the input of another process, using the pipe | operator, again, on the command line when invoking the program. You will see how cool these are later. But for C programming, it suffices to know for now that we only need to read from stdin and write to stdout in our code, and we let the users decide where they come from / go to. No printf and scanf (yet) In almost all articles and textbooks on C that I have seen, the scanf and printf functions are taught as the standard C library functions to perform the input and output respectively. The function scanf , however, is tricky to use correctly and securely. The function printf comes with many nuances, such as having to remember the different conversion specifiers and modifiers. I would rather not teach you scanf and printf at this stage and focus on how to solve problems instead. As such, CS1010 provides you with a library to perform I/O. The library provides a small set of essential functions to read and write long values, double values, space-separated words, and lines of text. If you insist on using printf and scanf for your assignments, make sure you know what you are doing. Otherwise, you will run into strange bugs if you are not using it correctly (and it is non-trivial to use them correctly). If you are an experienced programmer with C, you can skip ahead to take a look at Unit 29 on the pitfalls of using printf and scanf . You can find the documentation for the CS1010 I/O Library here . We will see how to use the library to improve our hypotenuse computation program here. Using the CS1010 I/O Library Let's modify our earlier program to now read the base and height from stdin , compute the hypotenuse, and print the results out to stdout . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <math.h> #include \"cs1010.h\" long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { double hypotenuse ; long base = cs1010_read_long (); long height = cs1010_read_long (); hypotenuse = hypotenuse_of ( base , height ); cs1010_println_double ( hypotenuse ); } The first change you see (on Line 2) is to include the file cs1010.h , which includes the declaration of functions provided by the library. On Lines 17 and 18, we introduce two new long variables named base and height , which we initialized with the returned value from cs1010_read_long() . The function cs1010_read_long reads a long value from stdin and returns the value. For now, we assume that the inputs are correctly passed to the program. Remember to include () C requires that function calls be identified with () . It is common for beginners to skip () and call a function like long base = cs1010_read_long; , leading to compilation errors. Finally, on Line 20, we print the resulting hypotenuse to stdout using the library function cs1010_println_double . Note that there are two versions of functions to print a double value: cs1010_println_double and cs1010_print_double . The one with println prints a newline character as well. Refer to CS1010 Compilation Guide on how to compile a program that uses the CS1010 I/O library. Note that the main function above can be written as a single statement without any variable and assignment. The resulting code, however, is not necessarily easier to understand. 1 2 3 4 int main () { cs1010_println_double ( hypotenuse_of ( cs1010_read_long (), cs1010_read_long ())); }","title":"6. CS1010 I/O"},{"location":"06-cs1010-io.html#unit-6-the-cs1010-io-library","text":"","title":"Unit 6: The CS1010 I/O Library"},{"location":"06-cs1010-io.html#learning-objectives","text":"After this unit, students should: understand the notion of standard input ( stdin ) and output ( stdout ) channels in Unix; be able to use the various print and read functions available in libcs1010 to perform I/O. be aware that there exist pitfalls in using printf and scanf functions provided by C and they should only use these functions if they know what they are doing.","title":"Learning Objectives"},{"location":"06-cs1010-io.html#interacting-with-users","text":"Our first C program that computes the hypotenuse doesn't do much -- it simply computes \\(\\sqrt{3^2 + 4^2}\\) . The value to be computed is hard-coded, and the result computed is not displayed. To make this program more general and useful, we need to do two things. First, we need to compute the hypotenuse for any length of the base and the height of a right-angled triangle. We cannot hard-code the length in the program. We should read these values from the users. Second, we need to output the result of the computation to the users. In other words, to make the program more general and useful, we need to add input and output, or I/O, functions.","title":"Interacting with Users"},{"location":"06-cs1010-io.html#standard-input-and-standard-output","text":"Before we talk about how to read the input values and display the output values, we have to first talk about where input comes from and where the output goes. In Unix-flavored operating systems, the input is read from an abstract channel called the standard input or stdin for short, and an output is sent to an abstract channel called the standard output or stdout for short. The fact that these channels are abstract is a powerful concept -- when we write our code, we do not have to worry about where the inputs come from and where the outputs go to. It will depend on how the user runs our program. Thus, it allows the users of our program the flexibility to control where the data comes from or goes to. For instance, the standard input, by default, reads from the keyboard. But the user can choose to read from a file, using the redirection < operator from the command line or from the output of another process, using the pipe | operator from the command line . Similarly, the standard output, by default, writes to the terminal. But the user can choose to write to a file using the redirection > operator on the command line or to the input of another process, using the pipe | operator, again, on the command line when invoking the program. You will see how cool these are later. But for C programming, it suffices to know for now that we only need to read from stdin and write to stdout in our code, and we let the users decide where they come from / go to.","title":"Standard Input and Standard Output"},{"location":"06-cs1010-io.html#no-printf-and-scanf-yet","text":"In almost all articles and textbooks on C that I have seen, the scanf and printf functions are taught as the standard C library functions to perform the input and output respectively. The function scanf , however, is tricky to use correctly and securely. The function printf comes with many nuances, such as having to remember the different conversion specifiers and modifiers. I would rather not teach you scanf and printf at this stage and focus on how to solve problems instead. As such, CS1010 provides you with a library to perform I/O. The library provides a small set of essential functions to read and write long values, double values, space-separated words, and lines of text. If you insist on using printf and scanf for your assignments, make sure you know what you are doing. Otherwise, you will run into strange bugs if you are not using it correctly (and it is non-trivial to use them correctly). If you are an experienced programmer with C, you can skip ahead to take a look at Unit 29 on the pitfalls of using printf and scanf . You can find the documentation for the CS1010 I/O Library here . We will see how to use the library to improve our hypotenuse computation program here.","title":"No printf and scanf (yet)"},{"location":"06-cs1010-io.html#using-the-cs1010-io-library","text":"Let's modify our earlier program to now read the base and height from stdin , compute the hypotenuse, and print the results out to stdout . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <math.h> #include \"cs1010.h\" long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { double hypotenuse ; long base = cs1010_read_long (); long height = cs1010_read_long (); hypotenuse = hypotenuse_of ( base , height ); cs1010_println_double ( hypotenuse ); } The first change you see (on Line 2) is to include the file cs1010.h , which includes the declaration of functions provided by the library. On Lines 17 and 18, we introduce two new long variables named base and height , which we initialized with the returned value from cs1010_read_long() . The function cs1010_read_long reads a long value from stdin and returns the value. For now, we assume that the inputs are correctly passed to the program. Remember to include () C requires that function calls be identified with () . It is common for beginners to skip () and call a function like long base = cs1010_read_long; , leading to compilation errors. Finally, on Line 20, we print the resulting hypotenuse to stdout using the library function cs1010_println_double . Note that there are two versions of functions to print a double value: cs1010_println_double and cs1010_print_double . The one with println prints a newline character as well. Refer to CS1010 Compilation Guide on how to compile a program that uses the CS1010 I/O library. Note that the main function above can be written as a single statement without any variable and assignment. The resulting code, however, is not necessarily easier to understand. 1 2 3 4 int main () { cs1010_println_double ( hypotenuse_of ( cs1010_read_long (), cs1010_read_long ())); }","title":"Using the CS1010 I/O Library"},{"location":"07-arithmetic-ops.html","text":"Unit 7: Arithmetic Operations Learning Objectives After this unit, students should: be able to define arithmetic expressions in C programs that include the use of the following arithmetic operators for: addition ( + ), subtraction ( - ), multiplication ( * ), division ( / ), and modulo ( % ); be aware of the numeric types that may be used with arithmetic operators in C programs; be aware of the value range restrictions on the various numeric types in C; be able to use compound operators in C programs; be aware of the difference between division and integer division, and when the latter occurs within arithmetic expressions; and be aware that there exist pitfalls in using ++ and -- operators and they are not allowed in CS1010. Operators You have seen the + operator in the previous units. You can use + to add two variables, a value, and a variable, or two values: 1 2 3 4 5 6 long a = 1 ; long b = 2 ; long c = 3 ; a = b + c ; // add two variables b = a + 4 ; // add a variable to a value c = 5 + 6 ; // add two values You can also use + on values returned by functions: 1 hypotenuse = sqrt ( square ( base ) + square ( height )); You have also seen the multiplication operator * . It can be used in the same way as the + operator. Three other useful operators are: / - division (e.g., double half_x = x / 2; ) - - subtraction (e.g., long deducted = income - 100 ) % - modulo (e.g, long last_digit = number % 10 ); The + , - , * , and / operators work on both integer types ( char , short , int , long , long long ) and real numbers ( float , double ). The module operator % works only on integer types. Operator Precedence We can chain the operations together to form expressions such as: 1 2 3 long b = 10 ; long c = 2 ; long a = b + 2 * c / 4 ; When we have multiple operations appearing, however, it becomes harder to trace the sequence of evaluation. What is the value of a after the three lines above are executed? C actually has well-defined rules to the order of evaluation for the operators: * , / , and % take precedence over + and - , and the operators are evaluated from left to right. Thus, in the example above, a will be 11 instead of 6 after the execution. To change the order of execution, we can add parenthesis to the expression. For instance: 1 2 long a = ( b + 2 ) * c / 4 ; // 6 long a = b + ( 2 * c / 4 ); // 11 The expression in the parenthesis will be evaluated first. To make your code easier to understand, you should add parenthesis even if the order of evaluation is from left to right to make the order of evaluation explicit. Compound Operators It is common to modify the value of a variable and store new value back to the same variable. For example, 1 2 index = index + 1 ; // increment the variable index age = age * 2 ; // double the variable age C provides compound operators that simplify the expressions above. For example, 1 2 index += 1 ; age *= 2 ; The syntax for a compound operator is op= , where op can be + , - , * , / , % , or other binary operators. The statement: 1 a op= b; modifies a the same way as: 1 a = a op b Common Mistakes Using Arithmetic Operations It is important to remember that when arithmetic operations in C are performed on a sequence of bits, the value that the sequence of bits can represent is limited and is determined by its type. A common mistake for beginner programmers is to forget this fact and treat the arithmetic operations as the same as the ones seen in mathematics. Let's look at two common gotchas. Overflow Consider the type uint8_t , which represents an unsigned 8-bit integer and the following code: 1 2 uint8_t c = 255 ; c += 1 ; What is the value of variable c after the operation above? Here, we are adding one to the value 255, so c must store the value 256, right? It turns out that after the execution above, c contains the value 0. The variable c is of the type uint8_t , which is the unsigned 8-bit integer. Being 8-bit, the variable can store values from 0 to 255. When we add 1 to 255, even though we get the result 256, mathematically, we cannot store 256 in c -- there are not enough bits! In this case, the value stored is \"wrap around\", and we get the value 0 instead. The variable c above is unsigned. It gets trickier if c is signed. In the case of overflowing signed integer, the behavior depends on the compiler and is undefined in the C standard. Integer Division Now, let's consider the following code: 1 double half = 3 / 2 ; What is the value of variable half after the operation above? It got to be 1.5, right? It turns out that, after executing the code above, the value of half is 1.0. To understand this, first, let's see what happen when we assign a floating-point number to an integer type: 1 int x = 1.5 ; C truncates the floating number and only stores the integer part of the value, 1 in this case, in x . Second, when we perform an arithmetic operation, the resulting value will be an integer if both values are integer types. If one of the operands is a floating-point number, the result will be a floating-point number 1 . Since 3 and 2 are both integers, the resulting value 1.5 is stored in an integer, which causes it to become 1. We then store 1 into a double variable, causing the value of half to become 1.0 . Because of this limitation, the operation / is sometimes also known as integer division when both operands are integers. In order to get the result 1.5 as expected, we can write either: 1 double half = 3 / 2.0 ; or 1 double half = 3 / ( double ) 2 ; The second fix above explicitly converts the type, or casts the type of value 2 into a double . Avoid Increment / Decrement Operator If you read C code in other places, you will certainly come across the increment or decrement operator, ++ or -- . The operators add one and minus one from the operand respectively. So, the statement 1 index += 1 ; can be further shortened into 1 index++; and the statement 1 index -= 1 ; can be further shortened into 1 index--; Using these two operators only shorten your code by two characters per statement, but introduces several issues. As such, we ban the use of both increment and decrement operator in CS1010 . So, why aren't ++ and -- welcomed in CS1010? The ++ and -- operators not only modify the value of the operand, but it also returns a value. We can write j = i++; to both increment i and assign the pre-incremented value of i to j . In C, we can also write j = ++i; , which again, increment i , and assign the post-incremented value of i to j . Things get tricky, when we write i = i++; , it is not clear how to interpret this. The C standard leaves this behavior undefined and leaves it to the compiler to define its behavior. Introducing all these complexities just to save two characters is not warranted. List of C features banned in CS1010 You should realize by now that we are only using a subset of C and enforce a certain style of programming in CS1010. We wish to move all of you away from common pitfalls in learning and writing C so that we can focus on using C as a tool to solve problems. So far, you have seen that we are banning: ++ and -- operators the types int , short , float etc. (with the returning type of main() as the exception) global variables In addition, we discourage: the use of printf and scanf skipping parenthesis in writing arithmetic expression The complete list of C features that we ban or discourage in CS1010 can be found here . The actual rules used by C, called integer promotion and usual arithmetic conversion , are much more complex and are outside the scope of CS1010. You should take note of this, however, and in a later part of your study or career, if you need to delve deeper into writing or debugging C code, take a look at this . \u21a9","title":"7. Arithmetic Operations"},{"location":"07-arithmetic-ops.html#unit-7-arithmetic-operations","text":"","title":"Unit 7: Arithmetic Operations"},{"location":"07-arithmetic-ops.html#learning-objectives","text":"After this unit, students should: be able to define arithmetic expressions in C programs that include the use of the following arithmetic operators for: addition ( + ), subtraction ( - ), multiplication ( * ), division ( / ), and modulo ( % ); be aware of the numeric types that may be used with arithmetic operators in C programs; be aware of the value range restrictions on the various numeric types in C; be able to use compound operators in C programs; be aware of the difference between division and integer division, and when the latter occurs within arithmetic expressions; and be aware that there exist pitfalls in using ++ and -- operators and they are not allowed in CS1010.","title":"Learning Objectives"},{"location":"07-arithmetic-ops.html#operators","text":"You have seen the + operator in the previous units. You can use + to add two variables, a value, and a variable, or two values: 1 2 3 4 5 6 long a = 1 ; long b = 2 ; long c = 3 ; a = b + c ; // add two variables b = a + 4 ; // add a variable to a value c = 5 + 6 ; // add two values You can also use + on values returned by functions: 1 hypotenuse = sqrt ( square ( base ) + square ( height )); You have also seen the multiplication operator * . It can be used in the same way as the + operator. Three other useful operators are: / - division (e.g., double half_x = x / 2; ) - - subtraction (e.g., long deducted = income - 100 ) % - modulo (e.g, long last_digit = number % 10 ); The + , - , * , and / operators work on both integer types ( char , short , int , long , long long ) and real numbers ( float , double ). The module operator % works only on integer types.","title":"Operators"},{"location":"07-arithmetic-ops.html#operator-precedence","text":"We can chain the operations together to form expressions such as: 1 2 3 long b = 10 ; long c = 2 ; long a = b + 2 * c / 4 ; When we have multiple operations appearing, however, it becomes harder to trace the sequence of evaluation. What is the value of a after the three lines above are executed? C actually has well-defined rules to the order of evaluation for the operators: * , / , and % take precedence over + and - , and the operators are evaluated from left to right. Thus, in the example above, a will be 11 instead of 6 after the execution. To change the order of execution, we can add parenthesis to the expression. For instance: 1 2 long a = ( b + 2 ) * c / 4 ; // 6 long a = b + ( 2 * c / 4 ); // 11 The expression in the parenthesis will be evaluated first. To make your code easier to understand, you should add parenthesis even if the order of evaluation is from left to right to make the order of evaluation explicit.","title":"Operator Precedence"},{"location":"07-arithmetic-ops.html#compound-operators","text":"It is common to modify the value of a variable and store new value back to the same variable. For example, 1 2 index = index + 1 ; // increment the variable index age = age * 2 ; // double the variable age C provides compound operators that simplify the expressions above. For example, 1 2 index += 1 ; age *= 2 ; The syntax for a compound operator is op= , where op can be + , - , * , / , % , or other binary operators. The statement: 1 a op= b; modifies a the same way as: 1 a = a op b","title":"Compound Operators"},{"location":"07-arithmetic-ops.html#common-mistakes-using-arithmetic-operations","text":"It is important to remember that when arithmetic operations in C are performed on a sequence of bits, the value that the sequence of bits can represent is limited and is determined by its type. A common mistake for beginner programmers is to forget this fact and treat the arithmetic operations as the same as the ones seen in mathematics. Let's look at two common gotchas.","title":"Common Mistakes Using Arithmetic Operations"},{"location":"07-arithmetic-ops.html#overflow","text":"Consider the type uint8_t , which represents an unsigned 8-bit integer and the following code: 1 2 uint8_t c = 255 ; c += 1 ; What is the value of variable c after the operation above? Here, we are adding one to the value 255, so c must store the value 256, right? It turns out that after the execution above, c contains the value 0. The variable c is of the type uint8_t , which is the unsigned 8-bit integer. Being 8-bit, the variable can store values from 0 to 255. When we add 1 to 255, even though we get the result 256, mathematically, we cannot store 256 in c -- there are not enough bits! In this case, the value stored is \"wrap around\", and we get the value 0 instead. The variable c above is unsigned. It gets trickier if c is signed. In the case of overflowing signed integer, the behavior depends on the compiler and is undefined in the C standard.","title":"Overflow"},{"location":"07-arithmetic-ops.html#integer-division","text":"Now, let's consider the following code: 1 double half = 3 / 2 ; What is the value of variable half after the operation above? It got to be 1.5, right? It turns out that, after executing the code above, the value of half is 1.0. To understand this, first, let's see what happen when we assign a floating-point number to an integer type: 1 int x = 1.5 ; C truncates the floating number and only stores the integer part of the value, 1 in this case, in x . Second, when we perform an arithmetic operation, the resulting value will be an integer if both values are integer types. If one of the operands is a floating-point number, the result will be a floating-point number 1 . Since 3 and 2 are both integers, the resulting value 1.5 is stored in an integer, which causes it to become 1. We then store 1 into a double variable, causing the value of half to become 1.0 . Because of this limitation, the operation / is sometimes also known as integer division when both operands are integers. In order to get the result 1.5 as expected, we can write either: 1 double half = 3 / 2.0 ; or 1 double half = 3 / ( double ) 2 ; The second fix above explicitly converts the type, or casts the type of value 2 into a double .","title":"Integer Division"},{"location":"07-arithmetic-ops.html#avoid-increment-decrement-operator","text":"If you read C code in other places, you will certainly come across the increment or decrement operator, ++ or -- . The operators add one and minus one from the operand respectively. So, the statement 1 index += 1 ; can be further shortened into 1 index++; and the statement 1 index -= 1 ; can be further shortened into 1 index--; Using these two operators only shorten your code by two characters per statement, but introduces several issues. As such, we ban the use of both increment and decrement operator in CS1010 . So, why aren't ++ and -- welcomed in CS1010? The ++ and -- operators not only modify the value of the operand, but it also returns a value. We can write j = i++; to both increment i and assign the pre-incremented value of i to j . In C, we can also write j = ++i; , which again, increment i , and assign the post-incremented value of i to j . Things get tricky, when we write i = i++; , it is not clear how to interpret this. The C standard leaves this behavior undefined and leaves it to the compiler to define its behavior. Introducing all these complexities just to save two characters is not warranted.","title":"Avoid Increment / Decrement Operator"},{"location":"07-arithmetic-ops.html#list-of-c-features-banned-in-cs1010","text":"You should realize by now that we are only using a subset of C and enforce a certain style of programming in CS1010. We wish to move all of you away from common pitfalls in learning and writing C so that we can focus on using C as a tool to solve problems. So far, you have seen that we are banning: ++ and -- operators the types int , short , float etc. (with the returning type of main() as the exception) global variables In addition, we discourage: the use of printf and scanf skipping parenthesis in writing arithmetic expression The complete list of C features that we ban or discourage in CS1010 can be found here . The actual rules used by C, called integer promotion and usual arithmetic conversion , are much more complex and are outside the scope of CS1010. You should take note of this, however, and in a later part of your study or career, if you need to delve deeper into writing or debugging C code, take a look at this . \u21a9","title":"List of C features banned in CS1010"},{"location":"08-if-else.html","text":"Unit 8: Conditional Statement Learning Objectives After going through this unit, students should: understand that branching in flowcharts relates to either if-else statements or loop; be able to identify the three components of an if-else statement: the condition, the true block, and the false block; be able to develop an if-else statement in C, including, (i) nested if-else , (ii) if without else blocks , and (iii) else if blocks; be able to model a computational solution with different conditions as a table; understand the meaning and the use of the type void understand the term string and be able to use cs1010_println_string to print a string to the screen. be aware that in CS1010: curly brackets must not be skipped even if a block contains only a single statement; nested conditional operators are banned. be aware of floating-point numbers must not be compared using equality. Branching So far the C programs that we have written have a straightforward execution path . The execution flows from top to bottom in main , jumping to a function being called (or callee ), and back to the caller when the function returns. We have, however, seen a few examples so far where the execution path can branch off to either one of two paths, depends on a condition: In the algorithm to compute the \\(max(L, k)\\) , we check if \\(i\\) equals \\(k\\) , and stop checking if it is true; repeat if it is false. In the algorithm to compute the \\(max(L, k)\\) , we check if \\(l_i > m\\) , and update \\(m\\) only if this is true. In the algorithm to compute the \\(factorial(n)\\) , we check if \\(n\\) equals 0, and return 1 if it is true, otherwise, we return \\(n \\times factorial(n-1)\\) . We are not ready to write C code that processes a list repetitively yet. So the first example above will be covered in Unit 11. In this unit, we will use the \\(factorial(n)\\) function as an example. In C, the \\(factorial(n)\\) would look like this: 1 2 3 4 5 6 7 8 9 10 long factorial ( long n ) { long answer ; if ( n == 0 ) { answer = 1 ; } else { answer = n * factorial ( n - 1 ); } return answer ; } In this example, you see two new C keywords if and else . These keywords are used conditional blocks . The general syntax is: 1 2 3 4 5 if ( < logical expression > ) { \"true block\" : statements to be executed if expression evaluates to true } else { \"false block\" : statements to be executed if expression evaluates to false } The if keyword is followed by a logical expression in parenthesis. This is followed by a block of statements (in curly braces { and } ). If the logical expression is true, then the statements are executed, otherwise, they are skipped, and the statements following the else block is executed instead. For this reason, the group of statements following if is known as a true block , and the group of statements following else is known as the false block . Comparison Operator The logical expression n == 0 is true if the variable n holds the value of 0 . == vs = Note that the use of TWO = signs. This is often confused by newbie programmers with a single = sign, which is used for assignment. A common bug is to write 1 2 3 if ( n = 0 ) { : } The == is known as a comparison operator . It compares if the left-hand side has the same value as the right-hand side. Other comparison operators include > (greater than), < (less than), >= (greater or equal to), <= (less than or equal to), and != (not equal). In other words, the variable answer will be set to 1 if the parameter n equals 0 . What if n is not 0 ? The block that contains Line 5 return 1; will be skipped, and Line 7 answer = n * factorial(n - 1); will be executed instead. Nested Else-If The example above considers two possible execution paths only. In some situations, we may need to consider more than two execution paths. Take the following problem for example. You are given the numerical score for an assignment, ranged between 0 and 10. Print out the letter grade of the assignment according to the table below: Score Letter Grade 8 or higher A Less than 8 but 5 or higher B Less than 5 but 3 or higher C Less than 3 D Since the if - else statement only allows branching into two possibilities, we can branch into multiple possibilities by nesting the if - else statements hierarchically. We can first break the table down into three tables, each containing only two rows, with one row a negation of the other row. Score Letter Grade 8 or higher A Less than 8 See Table 1 Table 1 (less than 8) Score Letter Grade 5 or higher B Less than 5 See Table 2 Table 2 (less than 5) Score Letter Grade 3 or higher C Less than 3 D The tables above can then be written into the following function: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void print_score ( double score ) { if ( score >= 8 ) { cs1010_println_string ( \"A\" ); } else { // Table 1 if ( score >= 5 ) { cs1010_println_string ( \"B\" ); } else { // Table 2 if ( score >= 3 ) { cs1010_println_string ( \"C\" ); } else { cs1010_println_string ( \"D\" ); } } } } There are three nested if - else in the function above. Note how I use indentation to clearly indicate the nesting of blocks. Such nesting or indentation is not required by C standard, but is a commonly accepted coding practice, and is required for CS1010. The code below compiles perfectly but is not as easy to read by a human as the above. 1 2 3 4 5 6 7 8 9 10 11 12 void print_score ( double score ) { if ( score >= 8 ) { cs1010_println_string ( \"A\" ); } else { // Table 1 if ( score >= 5 ) { cs1010_println_string ( \"B\" ); } else { // Table 2 if ( score >= 3 ) { cs1010_println_string ( \"C\" ); } else { cs1010_println_string ( \"D\" ); } } } } // Don't write code like this. There are also a couple of \"first\" in the sample code above: You see the keyword void for the first time. void is a special type that indicates nothing. The function print_score does not return anything, it accepts an input score and print something to screen. As such, we say that the return type of print_score is void . You see strings for the first time ( \"A\" , etc.). A string basically is a sequence of characters. We use double quotes \" to mark the beginning and the end of a string, and use the CS1010 I/O library function cs1010_println_string to print a string to the screen. We won't cover how to declare a string variable or manipulate string yet, until after the mid-semester break. For now, we will use strings in the context of printing output messages to the users. You can imagine that as the number of possible letter grades increases (NUS has 11), we will have many nested if - else , and the code gets complicated. To reduce the number of nesting, we can write else if directly, without nesting: 1 2 3 4 5 6 7 8 9 10 11 12 void print_score ( double score ) { if ( score >= 8 ) { cs1010_println_string ( \"A\" ); } else if ( score >= 5 ) { cs1010_println_string ( \"B\" ); } else if ( score >= 3 ) { cs1010_println_string ( \"C\" ); } else { cs1010_println_string ( \"D\" ); } } The above code is easier to read but has exactly the same flow as the one with nested if - else earlier. Avoid Skipping the Curly Braces The C standard says that, if the block contains only one statement, we can skip the curly braces { and } . In the example above, we can write: 1 2 3 4 5 6 7 8 9 10 11 void print_score ( double score ) { if ( score >= 8 ) cs1010_println_string ( \"A\" ); else if ( score >= 5 ) cs1010_println_string ( \"B\" ); else if ( score >= 3 ) cs1010_println_string ( \"C\" ); else cs1010_println_string ( \"D\" ); } Despite being allowed by the C standard, this is considered a bad practice and should be avoided. Imagine some time later, you go back to this code, and want to write something extra: 1 2 3 4 5 6 7 8 9 10 11 12 void print_score ( double score ) { if ( score >= 8 ) cs1010_println_string ( \"A\" ); else if ( score >= 5 ) cs1010_println_string ( \"B\" ); else if ( score >= 3 ) cs1010_println_string ( \"C\" ); else cs1010_println_string ( \"You can do better!\" ); cs1010_println_string ( \"D\" ); } What would be printed? The famous Apple goto fail bug wouldn't have happened in the there is a pair of curly braces added! Alternatively, if you have code like this: 1 2 3 4 5 if ( score >= 8 ) if ( late_penalty != 0 ) cs1010_println_string ( \"late submission\" ); else cs1010_println_string ( \"you can do better!\" ); It might look like you can do better! will be printed if score is less than 8, but actually, you can do better! will be printed if the score is larger or equal to 8 and there is no late penalty, which is not what is intended. Skipping else In some algorithms, it is not necessary for us to have an else block. Take, for instance, suppose we have a variable max_so_far and we wish to compare it with another variable x . We will set max_so_far to x if x is the larger of the two, but we do not need to do anything otherwise. We could write it as: 1 2 3 4 5 6 : if ( max_so_far < x ) { max_so_far = x ; } else { } : The false block is empty, and we could keep our code succinct by removing it altogether. 1 2 3 4 5 : if ( max_so_far < x ) { max_so_far = x ; } : One, however, needs to be careful with skipping the else block. Let's consider another example. Suppose we have three long variables, x , y , and max , and we want to set max to the maximum of x and y . Consider the following code snippet: 1 2 3 4 5 6 if ( x > y ) { max = x ; } if ( x < y ) { max = y ; } Take a moment to understand the code above, and see if you can figure out what is wrong. When we think about writing conditionals, we have to exhaustively reason about what are all the possible scenarios that could occur . In this example, we need to think about what are the possible relationships between x and y when we compare x an y . There are actually three possibilities! x > y : in this case, x is larger and we set max to x y > x : in this case, y is larger and we set max to y x == y : in this case, both are equally large, so the maximum of the two can be either x or y . In the code above, max is not set properly if x == y ! The following code adds the third case and arbitrarily chooses to set max to y if both x and y have the same value. 1 2 3 4 5 6 7 8 9 if ( x > y ) { max = x ; } if ( x < y ) { max = y ; } if ( x == y ) { max = y ; } The code snippet above now correctly sets max to the maximum of x and y . The code, however, is not very satisfying, since we compare between x and y three times! Since the \"true block\" for x < y and x == y are the same, and we can combine it into a single comparison x <= y . 1 2 3 4 5 6 if ( x > y ) { max = x ; } if ( x <= y ) { max = y ; } But, if x > y is false, then x <= y must be true! We say that x > y and x <= y are negation (or opposite) of each other. So, the check for x <= y is redundant -- checking x > y is enough to tell us if x <= y . We can re-write the code above succinctly as: 1 2 3 4 5 if ( x > y ) { max = x ; } else { max = y ; } So, we should not skip the else block in the case above to begin with. There are, however, other cases where the else block can be skipped. Consider the code: 1 2 3 4 5 6 7 8 9 10 long factorial ( long n ) { long answer ; if ( n == 0 ) { answer = 1 ; } else { answer = n * factorial ( n - 1 ); } return answer ; } We could actually write it more succinctly as: 1 2 3 4 5 6 7 8 long factorial ( long n ) { if ( n == 0 ) { return 1 ; } else { return n * factorial ( n - 1 ); } } We can have a more succinct code by removing the variable answer since it is not used in any other meaningful way except as a placeholder to be returned later. Now that we removed the variable answer , we could go one step further, and remove the else . 1 2 3 4 5 6 7 long factorial ( long n ) { if ( n == 0 ) { return 1 ; } return n * factorial ( n - 1 ); } We can always do this without changing the outcome of the function since Line 6 will be executed only if the condition of Line 3 is false. If the condition on Line 3 is true, the function will return and Line 6 will be skipped! In CS1010, we following this rule: we do not write an else after a return statement, since it is redundant. Conditional Operator The conditional operator consists of two special characters ? and : and is used in the format of: 1 condition ? true expression : false expression; If the condition evaluates to true, then the true expression will be evaluated and returned, otherwise, the false expression will be evaluated and returned. The conditional operator allows us to replace 1 2 3 4 5 if ( x > y ) { max = x ; } else { max = y ; } with a single line: 1 max = (x > y) ? x : y; We can nest the conditional operator as well, but it does not necessarily make your code easier to read once you start nesting them up. For example, 1 a = (x > y) ? ((y > z) ? y : z) : ((z > x) ? x : z); Nesting conditional operators is therefore not allowed in CS1010. Comparing Real Numbers Recall that we said real numbers cannot be represented exactly in computers . Comparing real numbers, therefore, becomes a little bit trickier in programming. The if statement 1 2 3 4 5 double expected_value = 0.3 ; double sum = 0.1 + 0.2 ; if ( sum == expected_value ) { : } would not be evaluated as true as expected! Thus, to compare real numbers, we normally allow some errors in comparisons -- we want the absolute difference between sum and expected_value to be small enough. 1 2 3 4 5 double expected_value = 0.3 ; double sum = 0.1 + 0.2 ; if ( fabs ( sum - expected_value ) < 0.000001 ) { : } Problem Sets Problem 8.1 Do the following two functions behave the same way? Explain. 1 2 3 4 5 6 7 8 9 long factorial ( long n ) { long answer ; if ( n == 0 ) { answer = 1 ; } answer = n * factorial ( n - 1 ); return answer ; } and 1 2 3 4 5 6 7 8 9 10 long factorial ( long n ) { long answer ; if ( n == 0 ) { answer = 1 ; } else { answer = n * factorial ( n - 1 ); } return answer ; } Problem 8.2 Draw the flowcharts for the three code snippets below. Identify redundant comparisons (if any), in each of the snippet. (a) 1 2 3 4 5 6 7 8 9 if ( x > y ) { max = x ; } if ( x < y ) { max = y ; } if ( x == y ) { max = y ; } (b) 1 2 3 4 5 6 7 if ( x > y ) { max = x ; } else if ( x < y ) { max = y ; } else if ( x == y ) { max = y ; } (c) 1 2 3 4 5 if ( x > y ) { max = x ; } else { max = y ; } Problem 8.3 Suppose we break down the table below in a slightly different way. Score Letter Grade 8 or higher A Less than 8 but 5 or higher B Less than 5 but 3 or higher C Less than 3 D We rewrite the tables into three smaller tables, as: Score Letter Grade 5 or higher See Table 3 Less than 5 See Table 4 where Table 3 (5 or higher) is Score Letter Grade 8 or higher A Less than 8 B and Table 4 (less than 5) is Score Letter Grade 3 or higher C Less than 3 D Write the corresponding if - else statements to print out the letter grade based on the tables above.","title":"8. Conditional Statement"},{"location":"08-if-else.html#unit-8-conditional-statement","text":"","title":"Unit 8: Conditional Statement"},{"location":"08-if-else.html#learning-objectives","text":"After going through this unit, students should: understand that branching in flowcharts relates to either if-else statements or loop; be able to identify the three components of an if-else statement: the condition, the true block, and the false block; be able to develop an if-else statement in C, including, (i) nested if-else , (ii) if without else blocks , and (iii) else if blocks; be able to model a computational solution with different conditions as a table; understand the meaning and the use of the type void understand the term string and be able to use cs1010_println_string to print a string to the screen. be aware that in CS1010: curly brackets must not be skipped even if a block contains only a single statement; nested conditional operators are banned. be aware of floating-point numbers must not be compared using equality.","title":"Learning Objectives"},{"location":"08-if-else.html#branching","text":"So far the C programs that we have written have a straightforward execution path . The execution flows from top to bottom in main , jumping to a function being called (or callee ), and back to the caller when the function returns. We have, however, seen a few examples so far where the execution path can branch off to either one of two paths, depends on a condition: In the algorithm to compute the \\(max(L, k)\\) , we check if \\(i\\) equals \\(k\\) , and stop checking if it is true; repeat if it is false. In the algorithm to compute the \\(max(L, k)\\) , we check if \\(l_i > m\\) , and update \\(m\\) only if this is true. In the algorithm to compute the \\(factorial(n)\\) , we check if \\(n\\) equals 0, and return 1 if it is true, otherwise, we return \\(n \\times factorial(n-1)\\) . We are not ready to write C code that processes a list repetitively yet. So the first example above will be covered in Unit 11. In this unit, we will use the \\(factorial(n)\\) function as an example. In C, the \\(factorial(n)\\) would look like this: 1 2 3 4 5 6 7 8 9 10 long factorial ( long n ) { long answer ; if ( n == 0 ) { answer = 1 ; } else { answer = n * factorial ( n - 1 ); } return answer ; } In this example, you see two new C keywords if and else . These keywords are used conditional blocks . The general syntax is: 1 2 3 4 5 if ( < logical expression > ) { \"true block\" : statements to be executed if expression evaluates to true } else { \"false block\" : statements to be executed if expression evaluates to false } The if keyword is followed by a logical expression in parenthesis. This is followed by a block of statements (in curly braces { and } ). If the logical expression is true, then the statements are executed, otherwise, they are skipped, and the statements following the else block is executed instead. For this reason, the group of statements following if is known as a true block , and the group of statements following else is known as the false block .","title":"Branching"},{"location":"08-if-else.html#comparison-operator","text":"The logical expression n == 0 is true if the variable n holds the value of 0 . == vs = Note that the use of TWO = signs. This is often confused by newbie programmers with a single = sign, which is used for assignment. A common bug is to write 1 2 3 if ( n = 0 ) { : } The == is known as a comparison operator . It compares if the left-hand side has the same value as the right-hand side. Other comparison operators include > (greater than), < (less than), >= (greater or equal to), <= (less than or equal to), and != (not equal). In other words, the variable answer will be set to 1 if the parameter n equals 0 . What if n is not 0 ? The block that contains Line 5 return 1; will be skipped, and Line 7 answer = n * factorial(n - 1); will be executed instead.","title":"Comparison Operator"},{"location":"08-if-else.html#nested-else-if","text":"The example above considers two possible execution paths only. In some situations, we may need to consider more than two execution paths. Take the following problem for example. You are given the numerical score for an assignment, ranged between 0 and 10. Print out the letter grade of the assignment according to the table below: Score Letter Grade 8 or higher A Less than 8 but 5 or higher B Less than 5 but 3 or higher C Less than 3 D Since the if - else statement only allows branching into two possibilities, we can branch into multiple possibilities by nesting the if - else statements hierarchically. We can first break the table down into three tables, each containing only two rows, with one row a negation of the other row. Score Letter Grade 8 or higher A Less than 8 See Table 1 Table 1 (less than 8) Score Letter Grade 5 or higher B Less than 5 See Table 2 Table 2 (less than 5) Score Letter Grade 3 or higher C Less than 3 D The tables above can then be written into the following function: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void print_score ( double score ) { if ( score >= 8 ) { cs1010_println_string ( \"A\" ); } else { // Table 1 if ( score >= 5 ) { cs1010_println_string ( \"B\" ); } else { // Table 2 if ( score >= 3 ) { cs1010_println_string ( \"C\" ); } else { cs1010_println_string ( \"D\" ); } } } } There are three nested if - else in the function above. Note how I use indentation to clearly indicate the nesting of blocks. Such nesting or indentation is not required by C standard, but is a commonly accepted coding practice, and is required for CS1010. The code below compiles perfectly but is not as easy to read by a human as the above. 1 2 3 4 5 6 7 8 9 10 11 12 void print_score ( double score ) { if ( score >= 8 ) { cs1010_println_string ( \"A\" ); } else { // Table 1 if ( score >= 5 ) { cs1010_println_string ( \"B\" ); } else { // Table 2 if ( score >= 3 ) { cs1010_println_string ( \"C\" ); } else { cs1010_println_string ( \"D\" ); } } } } // Don't write code like this. There are also a couple of \"first\" in the sample code above: You see the keyword void for the first time. void is a special type that indicates nothing. The function print_score does not return anything, it accepts an input score and print something to screen. As such, we say that the return type of print_score is void . You see strings for the first time ( \"A\" , etc.). A string basically is a sequence of characters. We use double quotes \" to mark the beginning and the end of a string, and use the CS1010 I/O library function cs1010_println_string to print a string to the screen. We won't cover how to declare a string variable or manipulate string yet, until after the mid-semester break. For now, we will use strings in the context of printing output messages to the users. You can imagine that as the number of possible letter grades increases (NUS has 11), we will have many nested if - else , and the code gets complicated. To reduce the number of nesting, we can write else if directly, without nesting: 1 2 3 4 5 6 7 8 9 10 11 12 void print_score ( double score ) { if ( score >= 8 ) { cs1010_println_string ( \"A\" ); } else if ( score >= 5 ) { cs1010_println_string ( \"B\" ); } else if ( score >= 3 ) { cs1010_println_string ( \"C\" ); } else { cs1010_println_string ( \"D\" ); } } The above code is easier to read but has exactly the same flow as the one with nested if - else earlier.","title":"Nested Else-If"},{"location":"08-if-else.html#avoid-skipping-the-curly-braces","text":"The C standard says that, if the block contains only one statement, we can skip the curly braces { and } . In the example above, we can write: 1 2 3 4 5 6 7 8 9 10 11 void print_score ( double score ) { if ( score >= 8 ) cs1010_println_string ( \"A\" ); else if ( score >= 5 ) cs1010_println_string ( \"B\" ); else if ( score >= 3 ) cs1010_println_string ( \"C\" ); else cs1010_println_string ( \"D\" ); } Despite being allowed by the C standard, this is considered a bad practice and should be avoided. Imagine some time later, you go back to this code, and want to write something extra: 1 2 3 4 5 6 7 8 9 10 11 12 void print_score ( double score ) { if ( score >= 8 ) cs1010_println_string ( \"A\" ); else if ( score >= 5 ) cs1010_println_string ( \"B\" ); else if ( score >= 3 ) cs1010_println_string ( \"C\" ); else cs1010_println_string ( \"You can do better!\" ); cs1010_println_string ( \"D\" ); } What would be printed? The famous Apple goto fail bug wouldn't have happened in the there is a pair of curly braces added! Alternatively, if you have code like this: 1 2 3 4 5 if ( score >= 8 ) if ( late_penalty != 0 ) cs1010_println_string ( \"late submission\" ); else cs1010_println_string ( \"you can do better!\" ); It might look like you can do better! will be printed if score is less than 8, but actually, you can do better! will be printed if the score is larger or equal to 8 and there is no late penalty, which is not what is intended.","title":"Avoid Skipping the Curly Braces"},{"location":"08-if-else.html#skipping-else","text":"In some algorithms, it is not necessary for us to have an else block. Take, for instance, suppose we have a variable max_so_far and we wish to compare it with another variable x . We will set max_so_far to x if x is the larger of the two, but we do not need to do anything otherwise. We could write it as: 1 2 3 4 5 6 : if ( max_so_far < x ) { max_so_far = x ; } else { } : The false block is empty, and we could keep our code succinct by removing it altogether. 1 2 3 4 5 : if ( max_so_far < x ) { max_so_far = x ; } : One, however, needs to be careful with skipping the else block. Let's consider another example. Suppose we have three long variables, x , y , and max , and we want to set max to the maximum of x and y . Consider the following code snippet: 1 2 3 4 5 6 if ( x > y ) { max = x ; } if ( x < y ) { max = y ; } Take a moment to understand the code above, and see if you can figure out what is wrong. When we think about writing conditionals, we have to exhaustively reason about what are all the possible scenarios that could occur . In this example, we need to think about what are the possible relationships between x and y when we compare x an y . There are actually three possibilities! x > y : in this case, x is larger and we set max to x y > x : in this case, y is larger and we set max to y x == y : in this case, both are equally large, so the maximum of the two can be either x or y . In the code above, max is not set properly if x == y ! The following code adds the third case and arbitrarily chooses to set max to y if both x and y have the same value. 1 2 3 4 5 6 7 8 9 if ( x > y ) { max = x ; } if ( x < y ) { max = y ; } if ( x == y ) { max = y ; } The code snippet above now correctly sets max to the maximum of x and y . The code, however, is not very satisfying, since we compare between x and y three times! Since the \"true block\" for x < y and x == y are the same, and we can combine it into a single comparison x <= y . 1 2 3 4 5 6 if ( x > y ) { max = x ; } if ( x <= y ) { max = y ; } But, if x > y is false, then x <= y must be true! We say that x > y and x <= y are negation (or opposite) of each other. So, the check for x <= y is redundant -- checking x > y is enough to tell us if x <= y . We can re-write the code above succinctly as: 1 2 3 4 5 if ( x > y ) { max = x ; } else { max = y ; } So, we should not skip the else block in the case above to begin with. There are, however, other cases where the else block can be skipped. Consider the code: 1 2 3 4 5 6 7 8 9 10 long factorial ( long n ) { long answer ; if ( n == 0 ) { answer = 1 ; } else { answer = n * factorial ( n - 1 ); } return answer ; } We could actually write it more succinctly as: 1 2 3 4 5 6 7 8 long factorial ( long n ) { if ( n == 0 ) { return 1 ; } else { return n * factorial ( n - 1 ); } } We can have a more succinct code by removing the variable answer since it is not used in any other meaningful way except as a placeholder to be returned later. Now that we removed the variable answer , we could go one step further, and remove the else . 1 2 3 4 5 6 7 long factorial ( long n ) { if ( n == 0 ) { return 1 ; } return n * factorial ( n - 1 ); } We can always do this without changing the outcome of the function since Line 6 will be executed only if the condition of Line 3 is false. If the condition on Line 3 is true, the function will return and Line 6 will be skipped! In CS1010, we following this rule: we do not write an else after a return statement, since it is redundant.","title":"Skipping else"},{"location":"08-if-else.html#conditional-operator","text":"The conditional operator consists of two special characters ? and : and is used in the format of: 1 condition ? true expression : false expression; If the condition evaluates to true, then the true expression will be evaluated and returned, otherwise, the false expression will be evaluated and returned. The conditional operator allows us to replace 1 2 3 4 5 if ( x > y ) { max = x ; } else { max = y ; } with a single line: 1 max = (x > y) ? x : y; We can nest the conditional operator as well, but it does not necessarily make your code easier to read once you start nesting them up. For example, 1 a = (x > y) ? ((y > z) ? y : z) : ((z > x) ? x : z); Nesting conditional operators is therefore not allowed in CS1010.","title":"Conditional Operator"},{"location":"08-if-else.html#comparing-real-numbers","text":"Recall that we said real numbers cannot be represented exactly in computers . Comparing real numbers, therefore, becomes a little bit trickier in programming. The if statement 1 2 3 4 5 double expected_value = 0.3 ; double sum = 0.1 + 0.2 ; if ( sum == expected_value ) { : } would not be evaluated as true as expected! Thus, to compare real numbers, we normally allow some errors in comparisons -- we want the absolute difference between sum and expected_value to be small enough. 1 2 3 4 5 double expected_value = 0.3 ; double sum = 0.1 + 0.2 ; if ( fabs ( sum - expected_value ) < 0.000001 ) { : }","title":"Comparing Real Numbers"},{"location":"08-if-else.html#problem-sets","text":"","title":"Problem Sets"},{"location":"08-if-else.html#problem-81","text":"Do the following two functions behave the same way? Explain. 1 2 3 4 5 6 7 8 9 long factorial ( long n ) { long answer ; if ( n == 0 ) { answer = 1 ; } answer = n * factorial ( n - 1 ); return answer ; } and 1 2 3 4 5 6 7 8 9 10 long factorial ( long n ) { long answer ; if ( n == 0 ) { answer = 1 ; } else { answer = n * factorial ( n - 1 ); } return answer ; }","title":"Problem 8.1"},{"location":"08-if-else.html#problem-82","text":"Draw the flowcharts for the three code snippets below. Identify redundant comparisons (if any), in each of the snippet. (a) 1 2 3 4 5 6 7 8 9 if ( x > y ) { max = x ; } if ( x < y ) { max = y ; } if ( x == y ) { max = y ; } (b) 1 2 3 4 5 6 7 if ( x > y ) { max = x ; } else if ( x < y ) { max = y ; } else if ( x == y ) { max = y ; } (c) 1 2 3 4 5 if ( x > y ) { max = x ; } else { max = y ; }","title":"Problem 8.2"},{"location":"08-if-else.html#problem-83","text":"Suppose we break down the table below in a slightly different way. Score Letter Grade 8 or higher A Less than 8 but 5 or higher B Less than 5 but 3 or higher C Less than 3 D We rewrite the tables into three smaller tables, as: Score Letter Grade 5 or higher See Table 3 Less than 5 See Table 4 where Table 3 (5 or higher) is Score Letter Grade 8 or higher A Less than 8 B and Table 4 (less than 5) is Score Letter Grade 3 or higher C Less than 3 D Write the corresponding if - else statements to print out the letter grade based on the tables above.","title":"Problem 8.3"},{"location":"09-logical-exp.html","text":"Unit 9: Logical Expression Learning Objectives After this unit, students should: be able to read and write logical expressions in C using various logical operators, including == , < , <= , < , >= , != , && , || and ! ; be aware of the bool type and its values true and false , and the need to include stdbool.h to use it in C; be aware that in CS1010, we must never use int to indicate a true/false value; be aware of short-circuiting in logical expression; be aware of the CS1010's convention of naming a boolean variable with the prefix is_ , has_ , or can_ ; be able to write a logical expression in appropriate order to exploit short-circuiting towards more efficient code Representing a Boolean Value You have seen some basic logical expressions in Unit 8 . n == 0 , score >= 5 , y > x , are all logical expressions. They evaluate to either true or false. We call a type that can contain either true or false as a Boolean data type, named after George Boole , a mathematician. The Boolean data type in C is named bool . It can hold two values: true or false . All three of bool , true , and false are keywords introduced in modern C. To use them, you need to include the file stdbool.h at the top of your program. Use bool is considered a cleaner way of representing true and false in C. Classically, C defines the numeric value 0 to be false, and everything else to be true. So, you can write code like this: 1 2 3 4 5 // x and y are long. long is_diff = x - y ; if ( is_diff ) { cs1010_println_string ( \"x and y store different values.\" ); } The above is harder to understand and should be avoided. A cleaner way is to write: 1 2 3 4 bool is_diff = x != y ; if ( is_diff ) { cs1010_println_string ( \"x and y store different values.\" ); } Although not required by C, we will name a bool variable with a prefix is_ , has_ , or can_ , as a convention. The code above can also be written as: 1 2 3 4 bool is_diff = x != y ; if ( is_diff == true ) { cs1010_println_string ( \"x and y store different values.\" ); } The comparison with true is redundant, however, and should be skipped. Logical Operators Just like we can perform arithmetic operations on integers and real numbers, we can perform logical operations on boolean values. These operations allow us to write complex logical expressions. Consider the example problem: Write a function that, given the birth year of a person, determine if he or she belongs to Generation Z, defined as someone whose birth is between 1995 and 2005, inclusive. We can write the function as follows using what we have known: 1 2 3 4 5 6 7 8 9 bool is_gen_z ( long birth_year ) { if ( birth_year >= 1995 ) { if ( birth_year <= 2005 ) { return true ; } } return false ; } To be in Generation Z, both conditions birth_year >= 1995 and birth_year <= 2005 must be true. We can use the logical AND && operator to simplify the code above to: 1 2 3 4 5 6 7 bool is_gen_z ( long birth_year ) { if (( birth_year >= 1995 ) && ( birth_year <= 2005 )) { return true ; } return false ; } or simply: 1 2 3 4 bool is_gen_z ( long birth_year ) { return (( birth_year >= 1995 ) && ( birth_year <= 2005 )); } The AND operator, && , evaluates to true if and only if both operands are true. Common Error A common mistake by a new C programmer is to write 1995 <= birth_year <= 2005 as the logical expression. Unfortunately, in C, we cannot chain the comparison operators together. What if we want to write a function to determine if someone is NOT part of Generation Z? This means that they are born either before 1995 or after 2005. To have an expression that evaluates to true if either one of two expressions is true, we can use the OR operator, || . 1 2 3 4 bool is_not_gen_z ( long birth_year ) { return (( birth_year < 1995 ) || ( birth_year > 2005 )); } Generally, we prefer to write functions that check for the positives, as it is generally easier to think in terms of the positives. So the example is_not_gen_z above is for illustration purposes only, we do not encourage you to write functions that check for the negatives. In any case, if we want to check if someone is not a Generation Z, we can use the ! NOT operator. 1 2 3 if ( ! is_gen_z ( birth_year )) { : } The ! operator can be used as part of the boolean expression: 1 2 3 4 bool is_not_gen_z ( long birth_year ) { return ! (( birth_year >= 1995 ) && ( birth_year <= 2005 )); } Short-Circuiting When evaluating the logical expressions that involve && and || , C uses \"short-circuiting\". If the program already know, for sure, that a logical expression is true or is false, there is no need to continue the evaluation. The corresponding true and false value will be returned. Consider the following: 1 2 3 4 bool is_gen_z ( long birth_year ) { return (( birth_year >= 1995 ) && ( birth_year <= 2005 )); } If the argument birth_year is 1970 , then, the expression (birth_year >= 1995) already evaluates to false , and the whole statement is false. We do not need to evaluate the second expression (birth_year <= 2005) . Similarly, for 1 2 3 4 bool is_not_gen_z ( long birth_year ) { return (( birth_year < 1995 ) || ( birth_year > 2005 )); } When birth_year is 1970 , the expression (birth_year < 1995) is true , so we know that the whole statement is true . There is no need to check if (birth_year > 2005) . In both examples above, the savings due to short-circuiting is not much -- since we are comparing two numbers, and there is no side effects in comparing birth_year to 2005 . But, let's suppose that we introduce two functions with side effects (of printing to the screen): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 bool not_too_old ( long birth_year ) { if ( birth_year >= 1995 ) { cs1010_print_string ( \"not too old..\" ); return true ; } cs1010_print_string ( \"too old..\" ); return false ; } bool not_too_young ( long birth_year ) { if ( birth_year <= 2005 ) { cs1010_print_string ( \"not too young..\" ); return true ; } cs1010_print_string ( \"too young..\" ); return false ; } bool is_gen_z ( long birth_year ) { return not_too_old ( birth_year ) && not_too_young ( birth_year ); } When we call is_gen_z(1984) , you might expect too old..not too young.. to be printed, but due to short-circuiting, the code only prints too old.. . Another reason to keep short-circuiting in mind is that the order of the logical expressions matter: we would want to put the logical expression that involves more work in the second half of the expression. Take the following example: 1 2 3 if ( number < 100000 && is_prime ( number )) { : } Checking whether a number is below 100,000 is easier than checking if a number is prime. So, we can skip checking for primality if the number is too big. Compare this to: 1 2 3 if ( is_prime ( number ) && number < 100000 ) { : } Suppose number is a gigantic integer, then we would have spent lots of effort checking if number is a prime, only to find out that it is too big anyway! Problem Sets Problem 9.1 Given two bool variables, a and b , there are four possible combinations of true false values. What are the values of a && b , a || b , and !a for each of these combinations? Fill in the table below. a b a && b a || b !a true true true false false true false false Problem 9.2 Consider the function below, which aims to return the maximum value given three numbers. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 long max_of_three ( long a , long b , long c ) { long max = 0 ; if (( a > b ) && ( a > c )) { // a is larger than b and c max = a ; } if (( b > a ) && ( b > c )) { // b is larger than a and c max = b ; } if (( c > a ) && ( c > b )) { // c is larger than a and b max = c ; } return max ; } (a) What is wrong with the code above? (b) Give a sample test value of a , b , and c that would expose the bug. (c) Fix the code above to remove the bug. (d) Replace the three if statements in the code above with if - else statements. Draw the corresponding flowchart. Problem 9.3 Write a function that takes in a blood pressure measurement, and prints either low , ideal , pre-high , and high depending on the input values. The blood pressure is given as two long values, the systolic and the diastolic. The text to be printed depends on the range, depicted in the figure below. 1 2 3 4 void print_blood_pressure ( long systolic , long diastolic ) { : } The figure does not say how to classify the data if the values fall exactly on the boundary of two regions. In this case, you can classify it into either region. Problem 9.4 The restaurant WcDonald's is setting a new rule for dining in. Two people are allowed to dine in only if both of them are fully vaccinnated against COVID-19. A child below 12 years old from the same household is exempted from the rule. Suppose we represent each diner with a long variable, and we have the following functions: bool is_vaccinated(long p) returns true if and only if p is fully vaccinated. bool is_a_child(long p) returns true if and only if p is a child below 12. bool are_from_same_household(long p, long q) returns true if and only if both p and q are from the same household. Write a function can_dine_in(long p, long q) that returns true if and only if p and q can dine in together at WcDonald's.","title":"9. Logical Expression"},{"location":"09-logical-exp.html#unit-9-logical-expression","text":"","title":"Unit 9: Logical Expression"},{"location":"09-logical-exp.html#learning-objectives","text":"After this unit, students should: be able to read and write logical expressions in C using various logical operators, including == , < , <= , < , >= , != , && , || and ! ; be aware of the bool type and its values true and false , and the need to include stdbool.h to use it in C; be aware that in CS1010, we must never use int to indicate a true/false value; be aware of short-circuiting in logical expression; be aware of the CS1010's convention of naming a boolean variable with the prefix is_ , has_ , or can_ ; be able to write a logical expression in appropriate order to exploit short-circuiting towards more efficient code","title":"Learning Objectives"},{"location":"09-logical-exp.html#representing-a-boolean-value","text":"You have seen some basic logical expressions in Unit 8 . n == 0 , score >= 5 , y > x , are all logical expressions. They evaluate to either true or false. We call a type that can contain either true or false as a Boolean data type, named after George Boole , a mathematician. The Boolean data type in C is named bool . It can hold two values: true or false . All three of bool , true , and false are keywords introduced in modern C. To use them, you need to include the file stdbool.h at the top of your program. Use bool is considered a cleaner way of representing true and false in C. Classically, C defines the numeric value 0 to be false, and everything else to be true. So, you can write code like this: 1 2 3 4 5 // x and y are long. long is_diff = x - y ; if ( is_diff ) { cs1010_println_string ( \"x and y store different values.\" ); } The above is harder to understand and should be avoided. A cleaner way is to write: 1 2 3 4 bool is_diff = x != y ; if ( is_diff ) { cs1010_println_string ( \"x and y store different values.\" ); } Although not required by C, we will name a bool variable with a prefix is_ , has_ , or can_ , as a convention. The code above can also be written as: 1 2 3 4 bool is_diff = x != y ; if ( is_diff == true ) { cs1010_println_string ( \"x and y store different values.\" ); } The comparison with true is redundant, however, and should be skipped.","title":"Representing a Boolean Value"},{"location":"09-logical-exp.html#logical-operators","text":"Just like we can perform arithmetic operations on integers and real numbers, we can perform logical operations on boolean values. These operations allow us to write complex logical expressions. Consider the example problem: Write a function that, given the birth year of a person, determine if he or she belongs to Generation Z, defined as someone whose birth is between 1995 and 2005, inclusive. We can write the function as follows using what we have known: 1 2 3 4 5 6 7 8 9 bool is_gen_z ( long birth_year ) { if ( birth_year >= 1995 ) { if ( birth_year <= 2005 ) { return true ; } } return false ; } To be in Generation Z, both conditions birth_year >= 1995 and birth_year <= 2005 must be true. We can use the logical AND && operator to simplify the code above to: 1 2 3 4 5 6 7 bool is_gen_z ( long birth_year ) { if (( birth_year >= 1995 ) && ( birth_year <= 2005 )) { return true ; } return false ; } or simply: 1 2 3 4 bool is_gen_z ( long birth_year ) { return (( birth_year >= 1995 ) && ( birth_year <= 2005 )); } The AND operator, && , evaluates to true if and only if both operands are true. Common Error A common mistake by a new C programmer is to write 1995 <= birth_year <= 2005 as the logical expression. Unfortunately, in C, we cannot chain the comparison operators together. What if we want to write a function to determine if someone is NOT part of Generation Z? This means that they are born either before 1995 or after 2005. To have an expression that evaluates to true if either one of two expressions is true, we can use the OR operator, || . 1 2 3 4 bool is_not_gen_z ( long birth_year ) { return (( birth_year < 1995 ) || ( birth_year > 2005 )); } Generally, we prefer to write functions that check for the positives, as it is generally easier to think in terms of the positives. So the example is_not_gen_z above is for illustration purposes only, we do not encourage you to write functions that check for the negatives. In any case, if we want to check if someone is not a Generation Z, we can use the ! NOT operator. 1 2 3 if ( ! is_gen_z ( birth_year )) { : } The ! operator can be used as part of the boolean expression: 1 2 3 4 bool is_not_gen_z ( long birth_year ) { return ! (( birth_year >= 1995 ) && ( birth_year <= 2005 )); }","title":"Logical Operators"},{"location":"09-logical-exp.html#short-circuiting","text":"When evaluating the logical expressions that involve && and || , C uses \"short-circuiting\". If the program already know, for sure, that a logical expression is true or is false, there is no need to continue the evaluation. The corresponding true and false value will be returned. Consider the following: 1 2 3 4 bool is_gen_z ( long birth_year ) { return (( birth_year >= 1995 ) && ( birth_year <= 2005 )); } If the argument birth_year is 1970 , then, the expression (birth_year >= 1995) already evaluates to false , and the whole statement is false. We do not need to evaluate the second expression (birth_year <= 2005) . Similarly, for 1 2 3 4 bool is_not_gen_z ( long birth_year ) { return (( birth_year < 1995 ) || ( birth_year > 2005 )); } When birth_year is 1970 , the expression (birth_year < 1995) is true , so we know that the whole statement is true . There is no need to check if (birth_year > 2005) . In both examples above, the savings due to short-circuiting is not much -- since we are comparing two numbers, and there is no side effects in comparing birth_year to 2005 . But, let's suppose that we introduce two functions with side effects (of printing to the screen): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 bool not_too_old ( long birth_year ) { if ( birth_year >= 1995 ) { cs1010_print_string ( \"not too old..\" ); return true ; } cs1010_print_string ( \"too old..\" ); return false ; } bool not_too_young ( long birth_year ) { if ( birth_year <= 2005 ) { cs1010_print_string ( \"not too young..\" ); return true ; } cs1010_print_string ( \"too young..\" ); return false ; } bool is_gen_z ( long birth_year ) { return not_too_old ( birth_year ) && not_too_young ( birth_year ); } When we call is_gen_z(1984) , you might expect too old..not too young.. to be printed, but due to short-circuiting, the code only prints too old.. . Another reason to keep short-circuiting in mind is that the order of the logical expressions matter: we would want to put the logical expression that involves more work in the second half of the expression. Take the following example: 1 2 3 if ( number < 100000 && is_prime ( number )) { : } Checking whether a number is below 100,000 is easier than checking if a number is prime. So, we can skip checking for primality if the number is too big. Compare this to: 1 2 3 if ( is_prime ( number ) && number < 100000 ) { : } Suppose number is a gigantic integer, then we would have spent lots of effort checking if number is a prime, only to find out that it is too big anyway!","title":"Short-Circuiting"},{"location":"09-logical-exp.html#problem-sets","text":"","title":"Problem Sets"},{"location":"09-logical-exp.html#problem-91","text":"Given two bool variables, a and b , there are four possible combinations of true false values. What are the values of a && b , a || b , and !a for each of these combinations? Fill in the table below. a b a && b a || b !a true true true false false true false false","title":"Problem 9.1"},{"location":"09-logical-exp.html#problem-92","text":"Consider the function below, which aims to return the maximum value given three numbers. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 long max_of_three ( long a , long b , long c ) { long max = 0 ; if (( a > b ) && ( a > c )) { // a is larger than b and c max = a ; } if (( b > a ) && ( b > c )) { // b is larger than a and c max = b ; } if (( c > a ) && ( c > b )) { // c is larger than a and b max = c ; } return max ; } (a) What is wrong with the code above? (b) Give a sample test value of a , b , and c that would expose the bug. (c) Fix the code above to remove the bug. (d) Replace the three if statements in the code above with if - else statements. Draw the corresponding flowchart.","title":"Problem 9.2"},{"location":"09-logical-exp.html#problem-93","text":"Write a function that takes in a blood pressure measurement, and prints either low , ideal , pre-high , and high depending on the input values. The blood pressure is given as two long values, the systolic and the diastolic. The text to be printed depends on the range, depicted in the figure below. 1 2 3 4 void print_blood_pressure ( long systolic , long diastolic ) { : } The figure does not say how to classify the data if the values fall exactly on the boundary of two regions. In this case, you can classify it into either region.","title":"Problem 9.3"},{"location":"09-logical-exp.html#problem-94","text":"The restaurant WcDonald's is setting a new rule for dining in. Two people are allowed to dine in only if both of them are fully vaccinnated against COVID-19. A child below 12 years old from the same household is exempted from the rule. Suppose we represent each diner with a long variable, and we have the following functions: bool is_vaccinated(long p) returns true if and only if p is fully vaccinated. bool is_a_child(long p) returns true if and only if p is a child below 12. bool are_from_same_household(long p, long q) returns true if and only if both p and q are from the same household. Write a function can_dine_in(long p, long q) that returns true if and only if p and q can dine in together at WcDonald's.","title":"Problem 9.4"},{"location":"10-assert.html","text":"Unit 10: Assertion Learning Objectives After this unit, students should: know what is an assertion be able to derive assertion statements in an algorithm that involves assignment and branches be able to note down assertions using Hoare's notation be able to apply De Morgan's laws What is Assertion? An assertion is a logical expression that must always be true for the program to be correct. We can write assertions either as part of the comment for the code or use the assert() macro in C. Let's look at what is assertion first. We will introduce the use of assert() later. To get started, let's first look at the most trivial assertion: 1 2 long x = 1 ; // { x == 1 } The line above initialize the variable x to be 1 . The next line, a comment, uses the curly braces { and } with a logical expression in between, to indicate that x must be equals to 1 after the assignment. We use the curly braces as a notation in CS1010, following C. A. R. Hoare 's notation, but this is not part of any C standard. The assertion above is kind of trivial and not very meaningful. Let's revisit this snippet: 1 2 3 4 5 if ( x > y ) { max = x ; } else { max = y ; } Let's consider the true block and the false block. Inside the true block, since x > y , we can assert that, well, x > y , and inside the false block, we have the negation, so x <= y . 1 2 3 4 5 6 7 if ( x > y ) { // { x > y } max = x ; } else { // { x <= y } max = y ; } Let's now consider what happens after initializing max to either x or y . 1 2 3 4 5 6 7 8 9 if ( x > y ) { // { x > y } max = x ; // { max == x && max > y } } else { // { x <= y } max = y ; // { max >= x && max == y } } The assertion on Line 4 consists of two parts: max == x which is the result of the assignment (the trivial assertion), but since inside this block, x > y , we must have max > y to be true as well. Similarly, we can argue the assertion in Line 8 to be true. What can we assert after we exit from the if - else block? We have either max == x && max > y or max >= x && max == y . This is exactly the property we are looking for in max when we set it to the maximum of x and y ! Let's look at another example: 1 2 3 4 5 6 7 8 9 10 11 12 13 if ( score >= 8 ) { cs1010_println_string ( \"A\" ); } else { if ( score >= 5 ) { cs1010_println_string ( \"B\" ); } else { if ( score >= 3 ) { cs1010_println_string ( \"C\" ); } else { cs1010_println_string ( \"D\" ); } } } Let's focus on the case of printing C . We should print C if score is less than 5 but is 3 or higher. Let's check if this is correct by finding out what we can assert wrt score just before printing C . We first add the assert condition to all the true blocks and the false block by negating the if condition. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 if ( score >= 8 ) { cs1010_println_string ( \"A\" ); } else { if ( score >= 5 ) { // { score >= 5 } cs1010_println_string ( \"B\" ); } else { // { score < 5 } if ( score >= 3 ) { // { score < 5 && score >= 3 } cs1010_println_string ( \"C\" ); } else { // { score < 5 && score < 3 } cs1010_println_string ( \"D\" ); } } } We can see that, we are printing C when score < 5 && score >= 3 , which is what we want. Note that the last assert score < 5 && score < 3 can be simplified to score < 3 . Note that we write assertions with Hoare's notation as C comments, so the assertions do not have to follow C's syntax. We could have written them in English. However, as much as possible, we use mathematical or programming notations to keep our assertion succinct and precise. De Morgan's Law To write an assertion for the false block, it is useful to know the De Morgan's law, which tells us how to negate some logical expression. Suppose we have two logical expressions e1 and e2 . !(e1 && e2) is the same as (!e1) || (!e2) !(e1 || e2) is the same as (!e1) && (!e2) We have actually seen it in action. Recall the expression for Generation Z: (birth_year >= 1995) && (birth_year <= 2005) . To check for NOT Generation Z, we can write it as !((birth_year >= 1995) && (birth_year <= 2005)) , which according to De Morgan's law, is the same as !(birth_year >= 1995) || !(birth_year <= 2005) , which is just (birth_year < 1995) || (birth_year > 2005) , exactly as we have written before! Assertion and De Morgan's law are two thinking tools that will help us reason about our code. We will revisit assertion again when we discuss iterative algorithms. Problem Set 10 Problem 10.1 Negate the following logical expression, then apply De Morgan's Law to simplify the resulting expression. Assume all variable names mentioned are boolean variables. (a) (x > 1) && (y != 10) (b) !eating && drinking (c) (has_cs2030 || has_cs2113) && has_cs2040c Problem 10.2 In the code below, replace ??? with the appropriate assertion. What will be printed? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 long score = 4 ; if ( something ) { score = 10 ; } else { score = 0 ; } // { ??? } if ( score == 4 ) { score = 1 ; } else { score += 10 ; } // { ??? } if ( score >= 10 ) { cs1010_println_string ( \"ok\" ); } else { cs1010_println_string ( \"failed\" ); }","title":"10. Assertions"},{"location":"10-assert.html#unit-10-assertion","text":"","title":"Unit 10: Assertion"},{"location":"10-assert.html#learning-objectives","text":"After this unit, students should: know what is an assertion be able to derive assertion statements in an algorithm that involves assignment and branches be able to note down assertions using Hoare's notation be able to apply De Morgan's laws","title":"Learning Objectives"},{"location":"10-assert.html#what-is-assertion","text":"An assertion is a logical expression that must always be true for the program to be correct. We can write assertions either as part of the comment for the code or use the assert() macro in C. Let's look at what is assertion first. We will introduce the use of assert() later. To get started, let's first look at the most trivial assertion: 1 2 long x = 1 ; // { x == 1 } The line above initialize the variable x to be 1 . The next line, a comment, uses the curly braces { and } with a logical expression in between, to indicate that x must be equals to 1 after the assignment. We use the curly braces as a notation in CS1010, following C. A. R. Hoare 's notation, but this is not part of any C standard. The assertion above is kind of trivial and not very meaningful. Let's revisit this snippet: 1 2 3 4 5 if ( x > y ) { max = x ; } else { max = y ; } Let's consider the true block and the false block. Inside the true block, since x > y , we can assert that, well, x > y , and inside the false block, we have the negation, so x <= y . 1 2 3 4 5 6 7 if ( x > y ) { // { x > y } max = x ; } else { // { x <= y } max = y ; } Let's now consider what happens after initializing max to either x or y . 1 2 3 4 5 6 7 8 9 if ( x > y ) { // { x > y } max = x ; // { max == x && max > y } } else { // { x <= y } max = y ; // { max >= x && max == y } } The assertion on Line 4 consists of two parts: max == x which is the result of the assignment (the trivial assertion), but since inside this block, x > y , we must have max > y to be true as well. Similarly, we can argue the assertion in Line 8 to be true. What can we assert after we exit from the if - else block? We have either max == x && max > y or max >= x && max == y . This is exactly the property we are looking for in max when we set it to the maximum of x and y ! Let's look at another example: 1 2 3 4 5 6 7 8 9 10 11 12 13 if ( score >= 8 ) { cs1010_println_string ( \"A\" ); } else { if ( score >= 5 ) { cs1010_println_string ( \"B\" ); } else { if ( score >= 3 ) { cs1010_println_string ( \"C\" ); } else { cs1010_println_string ( \"D\" ); } } } Let's focus on the case of printing C . We should print C if score is less than 5 but is 3 or higher. Let's check if this is correct by finding out what we can assert wrt score just before printing C . We first add the assert condition to all the true blocks and the false block by negating the if condition. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 if ( score >= 8 ) { cs1010_println_string ( \"A\" ); } else { if ( score >= 5 ) { // { score >= 5 } cs1010_println_string ( \"B\" ); } else { // { score < 5 } if ( score >= 3 ) { // { score < 5 && score >= 3 } cs1010_println_string ( \"C\" ); } else { // { score < 5 && score < 3 } cs1010_println_string ( \"D\" ); } } } We can see that, we are printing C when score < 5 && score >= 3 , which is what we want. Note that the last assert score < 5 && score < 3 can be simplified to score < 3 . Note that we write assertions with Hoare's notation as C comments, so the assertions do not have to follow C's syntax. We could have written them in English. However, as much as possible, we use mathematical or programming notations to keep our assertion succinct and precise.","title":"What is Assertion?"},{"location":"10-assert.html#de-morgans-law","text":"To write an assertion for the false block, it is useful to know the De Morgan's law, which tells us how to negate some logical expression. Suppose we have two logical expressions e1 and e2 . !(e1 && e2) is the same as (!e1) || (!e2) !(e1 || e2) is the same as (!e1) && (!e2) We have actually seen it in action. Recall the expression for Generation Z: (birth_year >= 1995) && (birth_year <= 2005) . To check for NOT Generation Z, we can write it as !((birth_year >= 1995) && (birth_year <= 2005)) , which according to De Morgan's law, is the same as !(birth_year >= 1995) || !(birth_year <= 2005) , which is just (birth_year < 1995) || (birth_year > 2005) , exactly as we have written before! Assertion and De Morgan's law are two thinking tools that will help us reason about our code. We will revisit assertion again when we discuss iterative algorithms.","title":"De Morgan's Law"},{"location":"10-assert.html#problem-set-10","text":"","title":"Problem Set 10"},{"location":"10-assert.html#problem-101","text":"Negate the following logical expression, then apply De Morgan's Law to simplify the resulting expression. Assume all variable names mentioned are boolean variables. (a) (x > 1) && (y != 10) (b) !eating && drinking (c) (has_cs2030 || has_cs2113) && has_cs2040c","title":"Problem 10.1"},{"location":"10-assert.html#problem-102","text":"In the code below, replace ??? with the appropriate assertion. What will be printed? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 long score = 4 ; if ( something ) { score = 10 ; } else { score = 0 ; } // { ??? } if ( score == 4 ) { score = 1 ; } else { score += 10 ; } // { ??? } if ( score >= 10 ) { cs1010_println_string ( \"ok\" ); } else { cs1010_println_string ( \"failed\" ); }","title":"Problem 10.2"},{"location":"11-loop.html","text":"Unit 11: Loops Learning Objectives After this unit, students should: be able to identify the four components of a loop: initialization, body, update, and condition be able to express a computational solution as a loop with the four components above be able to implement a loop using either the for , while or do-while construct in C be able to trace through the control flows of each loop construct understand the correspondence between the different loop constructs be aware of the \"infinite loops\" bug, what causes it, and what to pay attention to avoid it. In Unit 8 , you were introduced to writing code that follows one of two possible execution paths using the if - else statements, using a logical expression to decide which path to take. Sometimes, we want to execute one of the branches repeatedly (or iteratively), over-and-over again, until a certain logical condition is met. You have seen this construct in the \\(max\\) and \\(sum\\) example, where we repeatedly go through the numbers in the list until \\(i == k\\) . Writing Loops To write a loop, we need to think about the following four questions: what do we want to do repeatedly? what do we need to set up before repeating the above? what changes from one repetition to another? how to decide if we should stop repeating (or conversely, to continue repeating?) There is a fifth question that is as important as the above but is harder to answer (and not necessary for writing simple loops), so we will leave it to Unit 12 . Let's revisit the example of max . Here is the answer to the four questions: What do we want to do repeatedly? We want to compare the element \\(l_i\\) to \\(m\\) , and update \\(m\\) to \\(l_i\\) if \\(l_i > m\\) . What do we need to set up before repeating the above? We need to have some initial value of \\(m\\) and \\(i\\) . We set it up as \\(m = l_0\\) and \\(i = 1\\) . What would be different each time we repeat the above? Every time we repeat, \\(i\\) will be different. To be more precise, \\(i\\) is one more than before. How to decide if we should continue repeating the above? We stop when there is no more element to compare, i.e., \\(i\\) equals \\(k\\) . In other words, we continue if \\(i < k\\) . Let's consider another example. We have seen how to compute factorial recursively. Let's try to compute factorial using a loop. Recall that \\(n! = n \\times n-1 \\times n-2 .. 2 \\times 1\\) . Given \\(n\\) , how do we find \\(n!\\) using a loop? The idea to solve this with a loop is to start with the value \\(n\\) , and repeatedly multiply another value \\(i\\) , starting with \\(i = n - 1\\) , then \\(i = n - 2\\) , etc, until \\(i = 2\\) . We do not need to multiple with \\(i = 1\\) since it does not change the value. Like any other problem, we need to consider what are the variables we need to maintain. In this case, we should maintain the partial product of the factorial and a variable \\(i\\) that corresponds to value to multiple into the partial product. What do we want to do repeatedly? Multiply \\(i\\) into the partial product. What do we need to set up before repeating the above? We set up the partial product to be \\(n\\) and \\(i\\) to be \\(n - 1\\) . What changes from one repetition to another? \\(i\\) would decrease by one every time we repeat the above. How to decide if we should stop repeating (or conversely, to continue repeating?) We can stop when we have multiplied \\(i = 2\\) to the partial product. We can express the algorithm above using the following flowchart: A for loop Now that we have seen the four essential elements of a for loop, let's write some loops in C. C provides three ways to write a loop. Let's start with a simple one: the for loop. The for loop in C has the following syntax: 1 2 3 for ( < initialize > ; < condition > ; < update > ) { < body > } There are four components, corresponding to the four questions above: The initialize statement sets up the loop (i.e., \"What do we need to set up before repeating the above?\"). The condition statement indicates when we should stop repeating. If it evaluates to true , it will cause the loop to continue, otherwise, the loop stops. The update statement is executed after every loop. (i.e., \"What changes from one repetition to another?\") The body statement is the action that we want to do repeatedly. For the initialize and update statement, even though C allows us to include multiple initializations and multiple updates, it makes the code harder to read and understand. C also allows us to have empty statements for initialize , condition and/or update . As such, in CS1010, we will stick to performing one initialization and one update only. For example, in the setup phase for factorial, we should initialize the partial product to \\(n\\) and \\(i\\) to \\(n - 1\\) , that's two assignments. We commonly choose the index which we increment or decrement as we loop, hence we choose to initialize \\(i\\) in the initialize statement of the for loop, and leave the initialization of product to a separate assignment before the for loop. Here is an example on computing the factorial with a for loop: 1 2 3 4 5 6 7 8 long factorial ( long n ) { long product = n ; for ( long i = n - 1 ; i >= 2 ; i -= 1 ) { product *= i ; } return product ; } The code above is almost correct. We only need to handle the special case when n is 0. The complete code for the function is thus: 1 2 3 4 5 6 7 8 9 10 11 long factorial ( long n ) { if ( n == 0 ) { return 1 ; } long product = n ; for ( long i = n -1 ; i >= 2 ; i -= 1 ) { product *= i ; } return product ; } while Loop The second way to write a loop in C is to use a while loop. The while loop looks like this: 1 2 3 while ( < condition > ) { < body > } The statements in <body> will be executed if <condition> is true. Note that the syntax of the while loop above does not contain the <initialize> and the <update> component. When we write the loop, however, we still need to think about them, and add them to the appropriate place in the code, as follows: 1 2 3 4 5 < initialize > while ( < condition > ) { < body > < update > } The corresponding flowchart for while is: Compare the flowchart for while to the flowchart for for earlier. You will see that they are the same! Here is the while version of the factorial function: 1 2 3 4 5 6 7 8 9 10 11 12 13 long factorial ( long n ) { if ( n == 0 ) { return 1 ; } long product = n ; long i = n - 1 ; while ( i >= 2 ) { product *= i ; i -= 1 ; } return product ; } In the while loop, however, we can be more flexible in terms of what we want to do inside the loop. Technically, there is no difference between update and body since they are just a bunch of C statements. We can interleave <update> and <body> or execute <update> first before <body> , depending on the algorithm. With for loop, there is no such flexibility as <update> has to be executed after <body> . A do-while loop The third way we can write a loop in C is to use a do-while loop. The do-while loop is very similar to while , except that the body of the loop is guaranteed to be executed at least once. 1 2 3 4 5 < initialize > do { < body > < update > } while ( < condition > ); Similar to the while loop, the <body> component and <update> component in the loop do not have to be in order. There is a semicolon ; after a do-while loop. Let's look at an example where using do-while is more natural than while . Example: Guess a Number Let's write a program that plays a game with the user. The program generates a random integer number between 1 and 100. The user will guess what that number is. If the user guesses correctly, the program congratulates the user. Otherwise, the program tells the user whether the guess is too high or too low, and let the user guess again. This process repeats until the guess is correct. Note that, here, the user needs to guess at least once, so it is more natural to use a do - while loop than a while or a for . Answering The Four Questions What do we want to do repeatedly? We want to read the guess from the user and respond to the user. What do we need to set up before repeating the above? We need to generate a random integer between 1 and 100. What changes from one repetition to another? The guess may be different. How to decide if we should continue repeating the above? We stop when the guess is correct. Designing the Flowchart Here is the flowchart of the steps described above. The C code The entire corresponding program is shown below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <stdlib.h> #include <sys/times.h> #include \"cs1010.h\" int main () { // Initialize the random number generator srandom ( times ( 0 )); // Generate a random number between 1 and 100 long answer = ( random () % 100 ) + 1 ; long guess ; do { // Read guess and feedback to user guess = cs1010_read_long (); if ( guess > answer ) { cs1010_println_string ( \"too high\" ); } else if ( guess < answer ) { cs1010_println_string ( \"too low\" ); } } while ( guess != answer ); // { guess == answer } cs1010_println_string ( \"you got it. congrats!\" ); } I will not go into details of what srandom(times(0)) means. You can look it up on your own if you are interested (InfoSec students may want to do this as generating a good random number is key to keeping systems secure). The function random() generates a random integer, which we limit to 0 to 99 by modulo-ing it with 100. We then add 1 to it to a number between 1 and 100, inclusive. Infinite Loop One of the common bugs that programmers encounter when writing loops is the infinite loop . An infinite loop is a loop that never terminates until an external input (++control-c++) terminates the program. Consider the slight variation of the factorial function below: 1 2 3 4 5 6 7 8 9 10 11 12 13 long factorial ( long n ) { if ( n == 0 ) { return 1 ; } long product = n ; long i = n - 1 ; while ( i != 2 ) { product *= i ; i -= 1 ; } return product ; } What is the return value of factorial(-2) ? Take a moment to trace through the code. The answer is that factorial(-2) will never return! Since i is initialized to -3 on Line 7, and i only get smaller every time Line 10 is called. So, the terminating condition i != 2 will never be true. As a result, the loop never terminates. Let's examine under what condition would a loop continue forever, using three of the loop components: <initialize> , <update> , and <condition> . Consider the variable(s) used in <condition> and the condition in which <condition> evaluates to false . This is the terminal state of the loop. Now consider how these variables are set up in <initialize> . This is the initial state . For the loop to terminate, the sequence of operations performed by the <update> component must transit these variables from the initial state to the terminal state. Otherwise, the loop will never terminate. As an example, let's consider what happens when we call factorial(10) . The terminal state is { i == 2 } . The initial state is { i == 9 } . The update is performed by subtracting 1 from i in every loop. So the value of i starts at 9, and it becomes 8, 7, 6, .. and eventually the condition i == 2 will be true, i != 2 will be false, and the loop terminates. As an example, let's consider what happens when we call factorial(-2) . The terminal state is { i == 2 } . The initial state is { i == -3 } . The update is performed by subtracting 1 from i in every loop. So the value of i starts at -3, and it becomes -4, -5, -6, ... The <update> condition is moving the state away from the terminal state. So this loop never terminates! 1 To prevent the infinite loop bug, when developing your <initialize> , <update> , and <condition> , make sure that <update> always nudges the state from the initial state stated in <initialize> to the terminating condition specified by <condition> at each iteration and the terminal state is achievable eventually. Now, consider the version of factorial where the terminating condition is { i < 2 } . 1 2 3 4 5 6 7 8 9 10 11 12 13 long factorial ( long n ) { if ( n == 0 ) { return 1 ; } long product = n ; long i = n - 1 ; while ( i >= 2 ) { product *= i ; i -= 1 ; } return product ; } This version does not have the possibility of an infinite loop. Regardless of the initial state (i.e., regardless of what the value of i is initialized to), we will always reach the terminal state. Problem Set Problem 11.1 Here is another version of the factorial function: 1 2 3 4 5 6 7 8 9 10 long factorial ( long n ) { long i = n - 1 ; long product ; for ( product = n ; i >= 2 ; product *= i ) { i -= 1 ; } return product ; } Does this code run correctly? If it is incorrect, explain what is wrong and suggest a fix. (Hint: translate this to the corresponding flowchart and trace through the flowchart). Problem 11.2 (a) Rewrite the \"Guess A Number\" program so that it shows the user the number of guesses made before the correct guess is entered. (b) Rewrite the \"Guess A Number\" program with a while loop. (c) Extend the \"Guess A Number\" program so that it plays the game for five rounds with the user, and at the end, shows the user the average number of guesses over five rounds. (Hint: you should put the loop that reads the guess and prints feedback to the user into another function.) (d) What is the optimal strategy to play the game? Problem 11.3 Trace the following algorithms: 1 2 3 4 5 6 7 8 9 long mystery ( long n , long k ) { long something = n ; long count = -1 ; while ( something >= 1 ) { something /= k ; count += 1 ; } return count ; } (a) What is the return value when n is 8 and k is 2? n is 81 and k is 3? n is 100 and k is 5? Answer these questions by reading the code first, instead of trying it out on a computer (you can verify later). (b) What is the mathematical expression that our mystery function here is trying to compute based on the examples above? (c) Give a pair of inputs that would cause the function to return the wrong answer. (d) Give a pair of inputs that would cause the function to loop forever. Since a long variable can only store a limited range of values, eventually i will overflow and become positive again and reach the value 2. So the loop will still terminate, albeit after a long time (no pun intended) if we consider overflow. For CS1010, we still consider such a loop as an infinite loop. \u21a9","title":"11. Loops"},{"location":"11-loop.html#unit-11-loops","text":"","title":"Unit 11: Loops"},{"location":"11-loop.html#learning-objectives","text":"After this unit, students should: be able to identify the four components of a loop: initialization, body, update, and condition be able to express a computational solution as a loop with the four components above be able to implement a loop using either the for , while or do-while construct in C be able to trace through the control flows of each loop construct understand the correspondence between the different loop constructs be aware of the \"infinite loops\" bug, what causes it, and what to pay attention to avoid it. In Unit 8 , you were introduced to writing code that follows one of two possible execution paths using the if - else statements, using a logical expression to decide which path to take. Sometimes, we want to execute one of the branches repeatedly (or iteratively), over-and-over again, until a certain logical condition is met. You have seen this construct in the \\(max\\) and \\(sum\\) example, where we repeatedly go through the numbers in the list until \\(i == k\\) .","title":"Learning Objectives"},{"location":"11-loop.html#writing-loops","text":"To write a loop, we need to think about the following four questions: what do we want to do repeatedly? what do we need to set up before repeating the above? what changes from one repetition to another? how to decide if we should stop repeating (or conversely, to continue repeating?) There is a fifth question that is as important as the above but is harder to answer (and not necessary for writing simple loops), so we will leave it to Unit 12 . Let's revisit the example of max . Here is the answer to the four questions: What do we want to do repeatedly? We want to compare the element \\(l_i\\) to \\(m\\) , and update \\(m\\) to \\(l_i\\) if \\(l_i > m\\) . What do we need to set up before repeating the above? We need to have some initial value of \\(m\\) and \\(i\\) . We set it up as \\(m = l_0\\) and \\(i = 1\\) . What would be different each time we repeat the above? Every time we repeat, \\(i\\) will be different. To be more precise, \\(i\\) is one more than before. How to decide if we should continue repeating the above? We stop when there is no more element to compare, i.e., \\(i\\) equals \\(k\\) . In other words, we continue if \\(i < k\\) . Let's consider another example. We have seen how to compute factorial recursively. Let's try to compute factorial using a loop. Recall that \\(n! = n \\times n-1 \\times n-2 .. 2 \\times 1\\) . Given \\(n\\) , how do we find \\(n!\\) using a loop? The idea to solve this with a loop is to start with the value \\(n\\) , and repeatedly multiply another value \\(i\\) , starting with \\(i = n - 1\\) , then \\(i = n - 2\\) , etc, until \\(i = 2\\) . We do not need to multiple with \\(i = 1\\) since it does not change the value. Like any other problem, we need to consider what are the variables we need to maintain. In this case, we should maintain the partial product of the factorial and a variable \\(i\\) that corresponds to value to multiple into the partial product. What do we want to do repeatedly? Multiply \\(i\\) into the partial product. What do we need to set up before repeating the above? We set up the partial product to be \\(n\\) and \\(i\\) to be \\(n - 1\\) . What changes from one repetition to another? \\(i\\) would decrease by one every time we repeat the above. How to decide if we should stop repeating (or conversely, to continue repeating?) We can stop when we have multiplied \\(i = 2\\) to the partial product. We can express the algorithm above using the following flowchart:","title":"Writing Loops"},{"location":"11-loop.html#a-for-loop","text":"Now that we have seen the four essential elements of a for loop, let's write some loops in C. C provides three ways to write a loop. Let's start with a simple one: the for loop. The for loop in C has the following syntax: 1 2 3 for ( < initialize > ; < condition > ; < update > ) { < body > } There are four components, corresponding to the four questions above: The initialize statement sets up the loop (i.e., \"What do we need to set up before repeating the above?\"). The condition statement indicates when we should stop repeating. If it evaluates to true , it will cause the loop to continue, otherwise, the loop stops. The update statement is executed after every loop. (i.e., \"What changes from one repetition to another?\") The body statement is the action that we want to do repeatedly. For the initialize and update statement, even though C allows us to include multiple initializations and multiple updates, it makes the code harder to read and understand. C also allows us to have empty statements for initialize , condition and/or update . As such, in CS1010, we will stick to performing one initialization and one update only. For example, in the setup phase for factorial, we should initialize the partial product to \\(n\\) and \\(i\\) to \\(n - 1\\) , that's two assignments. We commonly choose the index which we increment or decrement as we loop, hence we choose to initialize \\(i\\) in the initialize statement of the for loop, and leave the initialization of product to a separate assignment before the for loop. Here is an example on computing the factorial with a for loop: 1 2 3 4 5 6 7 8 long factorial ( long n ) { long product = n ; for ( long i = n - 1 ; i >= 2 ; i -= 1 ) { product *= i ; } return product ; } The code above is almost correct. We only need to handle the special case when n is 0. The complete code for the function is thus: 1 2 3 4 5 6 7 8 9 10 11 long factorial ( long n ) { if ( n == 0 ) { return 1 ; } long product = n ; for ( long i = n -1 ; i >= 2 ; i -= 1 ) { product *= i ; } return product ; }","title":"A for loop"},{"location":"11-loop.html#while-loop","text":"The second way to write a loop in C is to use a while loop. The while loop looks like this: 1 2 3 while ( < condition > ) { < body > } The statements in <body> will be executed if <condition> is true. Note that the syntax of the while loop above does not contain the <initialize> and the <update> component. When we write the loop, however, we still need to think about them, and add them to the appropriate place in the code, as follows: 1 2 3 4 5 < initialize > while ( < condition > ) { < body > < update > } The corresponding flowchart for while is: Compare the flowchart for while to the flowchart for for earlier. You will see that they are the same! Here is the while version of the factorial function: 1 2 3 4 5 6 7 8 9 10 11 12 13 long factorial ( long n ) { if ( n == 0 ) { return 1 ; } long product = n ; long i = n - 1 ; while ( i >= 2 ) { product *= i ; i -= 1 ; } return product ; } In the while loop, however, we can be more flexible in terms of what we want to do inside the loop. Technically, there is no difference between update and body since they are just a bunch of C statements. We can interleave <update> and <body> or execute <update> first before <body> , depending on the algorithm. With for loop, there is no such flexibility as <update> has to be executed after <body> .","title":"while Loop"},{"location":"11-loop.html#a-do-while-loop","text":"The third way we can write a loop in C is to use a do-while loop. The do-while loop is very similar to while , except that the body of the loop is guaranteed to be executed at least once. 1 2 3 4 5 < initialize > do { < body > < update > } while ( < condition > ); Similar to the while loop, the <body> component and <update> component in the loop do not have to be in order. There is a semicolon ; after a do-while loop. Let's look at an example where using do-while is more natural than while .","title":"A do-while loop"},{"location":"11-loop.html#example-guess-a-number","text":"Let's write a program that plays a game with the user. The program generates a random integer number between 1 and 100. The user will guess what that number is. If the user guesses correctly, the program congratulates the user. Otherwise, the program tells the user whether the guess is too high or too low, and let the user guess again. This process repeats until the guess is correct. Note that, here, the user needs to guess at least once, so it is more natural to use a do - while loop than a while or a for .","title":"Example: Guess a Number"},{"location":"11-loop.html#answering-the-four-questions","text":"What do we want to do repeatedly? We want to read the guess from the user and respond to the user. What do we need to set up before repeating the above? We need to generate a random integer between 1 and 100. What changes from one repetition to another? The guess may be different. How to decide if we should continue repeating the above? We stop when the guess is correct.","title":"Answering The Four Questions"},{"location":"11-loop.html#designing-the-flowchart","text":"Here is the flowchart of the steps described above.","title":"Designing the Flowchart"},{"location":"11-loop.html#the-c-code","text":"The entire corresponding program is shown below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <stdlib.h> #include <sys/times.h> #include \"cs1010.h\" int main () { // Initialize the random number generator srandom ( times ( 0 )); // Generate a random number between 1 and 100 long answer = ( random () % 100 ) + 1 ; long guess ; do { // Read guess and feedback to user guess = cs1010_read_long (); if ( guess > answer ) { cs1010_println_string ( \"too high\" ); } else if ( guess < answer ) { cs1010_println_string ( \"too low\" ); } } while ( guess != answer ); // { guess == answer } cs1010_println_string ( \"you got it. congrats!\" ); } I will not go into details of what srandom(times(0)) means. You can look it up on your own if you are interested (InfoSec students may want to do this as generating a good random number is key to keeping systems secure). The function random() generates a random integer, which we limit to 0 to 99 by modulo-ing it with 100. We then add 1 to it to a number between 1 and 100, inclusive.","title":"The C code"},{"location":"11-loop.html#infinite-loop","text":"One of the common bugs that programmers encounter when writing loops is the infinite loop . An infinite loop is a loop that never terminates until an external input (++control-c++) terminates the program. Consider the slight variation of the factorial function below: 1 2 3 4 5 6 7 8 9 10 11 12 13 long factorial ( long n ) { if ( n == 0 ) { return 1 ; } long product = n ; long i = n - 1 ; while ( i != 2 ) { product *= i ; i -= 1 ; } return product ; } What is the return value of factorial(-2) ? Take a moment to trace through the code. The answer is that factorial(-2) will never return! Since i is initialized to -3 on Line 7, and i only get smaller every time Line 10 is called. So, the terminating condition i != 2 will never be true. As a result, the loop never terminates. Let's examine under what condition would a loop continue forever, using three of the loop components: <initialize> , <update> , and <condition> . Consider the variable(s) used in <condition> and the condition in which <condition> evaluates to false . This is the terminal state of the loop. Now consider how these variables are set up in <initialize> . This is the initial state . For the loop to terminate, the sequence of operations performed by the <update> component must transit these variables from the initial state to the terminal state. Otherwise, the loop will never terminate. As an example, let's consider what happens when we call factorial(10) . The terminal state is { i == 2 } . The initial state is { i == 9 } . The update is performed by subtracting 1 from i in every loop. So the value of i starts at 9, and it becomes 8, 7, 6, .. and eventually the condition i == 2 will be true, i != 2 will be false, and the loop terminates. As an example, let's consider what happens when we call factorial(-2) . The terminal state is { i == 2 } . The initial state is { i == -3 } . The update is performed by subtracting 1 from i in every loop. So the value of i starts at -3, and it becomes -4, -5, -6, ... The <update> condition is moving the state away from the terminal state. So this loop never terminates! 1 To prevent the infinite loop bug, when developing your <initialize> , <update> , and <condition> , make sure that <update> always nudges the state from the initial state stated in <initialize> to the terminating condition specified by <condition> at each iteration and the terminal state is achievable eventually. Now, consider the version of factorial where the terminating condition is { i < 2 } . 1 2 3 4 5 6 7 8 9 10 11 12 13 long factorial ( long n ) { if ( n == 0 ) { return 1 ; } long product = n ; long i = n - 1 ; while ( i >= 2 ) { product *= i ; i -= 1 ; } return product ; } This version does not have the possibility of an infinite loop. Regardless of the initial state (i.e., regardless of what the value of i is initialized to), we will always reach the terminal state.","title":"Infinite Loop"},{"location":"11-loop.html#problem-set","text":"","title":"Problem Set"},{"location":"11-loop.html#problem-111","text":"Here is another version of the factorial function: 1 2 3 4 5 6 7 8 9 10 long factorial ( long n ) { long i = n - 1 ; long product ; for ( product = n ; i >= 2 ; product *= i ) { i -= 1 ; } return product ; } Does this code run correctly? If it is incorrect, explain what is wrong and suggest a fix. (Hint: translate this to the corresponding flowchart and trace through the flowchart).","title":"Problem 11.1"},{"location":"11-loop.html#problem-112","text":"(a) Rewrite the \"Guess A Number\" program so that it shows the user the number of guesses made before the correct guess is entered. (b) Rewrite the \"Guess A Number\" program with a while loop. (c) Extend the \"Guess A Number\" program so that it plays the game for five rounds with the user, and at the end, shows the user the average number of guesses over five rounds. (Hint: you should put the loop that reads the guess and prints feedback to the user into another function.) (d) What is the optimal strategy to play the game?","title":"Problem 11.2"},{"location":"11-loop.html#problem-113","text":"Trace the following algorithms: 1 2 3 4 5 6 7 8 9 long mystery ( long n , long k ) { long something = n ; long count = -1 ; while ( something >= 1 ) { something /= k ; count += 1 ; } return count ; } (a) What is the return value when n is 8 and k is 2? n is 81 and k is 3? n is 100 and k is 5? Answer these questions by reading the code first, instead of trying it out on a computer (you can verify later). (b) What is the mathematical expression that our mystery function here is trying to compute based on the examples above? (c) Give a pair of inputs that would cause the function to return the wrong answer. (d) Give a pair of inputs that would cause the function to loop forever. Since a long variable can only store a limited range of values, eventually i will overflow and become positive again and reach the value 2. So the loop will still terminate, albeit after a long time (no pun intended) if we consider overflow. For CS1010, we still consider such a loop as an infinite loop. \u21a9","title":"Problem 11.3"},{"location":"12-invariant.html","text":"Unit 12: Reasoning About Loops Learning Objectives After this unit, students should: understand how assertions can be derived in a loop; understand how assertions can help us understand the behavior of a loop; understand what is a loop invariant; be able to argue why a given loop invariant is true; be able to derive simple loop invariant of a given loop. Using Assertions We have seen how we can use assertions to reason about the state of our program at different points of execution for conditional if - else statements. We can apply the same techniques to loops. Take the simple program below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 long count ( long n ) { long y = 0 ; long x = n ; while ( x > 0 ) { // Line A x -= 1 ; // Line B if ( x % 5 == 0 ) { // Line C y += 1 ; } } // Line D return y ; } Before we continue, study this program and try to analyze what the function is counting and returning. To do this more systematically, we can use assertions. Let's ask ourselves: what can be said about the variables x and y at Lines A, B, C? Let start with x first. Line A is the first line after entering the loop, so we can reason that, to enter the loop (the first time or subsequent times), x > 0 must be true. We can also derive that, at Line A, x <= n . This is less obvious: since we initialize the x to n , and after Line A, we only decrease x , x can never be more than n . At Line B, we decrease x by 1, so now x >= 0 && x < n must be true. At Line C, x % 5 == 0 (i.e., x is multiple of 5) must also be true (since it is in the true block of the if block). At Line D, we already exit from the loop, and the only way to exit here is that x > 0 is false. So we know that x <= 0 . Let's annotate the code with the assertions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 long count ( long n ) { long y = 0 ; long x = n ; while ( x > 0 ) { // { (x > 0) && (x <= n) } x -= 1 ; // { (x >= 0) && (x < n) } if ( x % 5 == 0 ) { // { (x >= 0) && (x < n) && x is multiple of 5 } y += 1 ; } } // { x <= 0 } return y ; } What can be said about y ? It should be clear now that we increment y for every value between 0 and n-1 (inclusive) that is a multiple of 5, based on the condition on Line C. That is, it is counting the number of multiple of 5s between 0 and n-1. Loop Invariant In the last unit, we say that there are five questions that we have to think about when designing loops. But we only talked about four at that time. The fifth question is: what is the loop invariant ? A loop invariant is an assertion that is true before the loop, after each iteration of the loop, and after the loop. Thinking about the loop invariant is helpful to convince ourselves that a loop is correct, or to identify bugs in a loop. Let's see an example of a loop invariant. Consider the example of calculating a factorial using a loop as before. To make the invariant simpler, let's tweak the loop slightly and start looping from i equals 1 up to n . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 long factorial ( long n ) { if ( n == 0 ) { return 1 ; } long product = 1 ; long i = 1 ; // Line A: before the loop while ( i < n ) { // Line B: beginning of each iteration i += 1 ; // Line C product *= i ; // Line D: after each iteration } // Line E: after the loop return product ; } Line A is where we want to identify the assertion before the loop; Line D is where we want to identify the assertion after each iteration of the loop. Line E is where we want to identify the assertion after the loop. We added Lines B and C to help us reason about the assertions at Line D. For this function, the assertion at line A, D, and E are the same, they are all { product == i! } ! Thus, we say that this loop has the invariant { product == i! } . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 long factorial ( long n ) { if ( n == 0 ) { return 1 ; } long product = 1 ; long i = 1 ; // A: { product == i! } while ( i < n ) { // B: { product == i! } i += 1 ; // C: { product == (i-1)! } product *= i ; // D: { product == i! } } // E: { product == i! } return product ; } Let's see why the assertions labeled above hold. On Line A, the assertion is obvious. Since product is 1, i is 1, and 1! is 1. The assertion { product == i! } holds. Let's look at Line B. We need to argue that this assertion holds for every iteration. This is a bit more tricky. Let's first consider the first iteration and come back to the subsequent iterations later. In the first iteration, the values of product and i do not change from Line A to Line B, so the assertion still holds. On Line 11, we increment i . So, at Line C of the first iteration, we have { product == (i-1)! } . On Line 13, we update product by multiplying it with i . So, we have on Line D of the first iteration that { product == i! } again. Now, let's look at the second iteration. There is no change to the variables product and i , between Line D of the first iteration and Line B of the second iteration. So the assertion { product == i! } still holds. From this point onwards, we can apply the same argument over and over again, and see that the assertions on Lines B, C, and D hold for every iteration! After we exit the loop, we can also assert that i == n , and so combining product == i! && i == n we have product == n! , which is what we want. The loop therefore correctly computes n! . The approach above to argue that an invariant is true, can be generalized to the following steps. To argue that an invariant is true, we need to argue that: it is true before entering the loop. it is true at the end of the first iteration of the loop if it is true at the end of the \\(k\\) -th iteration of the loop, then it is true at the end of the \\((k+1)\\) -th iteration. it is true when we exit the loop. The way we argue that an invariant is true above is similar to a mathematical proof technique called proof by induction . Induction is taught in CS1231. We will not require you to give a formal proof of invariant in CS1010, however. When is an Invariant Useful As we have seen in the example above, invariant is a useful thinking and reasoning tool to help us convince ourselves that our loop behaves correctly (e.g., { product == n! } ). Loop invariant, however, is not unique. We can write down possibly infinitely many loop invariant that is true. A good invariant, however, is one that will lead us to an assertion that we want to see (e.g., relating product to n ). We can derive other invariants in our code (such as { n != 0 } below) that does not contribute to the resoning of the behavior of our loop. Such invariants should be avoided . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 long factorial ( long n ) { if ( n == 0 ) { return 1 ; } long product = 1 ; long i = 1 ; // { n != 0 } while ( i < n ) { i += 1 ; product *= i ; // { n != 0 } } // { n != 0 } return product ; } Problem Set 12 Problem 12.1 (a) Consider the algorithm to find the maximum among a list of integers \\(L\\) with at least one element ( \\(k > 0\\) ) below: The loop invariant for this loop must hold at the three points marked with the red dots: before the loop, after each iteration of the loop, and after the loop. State the loop invariant, explain why it holds at the three points above, and threfore argue that the loop above correctly finds the maximum among the elements of the list \\(L\\) . (b) Now, consider a slightly different algorithm to find the maximum among a list of integers \\(L\\) with at least one element ( \\(k > 0\\) ) below: Explain why you cannot find a loop invariant similar to Part (a) above, and therefore show that the algorithm does not correctly find the maximum in certain cases.","title":"12. Invariant"},{"location":"12-invariant.html#unit-12-reasoning-about-loops","text":"","title":"Unit 12: Reasoning About Loops"},{"location":"12-invariant.html#learning-objectives","text":"After this unit, students should: understand how assertions can be derived in a loop; understand how assertions can help us understand the behavior of a loop; understand what is a loop invariant; be able to argue why a given loop invariant is true; be able to derive simple loop invariant of a given loop.","title":"Learning Objectives"},{"location":"12-invariant.html#using-assertions","text":"We have seen how we can use assertions to reason about the state of our program at different points of execution for conditional if - else statements. We can apply the same techniques to loops. Take the simple program below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 long count ( long n ) { long y = 0 ; long x = n ; while ( x > 0 ) { // Line A x -= 1 ; // Line B if ( x % 5 == 0 ) { // Line C y += 1 ; } } // Line D return y ; } Before we continue, study this program and try to analyze what the function is counting and returning. To do this more systematically, we can use assertions. Let's ask ourselves: what can be said about the variables x and y at Lines A, B, C? Let start with x first. Line A is the first line after entering the loop, so we can reason that, to enter the loop (the first time or subsequent times), x > 0 must be true. We can also derive that, at Line A, x <= n . This is less obvious: since we initialize the x to n , and after Line A, we only decrease x , x can never be more than n . At Line B, we decrease x by 1, so now x >= 0 && x < n must be true. At Line C, x % 5 == 0 (i.e., x is multiple of 5) must also be true (since it is in the true block of the if block). At Line D, we already exit from the loop, and the only way to exit here is that x > 0 is false. So we know that x <= 0 . Let's annotate the code with the assertions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 long count ( long n ) { long y = 0 ; long x = n ; while ( x > 0 ) { // { (x > 0) && (x <= n) } x -= 1 ; // { (x >= 0) && (x < n) } if ( x % 5 == 0 ) { // { (x >= 0) && (x < n) && x is multiple of 5 } y += 1 ; } } // { x <= 0 } return y ; } What can be said about y ? It should be clear now that we increment y for every value between 0 and n-1 (inclusive) that is a multiple of 5, based on the condition on Line C. That is, it is counting the number of multiple of 5s between 0 and n-1.","title":"Using Assertions"},{"location":"12-invariant.html#loop-invariant","text":"In the last unit, we say that there are five questions that we have to think about when designing loops. But we only talked about four at that time. The fifth question is: what is the loop invariant ? A loop invariant is an assertion that is true before the loop, after each iteration of the loop, and after the loop. Thinking about the loop invariant is helpful to convince ourselves that a loop is correct, or to identify bugs in a loop. Let's see an example of a loop invariant. Consider the example of calculating a factorial using a loop as before. To make the invariant simpler, let's tweak the loop slightly and start looping from i equals 1 up to n . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 long factorial ( long n ) { if ( n == 0 ) { return 1 ; } long product = 1 ; long i = 1 ; // Line A: before the loop while ( i < n ) { // Line B: beginning of each iteration i += 1 ; // Line C product *= i ; // Line D: after each iteration } // Line E: after the loop return product ; } Line A is where we want to identify the assertion before the loop; Line D is where we want to identify the assertion after each iteration of the loop. Line E is where we want to identify the assertion after the loop. We added Lines B and C to help us reason about the assertions at Line D. For this function, the assertion at line A, D, and E are the same, they are all { product == i! } ! Thus, we say that this loop has the invariant { product == i! } . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 long factorial ( long n ) { if ( n == 0 ) { return 1 ; } long product = 1 ; long i = 1 ; // A: { product == i! } while ( i < n ) { // B: { product == i! } i += 1 ; // C: { product == (i-1)! } product *= i ; // D: { product == i! } } // E: { product == i! } return product ; } Let's see why the assertions labeled above hold. On Line A, the assertion is obvious. Since product is 1, i is 1, and 1! is 1. The assertion { product == i! } holds. Let's look at Line B. We need to argue that this assertion holds for every iteration. This is a bit more tricky. Let's first consider the first iteration and come back to the subsequent iterations later. In the first iteration, the values of product and i do not change from Line A to Line B, so the assertion still holds. On Line 11, we increment i . So, at Line C of the first iteration, we have { product == (i-1)! } . On Line 13, we update product by multiplying it with i . So, we have on Line D of the first iteration that { product == i! } again. Now, let's look at the second iteration. There is no change to the variables product and i , between Line D of the first iteration and Line B of the second iteration. So the assertion { product == i! } still holds. From this point onwards, we can apply the same argument over and over again, and see that the assertions on Lines B, C, and D hold for every iteration! After we exit the loop, we can also assert that i == n , and so combining product == i! && i == n we have product == n! , which is what we want. The loop therefore correctly computes n! . The approach above to argue that an invariant is true, can be generalized to the following steps. To argue that an invariant is true, we need to argue that: it is true before entering the loop. it is true at the end of the first iteration of the loop if it is true at the end of the \\(k\\) -th iteration of the loop, then it is true at the end of the \\((k+1)\\) -th iteration. it is true when we exit the loop. The way we argue that an invariant is true above is similar to a mathematical proof technique called proof by induction . Induction is taught in CS1231. We will not require you to give a formal proof of invariant in CS1010, however.","title":"Loop Invariant"},{"location":"12-invariant.html#when-is-an-invariant-useful","text":"As we have seen in the example above, invariant is a useful thinking and reasoning tool to help us convince ourselves that our loop behaves correctly (e.g., { product == n! } ). Loop invariant, however, is not unique. We can write down possibly infinitely many loop invariant that is true. A good invariant, however, is one that will lead us to an assertion that we want to see (e.g., relating product to n ). We can derive other invariants in our code (such as { n != 0 } below) that does not contribute to the resoning of the behavior of our loop. Such invariants should be avoided . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 long factorial ( long n ) { if ( n == 0 ) { return 1 ; } long product = 1 ; long i = 1 ; // { n != 0 } while ( i < n ) { i += 1 ; product *= i ; // { n != 0 } } // { n != 0 } return product ; }","title":"When is an Invariant Useful"},{"location":"12-invariant.html#problem-set-12","text":"","title":"Problem Set 12"},{"location":"12-invariant.html#problem-121","text":"(a) Consider the algorithm to find the maximum among a list of integers \\(L\\) with at least one element ( \\(k > 0\\) ) below: The loop invariant for this loop must hold at the three points marked with the red dots: before the loop, after each iteration of the loop, and after the loop. State the loop invariant, explain why it holds at the three points above, and threfore argue that the loop above correctly finds the maximum among the elements of the list \\(L\\) . (b) Now, consider a slightly different algorithm to find the maximum among a list of integers \\(L\\) with at least one element ( \\(k > 0\\) ) below: Explain why you cannot find a loop invariant similar to Part (a) above, and therefore show that the algorithm does not correctly find the maximum in certain cases.","title":"Problem 12.1"},{"location":"13-call-stack.html","text":"Unit 13: Call Stack In this unit, we will delve deeper into how variables are stored in the memory and what happens when we call a function. Learning Objectives After this unit, students should: understand the purpose of the call stack be aware that the stack frame represents the memory allocated to a particular function call be aware that the stack frame for a function is deallocated once the function terminates understand what occurs in a stack frame when a variable is declared understand what occurs in a stack frame when a variable is assigned understand how function parameters are handled within the stack frame be able to trace the contents of the call stack through nested function calls be aware that there are three different types of variables: automatic, global, and static be aware that the operating system limits the size of the call stack for each program Stack Frame Modern OS typically divides the memory into several regions. The region that we are concerned with for now is called the call stack . Every function invocation causes the OS to allocate some memory on the call stack to store (among other things) the parameters passed into the function and the variables declared and used in the function. The memory allocated to each function call is called a stack frame . When a function returns, the stack frame is deallocated and freed up for other uses. Let's start with the following simple program as an example. 1 2 3 4 5 int main () { long x = 1 ; long y ; } When the OS runs the program above, it invokes, or calls, the function main . A new stack frame is created for main() . There are two variables x and y declared in main . Recall from Unit 2 that a variable is a location in the memory which holds a value. Thus, the stack frame of the main will include these two variables. We initialize x to 1 in the code above, so the value 1 will be placed in the memory location of x . The variable y remains uninitialized, so it will contain whatever value that happens to be in the memory at that time. Now, let's consider the program 1 : 1 2 3 4 5 6 7 8 9 10 11 12 long add ( long a , long b ) { long sum ; sum = a + b ; return sum ; } int main () { long x = 1 ; long y ; y = add ( x , 10 ); } Now, the program invokes the function add with two parameters, using x and 10 as arguments. What the OS does when add is called, is that it allocates another stack frame for add . We can visualize the stack frame for add as being placed on top of the stack frame of main . The stack frame for add includes two variables corresponding to the parameters a , b , and the variable sum declared in the function add . When the stack frame for add is created, sum is uninitialized, but a is initialized to whatever the value of x is when the function is invoked (1 in this example), and b is initialized to 10, since that is the argument passed into add . After the stack frame for add is set up, the code is executed. The memory location for sum is then initialized to the sum of a and b (11 in this example), and the return statement is executed. When a function returns, the stack frame for sum is removed. The variables sum , a , b crumble into dust and no longer exist in the memory. The value of the variable being returned ( sum in this case) is then copied back to the stack frame of the main (the caller). In this example, this value is copied into the memory location of y . What would happen if we change the value of a within add ? 1 2 3 4 5 6 7 8 9 10 11 12 long add ( long a , long b ) { sum = a + b ; a = 42 ; // change a return sum ; } int main () { long x = 1 ; long y ; y = add ( x , 10 ); } In this example, we change the value of a in the call stack of add to 42. This does not affect any variable in main , since the changes apply only within the stack frame of add . A common bug by beginners is to try to write a function this way: 1 2 3 4 5 6 7 8 9 10 void add ( long sum , long a , long b ) { sum = a + b ; } int main () { long x = 1 ; long sum ; add ( sum , x , 10 ); } Here, there are two versions of sum , one in the stack frame of main , the other in the stack frame of add . When we change sum in add , we are changing a local copy which will eventually get deleted. The assignment to sum in Line 2 does not affect the variable sum on Line 8 of main . This explanation explains why a function is a black box, we can only pass in parameters and get a value in return. Nothing else gets in and out. There are no \"side effects\" -- whatever happens in the function, stays in the function and does not affect the caller (excepts if it reads or writes to the standard input/output). Such a function is sometimes called a \"pure function\". Pure functions simplies the reasoning about our code. For instance, in the code snippet below, we can still be sure that, x is 1 and sum is 0, after invoking the function add , without knowing what is happening inside. 1 2 3 4 5 long x = 1 ; long sum = 0 ; add ( sum , x , 10 ); // { x == 1 } // { sum == 0 } There is a paradigm of programming called functional programming where one of its tenets is that a program should consist of only pure functions. Functional programming languages such as Haskell and F# provides language support for functional programming. C, however, does not enforce such functional paradigm -- it is up to us programers to enforce it. As we will see very soon, some of the core features of C actually introduce impureness into functions. Automatic Variable Because of the way the memory for the variables are automatically allocated and deallocated when a function is invoked and when the function returns, we call these variables automatic variables or auto variable for short. There are two other types of variables, global variable , which we have mentioned is a very very bad programming practice in Lecture 5 and is banned from CS1010, and static variable , which could be useful in rare occasions but it is again a bug-prone feature of C and so using static variable in CS1010 is not allowed. Stack Size The OS typically reserves a limited amount of memory for each program for the stack. You can find out, on your system, what is the maximum allocated stack size with the command 1 ulimit -s On our CS1010 PE hosts, the limit is 8 MB. Problem Set 13 Problem 13.1 Trace through what gets stored in the call stack when we run the following programs: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <math.h> long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { hypotenuse_of ( 3 , 4 ); } Problem 13.2 Trace through what gets stored in the call stack when we run the following programs: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \"cs1010.h\" long factorial ( long n ) { if ( n == 0 ) { return 1 ; } return factorial ( n -1 ) * n ; } int main () { factorial ( 3 ); } Problem 13.3 What will be printed by the program below? Trace through what gets stored in the call stack when we run the following programs: 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \"cs1010.h\" void incr ( long x ) { x += 1 ; } int main () { long x = 10 ; incr ( x ); incr ( x ); cs1010_print_long ( x ); } The variable sum is not necessary and the function can be better written as a one-liner return a + b; . But I introduce the additional variable sum here to make the example more meaningful in explaining about stack frame. \u21a9","title":"13. Stack"},{"location":"13-call-stack.html#unit-13-call-stack","text":"In this unit, we will delve deeper into how variables are stored in the memory and what happens when we call a function.","title":"Unit 13: Call Stack"},{"location":"13-call-stack.html#learning-objectives","text":"After this unit, students should: understand the purpose of the call stack be aware that the stack frame represents the memory allocated to a particular function call be aware that the stack frame for a function is deallocated once the function terminates understand what occurs in a stack frame when a variable is declared understand what occurs in a stack frame when a variable is assigned understand how function parameters are handled within the stack frame be able to trace the contents of the call stack through nested function calls be aware that there are three different types of variables: automatic, global, and static be aware that the operating system limits the size of the call stack for each program","title":"Learning Objectives"},{"location":"13-call-stack.html#stack-frame","text":"Modern OS typically divides the memory into several regions. The region that we are concerned with for now is called the call stack . Every function invocation causes the OS to allocate some memory on the call stack to store (among other things) the parameters passed into the function and the variables declared and used in the function. The memory allocated to each function call is called a stack frame . When a function returns, the stack frame is deallocated and freed up for other uses. Let's start with the following simple program as an example. 1 2 3 4 5 int main () { long x = 1 ; long y ; } When the OS runs the program above, it invokes, or calls, the function main . A new stack frame is created for main() . There are two variables x and y declared in main . Recall from Unit 2 that a variable is a location in the memory which holds a value. Thus, the stack frame of the main will include these two variables. We initialize x to 1 in the code above, so the value 1 will be placed in the memory location of x . The variable y remains uninitialized, so it will contain whatever value that happens to be in the memory at that time. Now, let's consider the program 1 : 1 2 3 4 5 6 7 8 9 10 11 12 long add ( long a , long b ) { long sum ; sum = a + b ; return sum ; } int main () { long x = 1 ; long y ; y = add ( x , 10 ); } Now, the program invokes the function add with two parameters, using x and 10 as arguments. What the OS does when add is called, is that it allocates another stack frame for add . We can visualize the stack frame for add as being placed on top of the stack frame of main . The stack frame for add includes two variables corresponding to the parameters a , b , and the variable sum declared in the function add . When the stack frame for add is created, sum is uninitialized, but a is initialized to whatever the value of x is when the function is invoked (1 in this example), and b is initialized to 10, since that is the argument passed into add . After the stack frame for add is set up, the code is executed. The memory location for sum is then initialized to the sum of a and b (11 in this example), and the return statement is executed. When a function returns, the stack frame for sum is removed. The variables sum , a , b crumble into dust and no longer exist in the memory. The value of the variable being returned ( sum in this case) is then copied back to the stack frame of the main (the caller). In this example, this value is copied into the memory location of y . What would happen if we change the value of a within add ? 1 2 3 4 5 6 7 8 9 10 11 12 long add ( long a , long b ) { sum = a + b ; a = 42 ; // change a return sum ; } int main () { long x = 1 ; long y ; y = add ( x , 10 ); } In this example, we change the value of a in the call stack of add to 42. This does not affect any variable in main , since the changes apply only within the stack frame of add . A common bug by beginners is to try to write a function this way: 1 2 3 4 5 6 7 8 9 10 void add ( long sum , long a , long b ) { sum = a + b ; } int main () { long x = 1 ; long sum ; add ( sum , x , 10 ); } Here, there are two versions of sum , one in the stack frame of main , the other in the stack frame of add . When we change sum in add , we are changing a local copy which will eventually get deleted. The assignment to sum in Line 2 does not affect the variable sum on Line 8 of main . This explanation explains why a function is a black box, we can only pass in parameters and get a value in return. Nothing else gets in and out. There are no \"side effects\" -- whatever happens in the function, stays in the function and does not affect the caller (excepts if it reads or writes to the standard input/output). Such a function is sometimes called a \"pure function\". Pure functions simplies the reasoning about our code. For instance, in the code snippet below, we can still be sure that, x is 1 and sum is 0, after invoking the function add , without knowing what is happening inside. 1 2 3 4 5 long x = 1 ; long sum = 0 ; add ( sum , x , 10 ); // { x == 1 } // { sum == 0 } There is a paradigm of programming called functional programming where one of its tenets is that a program should consist of only pure functions. Functional programming languages such as Haskell and F# provides language support for functional programming. C, however, does not enforce such functional paradigm -- it is up to us programers to enforce it. As we will see very soon, some of the core features of C actually introduce impureness into functions.","title":"Stack Frame"},{"location":"13-call-stack.html#automatic-variable","text":"Because of the way the memory for the variables are automatically allocated and deallocated when a function is invoked and when the function returns, we call these variables automatic variables or auto variable for short. There are two other types of variables, global variable , which we have mentioned is a very very bad programming practice in Lecture 5 and is banned from CS1010, and static variable , which could be useful in rare occasions but it is again a bug-prone feature of C and so using static variable in CS1010 is not allowed.","title":"Automatic Variable"},{"location":"13-call-stack.html#stack-size","text":"The OS typically reserves a limited amount of memory for each program for the stack. You can find out, on your system, what is the maximum allocated stack size with the command 1 ulimit -s On our CS1010 PE hosts, the limit is 8 MB.","title":"Stack Size"},{"location":"13-call-stack.html#problem-set-13","text":"","title":"Problem Set 13"},{"location":"13-call-stack.html#problem-131","text":"Trace through what gets stored in the call stack when we run the following programs: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <math.h> long square ( long x ) { return x * x ; } double hypotenuse_of ( long base , long height ) { return sqrt ( square ( base ) + square ( height )); } int main () { hypotenuse_of ( 3 , 4 ); }","title":"Problem 13.1"},{"location":"13-call-stack.html#problem-132","text":"Trace through what gets stored in the call stack when we run the following programs: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \"cs1010.h\" long factorial ( long n ) { if ( n == 0 ) { return 1 ; } return factorial ( n -1 ) * n ; } int main () { factorial ( 3 ); }","title":"Problem 13.2"},{"location":"13-call-stack.html#problem-133","text":"What will be printed by the program below? Trace through what gets stored in the call stack when we run the following programs: 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \"cs1010.h\" void incr ( long x ) { x += 1 ; } int main () { long x = 10 ; incr ( x ); incr ( x ); cs1010_print_long ( x ); } The variable sum is not necessary and the function can be better written as a one-liner return a + b; . But I introduce the additional variable sum here to make the example more meaningful in explaining about stack frame. \u21a9","title":"Problem 13.3"},{"location":"14-array.html","text":"Unit 14: Fixed-Length Array Learning Objectives After this unit, students should: understand the concept of a compound data type be able to manipulate arrays in C, including: declaring an array of a particular type and length accessing the elements within an array be aware that when declaring arrays, they are done so with a fixed-length be able to define an array as a function parameter be aware of the difference of pass by value and pass by reference, and that arrays, as parameters correspond to the latter, and consequently, the need to also indicate the length of an array as another parameter be aware that we cannot change the length of an array, only declare a new one of a different length be aware that we may check the length of an array using the sizeof operator be aware that VLA should be avoided in general, and is banned in CS1010 Your First Compound Data Type We now look at the first of the two compound data types in C -- arrays. An array is a data type that can hold one or more values. An array variable can only store values of the same type \\(T\\) . We say that the array variable is an array of \\(T\\) . For instance, we can declare a variable list to be an array of long , in which case, list can hold one or more long values. There are three different types of arrays in C: A fixed-size array is an array in which the size is known during compile time . A variable-length array (VLA) is an array in which the size is variable (known only during run-time) and is allocated on the stack . A dynamically allocated array is an array in which the size is variable (known only during run-time) and is allocated on the heap . In this unit, we will focus on fixed-size arrays. We will explain why VLA should not be used. We will leave our discussion of dynamically allocated arrays to later units. Array Declaration Let's first look at how we can declare an array variable. The declaration syntax for an array in C takes the following form: 1 long list [ 10 ]; We use the square bracket [ and ] to indicate that the variable list is an array. The number 10 indicates that marks holds 10 long values. The size of the array must be an integer value, not a variable. Just like any other local variables, declaring an array does not uninitialized initialize it. An uninitialized array contains whatever values happened to be in the memory at that time. Accessing the Array Elements We can access the array elements using the index of the element, starting from 0. For instance, to initialize the first three elements of a list to 1, 2, 4, respectively, we can write: 1 2 3 4 long list [ 10 ]; list [ 0 ] = 1 ; list [ 1 ] = 2 ; list [ 2 ] = 4 ; Same syntax, two different meanings Beginners tend to confuse with the following: 1 2 long list [ 10 ]; list [ 10 ] = 1 ; list[10] appears twice but it has two different meanings. In the first line, we are declaring an array called list of size 10. In the second line, we are using the array list , and accessing the element with index 10 (which is not valid). Array Initialization Initializing a large array using the method above could be tedious. Alternatively, we can initialize an array using a list of values when we declare the array. 1 long list [ 10 ] = { 1 , 2 , 3 , 1 , 5 , 10 , 10 , 4 , 5 , 3 , }; If we do not specify a value during initialization, it will be set to 0 by default. 1 2 long list [ 10 ] = { 1 , 2 , 3 , 1 , 5 , 10 , 10 , 4 , }; // list[8] and list[9] are both initialized to 0 Note that, after the declaration, we can no longer using this technique to reinitialized or initialize the array. 1 2 long list [ 10 ]; list = { 1 , 2 , 3 , 1 , 5 , 10 , 10 , 4 , 5 , 3 , }; // error Example: Array as Lookup Table One useful application of a pre-initialized array is to use it as a lookup table. Consider the problem burger in Exercise 1, in which we need to find out how many burgers can be made given a list of ingredients. Instead of storing the number of ingredients needed for each burger in five different variables, we can put them into an array: 1 long per_burger [ 5 ] = { 3 , 2 , 1 , 15 , 5 }; If we pass in the number of available ingredients in an array, then, we can do the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 long count_burgers ( long available [ 5 ]) { long per_burger [ 5 ] = { 3 , 2 , 1 , 15 , 5 }; long num_burgers = LONG_MAX ; for ( long i = 0 ; i < 5 ; i += 1 ) { long k = available [ i ] / per_burger [ i ]; if ( num_burgers > k ) { num_burgers = k ; } } return num_burgers ; } Passing Array as Parameter to Functions C supports several different syntaxes for passing an array as a parameter into a function. The following function declarations mean the same thing. a. Passing in the array with [ , ] and the constant size of the array. 1 2 3 void foo ( long list [ 10 ]) { : } b. Passing in the array with [ , ] and the variable containing the size of the array. 1 2 3 void foo ( long len , long list [ len ]) { : } c. Passing in the array with [ , ] 1 2 3 void foo ( long len , long list []) { : } While these three ways of declaring an array mean the same thing, in terms of human readability, Option (a) and (b) are better. Option (a) explicitly tells the reader of the code that this function expects an array called list of size 10. Option (b) explicitly tells the reader that the parameter len is the size of the array list . Option (c) does not explicitly relate len to list , and would have to depend on the comments of the code to tell the reader what len is for and how big is the array. Option (b) is the most flexible and readable option and is the recommended way in CS1010. To pass in an array as an argument, we just need to specify the name of the array: 1 2 long list [ 3 ] = { 1 , 2 , 3 }; foo ( 3 , list ); // assuming `foo` is declared with Option (b) Example: Finding Max We can now revisit the flowchart for \\(max\\) and write the function in C: 1 2 3 4 5 6 7 8 9 10 long max ( long length , long list [ length ]) { long max_so_far = list [ 0 ]; for ( long i = 1 ; i != length ; i += 1 ) { if ( list [ i ] > max_so_far ) { max_so_far = list [ i ]; } } return max_so_far ; } Array is Passed By Reference An array variable is treated differently than a variable of other types in C in several ways. One of these differential treatment has caught many new programmers by surprise -- it violates the pureness of functions. Whatever happens in the function no longer just stays in the function . Let's consider the following example: 1 2 3 4 5 6 7 8 9 10 11 void foo ( long a [ 2 ]) { a [ 0 ] = a [ 1 ]; } int main () { long a [ 2 ] = { 100 , 200 }; foo ( a ); cs1010_println_long ( a [ 0 ]); cs1010_println_long ( a [ 1 ]); } If foo is a pure function with no side-effects, then calling foo should not change a . But if you run the code above, you will see that a[0] has changed 200 ! When we pass a into foo , what do we actually push onto the stack? Unlike other variable types, we do not copy the whole array onto the stack. One reason for this is that array can be huge -- copying the whole array onto the stack for every function call with the array as an argument can be slow. Thus, in C, when an array is passed as an argument, only the memory address of the array is copied onto the stack. The following figures illustrate this point. First, let's see how an array is laid out in the memory. When we declare an array a with two elements, the appropriate space is reserved on the stack. The elements of the array are stored consecutively in the memory. This implies, that, it is sufficient to know where the first element of the array is stored. With that memory address, we can find out where the rest of the elements in the array are, and by reading the content of that memory location, find out what their values are. This \"trick\" is what allows C to pass an array into a function efficiently. When we call foo , we push the memory address of the array (i.e., of the first element of the array), on the stack. With this memory address, foo can now read the elements of the array a[0] and a[1] , by accessing the memory of the array on the stack frame of main . If foo modifies to the array, then the array on the stack frame of main is updated as well. This mechanism of passing arguments into a function is called \"pass by reference\" , as opposed to \"pass by value\" , in which we make a copy of the variable on the stack. Mitigating Impurity with const C does not give us any choice but to pass in an array by reference, making our job to reason about the behavior of our code difficult. Every time we pass an array into a function, we would have to read through the code of that function, to ensure that the array is not modified. Fortunately, C provides a mechanism to make our life better: the const keyword. The const keyword is a qualifier that indicates that a variable is read-only, and therefore cannot be modified. A good programmer should always communicate to the reader of the code if a call-by-reference parameter will be modified or not. A better way to write our max is: 1 2 3 4 5 6 7 8 9 10 long max ( const long length , const long list [ len ]) { long max_so_far = list [ 0 ]; for ( long i = 1 ; i != length ; i += 1 ) { if ( list [ i ] > max_so_far ) { max_so_far = list [ i ]; } } return max_so_far ; } Here, we are communicating to whoever reading our code that length and the elements of list will not be modified anywhere in our code. Adding const will also help us to avoid bugs in case we had a typo in our code. A buggy version of max is as follows, where the programmer mixed up k and m . Since the programmer already qualified k with the const keyword, the code wouldn't compile, avoiding hours of hair-pulling debugging session. 1 2 3 4 5 6 7 8 9 10 long max ( const long k , const long list [ k ]) { long m = list [ 0 ]; for ( long i = 1 ; i != k ; i += 1 ) { if ( list [ i ] > m ) { k = list [ i ]; } } return m ; } Pointers A more visual way to illustrate the fact that a memory location contains the memory address of another variable is to draw an arrow. For this reason, in C, a variable that stores a memory address is called a pointer . We will examine this in more detail in Unit 15, but for now, we will just introduce the * notation in C. This notation is overused in C and often confuses. You have seen how * is used for multiplication. We will now use * to indicate that a variable is a pointer, by putting it in front of the name of the variable. For instance, the line below declares a variable named address that contains the memory address of a double value. 1 double * addr ; Common Bug It is possible to write as 1 double * addr ; too, but this is not recommended. Suppose you want to declare two addresses, you might write, 1 double * from_addr , to_addr ; thinking that both from_addr and to_addr are of type double* . But C treats to_addr as a double , not an address of a double ! In any case, if you follow the CS1010 style, you shouldn't be declaring two variables in one line. We can use * to dereference a pointer, but let's keep that for another day, and stick to using * in a variable declaration for now. Array Decay We have seen in the above, how calling foo(a) would cause the address of array a to be passed into the function foo . This behavior is rooted in the principle in how C treats the name of an array: array decay . Once you understand this concept, all the special treatments C makes to array would fall into place! This is how array decay works. In C, the name of the variable of an array is treated differently from a non-array variable. If we declare an array 1 type name [ num_of_elems ]; then any reference to name is a synonym to the pointer to the first element of the array name . This explains why when we call foo with a , it is the address of the first element of a that is pushed onto the stack. 1 2 long a [ 2 ] = { 100 , 200 }; foo ( a ); This also explains why we have so many options when declaring an array as a parameter to a function. All three options below 1 2 3 void foo ( long list [ 10 ]) { .. } void foo ( long len , long list [ len ]) { .. } void foo ( long len , long list []) { .. } are equivalent to: 1 void foo ( long * list ) { .. } or 1 void foo ( long len , long * list ) { .. } since we are just passing in the pointer to a long variable. Using long *x is a perfectly valid (and common) C syntax for passing in an array, it is just not as readable since we can't tell if x is meant to be just an address to a variable, or meant to be an array. Array decay works everywhere, not just during argument passing to a function. Suppose we write 1 2 3 4 5 6 7 8 long a [ 2 ] = { 0 , 1 }; long b [ 2 ] = { 0 , 1 }; if ( a == b ) { // always false : } b = a ; // not possible Line 4 above is equivalent to comparing the memory addresses of the first elements of a and b and therefore is always false (since the array elements do not have the same memory address). Line 8 above is equivalent to assigning the memory address of the first element of a into the memory address of b , which is not allowed. We cannot change the memory address of a variable since this is determined by the OS. Returning Array from a Function Now that we have a better understanding of how we can pass an array as a pointer into a function, let's see how we can return an array from a function. Exploiting array decay, we can return the array as a pointer from a function. Consider the square function that computes the square of every element in the list: 1 2 3 4 5 6 7 long * square ( const long length , long list [ len ]) { for ( long i = 1 ; i != length ; i += 1 ) { list [ i ] = list [ i ] * list [ i ]; } return list ; } We can call the function like this: 1 2 3 long a [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; long * a2 ; a2 = square ( 5 , a ); If you examine the content of a2 , you will find that a2 correctly contains the square of the input array a . We are, however, passing in a as a reference, the code snippet above modifies a as well! One might argue that it is pointless to return an array in this case, since we could have just defined the function as a void function: 1 2 3 4 5 6 void square ( const long length , long list [ len ]) { for ( long i = 1 ; i != length ; i += 1 ) { list [ i ] = list [ i ] * list [ i ]; } } and assign a2 to a a to a2 (if we want to store the squared list in a2 ). 1 2 3 4 long a [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; square ( 5 , a ); long * a2 ; a2 = a ; Is there a way then, to keep list unmodified, while returning a \"new\" array? You might be tempted to do this: 1 2 3 4 5 6 7 8 long * square ( const long length , const long list [ len ]) { long squared [ length ]; for ( long i = 1 ; i != length ; i += 1 ) { squared [ i ] = list [ i ] * list [ i ]; } return squared ; } This is wrong for two reasons: We are declaring an array squared with a variable size on the stack. This is called a variable-length array, or VLA. This is a misnomer since once the array is created, the length is fixed. VLA is banned in CS1010. Even outside of CS1010, VLA should be used with extreme care. A VLA is allocated on the stack, which typically has very limited memory. If the stack runs out of memory, your program would crash! The situation is worse if the size of the VLA is read as an input from the users -- this implies that an external user could enter malicious input to crash your program. By returning squared , we are returning the memory address of an array allocated on the stack. Recall that when a function exits, the memory allocated to it on the stack is reclaimed and reused. Thus, the array squared no longer exists, and the content of the returned array is not now undetermined. There is a right way to do this involving allocating memory on the heap, but we will explore it in a later unit. But, in short, at this point, you haven't learned enough yet to have a correct and meaningful way to return an array from a function. Array Index Out of Bound A common bug when we work with arrays is accessing a location beyond what is allocated to the array. Unlike other languages like Java, which checks the bound for you, C does not. So we could write the following code and it would compile perfectly. 1 2 3 4 5 6 7 int main () { long a [ 10 ]; for ( long i = 0 ; i <= 10 ; i += 1 ) { a [ i ] = 1 ; } } Running this, however, would lead to memory corruption , since we are writing to a[10] (the 11-th element) but we only asked for 10 elements for the array a . So we are writing to a memory that we are not supposed to and thus causing your program to behave incorrectly. Similarly, reading from a memory location that we are not supposed to could lead to a misbehaving program. You have seen this in Problem 1.1(d). Other Facts About Arrays Skipping Elements During Initialization If we have a large array, and we want most of it to be initialized to 0, and only some non-zero, we can use element designators , putting the index of the element we want to initialize to non-zero in square brackets [ and ] . 1 long vector [ 100 ] = { 1 , [ 5 ] = 2 , 3 , [ 99 ] = -1 }; This statement initializes vector[0] to 1, vector[5] to 2, vector[6] to 3, and vector[99] to -1. The rest of the elements will be 0. Skipping the Size in Declaration If you supply an initialization list, the number of elements already indicates the length to the compiler, so you can skip the length. 1 long marks [] = { 1 , 3 , 2 , 8 , 5 ,} This makes it easy to add or remove items from the array, without having to remember to keep the array length consistent. Determining the Number of Elements in the Array C provides a sizeof operator, which returns the number of bytes allocated to a type. We can use sizeof long for instance, to determine the number of bytes allocated to long on a platform. We can also use sizeof on a variable instead of the type. This becomes useful to determine, programmatically, the length of an array (esp if the array length is skipped in the array declaration). We can calculate the number of elements in marks with 1 2 long marks [] = { 1 , 2 , 3 , 5 , 8 }; long num_of_elem = sizeof marks / sizeof marks [ 0 ]; Problem Set 14 Problem 14.1 Consider the snippet below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void doThat ( long a [], long b []) { a [ 0 ] = 100 ; b [ 1 ] = 200 ; // Line A } void doThis ( long a []) { long * b = a ; doThat ( a , b ); } int main () { long a [ 3 ] = { 0 , 0 , 0 }; doThis ( a ); // Line B } a. Show the content of the stack at Line A if the program above is executed. b. What is the content of array a at Line B? Problem 14.2 Consider the snippet below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void doThat ( long list []) { list [ 1 ] = 200 ; // Line A } void doThis ( const long a []) { long b [ 2 ] = { 10 , 10 }; a = b ; doThat ( a ); } int main () { long a [ 3 ] = { 0 , 0 , 0 }; doThis ( a ); // Line B } a. Does the code compile cleanly? b. Show the content of the stack at Line A if the program above is executed. c. What is the content of array a at Line B?","title":"14. Array"},{"location":"14-array.html#learning-objectives","text":"After this unit, students should: understand the concept of a compound data type be able to manipulate arrays in C, including: declaring an array of a particular type and length accessing the elements within an array be aware that when declaring arrays, they are done so with a fixed-length be able to define an array as a function parameter be aware of the difference of pass by value and pass by reference, and that arrays, as parameters correspond to the latter, and consequently, the need to also indicate the length of an array as another parameter be aware that we cannot change the length of an array, only declare a new one of a different length be aware that we may check the length of an array using the sizeof operator be aware that VLA should be avoided in general, and is banned in CS1010","title":"Learning Objectives"},{"location":"14-array.html#your-first-compound-data-type","text":"We now look at the first of the two compound data types in C -- arrays. An array is a data type that can hold one or more values. An array variable can only store values of the same type \\(T\\) . We say that the array variable is an array of \\(T\\) . For instance, we can declare a variable list to be an array of long , in which case, list can hold one or more long values. There are three different types of arrays in C: A fixed-size array is an array in which the size is known during compile time . A variable-length array (VLA) is an array in which the size is variable (known only during run-time) and is allocated on the stack . A dynamically allocated array is an array in which the size is variable (known only during run-time) and is allocated on the heap . In this unit, we will focus on fixed-size arrays. We will explain why VLA should not be used. We will leave our discussion of dynamically allocated arrays to later units.","title":"Your First Compound Data Type"},{"location":"14-array.html#array-declaration","text":"Let's first look at how we can declare an array variable. The declaration syntax for an array in C takes the following form: 1 long list [ 10 ]; We use the square bracket [ and ] to indicate that the variable list is an array. The number 10 indicates that marks holds 10 long values. The size of the array must be an integer value, not a variable. Just like any other local variables, declaring an array does not uninitialized initialize it. An uninitialized array contains whatever values happened to be in the memory at that time.","title":"Array Declaration"},{"location":"14-array.html#accessing-the-array-elements","text":"We can access the array elements using the index of the element, starting from 0. For instance, to initialize the first three elements of a list to 1, 2, 4, respectively, we can write: 1 2 3 4 long list [ 10 ]; list [ 0 ] = 1 ; list [ 1 ] = 2 ; list [ 2 ] = 4 ; Same syntax, two different meanings Beginners tend to confuse with the following: 1 2 long list [ 10 ]; list [ 10 ] = 1 ; list[10] appears twice but it has two different meanings. In the first line, we are declaring an array called list of size 10. In the second line, we are using the array list , and accessing the element with index 10 (which is not valid).","title":"Accessing the Array Elements"},{"location":"14-array.html#array-initialization","text":"Initializing a large array using the method above could be tedious. Alternatively, we can initialize an array using a list of values when we declare the array. 1 long list [ 10 ] = { 1 , 2 , 3 , 1 , 5 , 10 , 10 , 4 , 5 , 3 , }; If we do not specify a value during initialization, it will be set to 0 by default. 1 2 long list [ 10 ] = { 1 , 2 , 3 , 1 , 5 , 10 , 10 , 4 , }; // list[8] and list[9] are both initialized to 0 Note that, after the declaration, we can no longer using this technique to reinitialized or initialize the array. 1 2 long list [ 10 ]; list = { 1 , 2 , 3 , 1 , 5 , 10 , 10 , 4 , 5 , 3 , }; // error","title":"Array Initialization"},{"location":"14-array.html#example-array-as-lookup-table","text":"One useful application of a pre-initialized array is to use it as a lookup table. Consider the problem burger in Exercise 1, in which we need to find out how many burgers can be made given a list of ingredients. Instead of storing the number of ingredients needed for each burger in five different variables, we can put them into an array: 1 long per_burger [ 5 ] = { 3 , 2 , 1 , 15 , 5 }; If we pass in the number of available ingredients in an array, then, we can do the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 long count_burgers ( long available [ 5 ]) { long per_burger [ 5 ] = { 3 , 2 , 1 , 15 , 5 }; long num_burgers = LONG_MAX ; for ( long i = 0 ; i < 5 ; i += 1 ) { long k = available [ i ] / per_burger [ i ]; if ( num_burgers > k ) { num_burgers = k ; } } return num_burgers ; }","title":"Example: Array as Lookup Table"},{"location":"14-array.html#passing-array-as-parameter-to-functions","text":"C supports several different syntaxes for passing an array as a parameter into a function. The following function declarations mean the same thing. a. Passing in the array with [ , ] and the constant size of the array. 1 2 3 void foo ( long list [ 10 ]) { : } b. Passing in the array with [ , ] and the variable containing the size of the array. 1 2 3 void foo ( long len , long list [ len ]) { : } c. Passing in the array with [ , ] 1 2 3 void foo ( long len , long list []) { : } While these three ways of declaring an array mean the same thing, in terms of human readability, Option (a) and (b) are better. Option (a) explicitly tells the reader of the code that this function expects an array called list of size 10. Option (b) explicitly tells the reader that the parameter len is the size of the array list . Option (c) does not explicitly relate len to list , and would have to depend on the comments of the code to tell the reader what len is for and how big is the array. Option (b) is the most flexible and readable option and is the recommended way in CS1010. To pass in an array as an argument, we just need to specify the name of the array: 1 2 long list [ 3 ] = { 1 , 2 , 3 }; foo ( 3 , list ); // assuming `foo` is declared with Option (b)","title":"Passing Array as Parameter to Functions"},{"location":"14-array.html#example-finding-max","text":"We can now revisit the flowchart for \\(max\\) and write the function in C: 1 2 3 4 5 6 7 8 9 10 long max ( long length , long list [ length ]) { long max_so_far = list [ 0 ]; for ( long i = 1 ; i != length ; i += 1 ) { if ( list [ i ] > max_so_far ) { max_so_far = list [ i ]; } } return max_so_far ; }","title":"Example: Finding Max"},{"location":"14-array.html#array-is-passed-by-reference","text":"An array variable is treated differently than a variable of other types in C in several ways. One of these differential treatment has caught many new programmers by surprise -- it violates the pureness of functions. Whatever happens in the function no longer just stays in the function . Let's consider the following example: 1 2 3 4 5 6 7 8 9 10 11 void foo ( long a [ 2 ]) { a [ 0 ] = a [ 1 ]; } int main () { long a [ 2 ] = { 100 , 200 }; foo ( a ); cs1010_println_long ( a [ 0 ]); cs1010_println_long ( a [ 1 ]); } If foo is a pure function with no side-effects, then calling foo should not change a . But if you run the code above, you will see that a[0] has changed 200 ! When we pass a into foo , what do we actually push onto the stack? Unlike other variable types, we do not copy the whole array onto the stack. One reason for this is that array can be huge -- copying the whole array onto the stack for every function call with the array as an argument can be slow. Thus, in C, when an array is passed as an argument, only the memory address of the array is copied onto the stack. The following figures illustrate this point. First, let's see how an array is laid out in the memory. When we declare an array a with two elements, the appropriate space is reserved on the stack. The elements of the array are stored consecutively in the memory. This implies, that, it is sufficient to know where the first element of the array is stored. With that memory address, we can find out where the rest of the elements in the array are, and by reading the content of that memory location, find out what their values are. This \"trick\" is what allows C to pass an array into a function efficiently. When we call foo , we push the memory address of the array (i.e., of the first element of the array), on the stack. With this memory address, foo can now read the elements of the array a[0] and a[1] , by accessing the memory of the array on the stack frame of main . If foo modifies to the array, then the array on the stack frame of main is updated as well. This mechanism of passing arguments into a function is called \"pass by reference\" , as opposed to \"pass by value\" , in which we make a copy of the variable on the stack.","title":"Array is Passed By Reference"},{"location":"14-array.html#mitigating-impurity-with-const","text":"C does not give us any choice but to pass in an array by reference, making our job to reason about the behavior of our code difficult. Every time we pass an array into a function, we would have to read through the code of that function, to ensure that the array is not modified. Fortunately, C provides a mechanism to make our life better: the const keyword. The const keyword is a qualifier that indicates that a variable is read-only, and therefore cannot be modified. A good programmer should always communicate to the reader of the code if a call-by-reference parameter will be modified or not. A better way to write our max is: 1 2 3 4 5 6 7 8 9 10 long max ( const long length , const long list [ len ]) { long max_so_far = list [ 0 ]; for ( long i = 1 ; i != length ; i += 1 ) { if ( list [ i ] > max_so_far ) { max_so_far = list [ i ]; } } return max_so_far ; } Here, we are communicating to whoever reading our code that length and the elements of list will not be modified anywhere in our code. Adding const will also help us to avoid bugs in case we had a typo in our code. A buggy version of max is as follows, where the programmer mixed up k and m . Since the programmer already qualified k with the const keyword, the code wouldn't compile, avoiding hours of hair-pulling debugging session. 1 2 3 4 5 6 7 8 9 10 long max ( const long k , const long list [ k ]) { long m = list [ 0 ]; for ( long i = 1 ; i != k ; i += 1 ) { if ( list [ i ] > m ) { k = list [ i ]; } } return m ; }","title":"Mitigating Impurity with const"},{"location":"14-array.html#pointers","text":"A more visual way to illustrate the fact that a memory location contains the memory address of another variable is to draw an arrow. For this reason, in C, a variable that stores a memory address is called a pointer . We will examine this in more detail in Unit 15, but for now, we will just introduce the * notation in C. This notation is overused in C and often confuses. You have seen how * is used for multiplication. We will now use * to indicate that a variable is a pointer, by putting it in front of the name of the variable. For instance, the line below declares a variable named address that contains the memory address of a double value. 1 double * addr ; Common Bug It is possible to write as 1 double * addr ; too, but this is not recommended. Suppose you want to declare two addresses, you might write, 1 double * from_addr , to_addr ; thinking that both from_addr and to_addr are of type double* . But C treats to_addr as a double , not an address of a double ! In any case, if you follow the CS1010 style, you shouldn't be declaring two variables in one line. We can use * to dereference a pointer, but let's keep that for another day, and stick to using * in a variable declaration for now.","title":"Pointers"},{"location":"14-array.html#array-decay","text":"We have seen in the above, how calling foo(a) would cause the address of array a to be passed into the function foo . This behavior is rooted in the principle in how C treats the name of an array: array decay . Once you understand this concept, all the special treatments C makes to array would fall into place! This is how array decay works. In C, the name of the variable of an array is treated differently from a non-array variable. If we declare an array 1 type name [ num_of_elems ]; then any reference to name is a synonym to the pointer to the first element of the array name . This explains why when we call foo with a , it is the address of the first element of a that is pushed onto the stack. 1 2 long a [ 2 ] = { 100 , 200 }; foo ( a ); This also explains why we have so many options when declaring an array as a parameter to a function. All three options below 1 2 3 void foo ( long list [ 10 ]) { .. } void foo ( long len , long list [ len ]) { .. } void foo ( long len , long list []) { .. } are equivalent to: 1 void foo ( long * list ) { .. } or 1 void foo ( long len , long * list ) { .. } since we are just passing in the pointer to a long variable. Using long *x is a perfectly valid (and common) C syntax for passing in an array, it is just not as readable since we can't tell if x is meant to be just an address to a variable, or meant to be an array. Array decay works everywhere, not just during argument passing to a function. Suppose we write 1 2 3 4 5 6 7 8 long a [ 2 ] = { 0 , 1 }; long b [ 2 ] = { 0 , 1 }; if ( a == b ) { // always false : } b = a ; // not possible Line 4 above is equivalent to comparing the memory addresses of the first elements of a and b and therefore is always false (since the array elements do not have the same memory address). Line 8 above is equivalent to assigning the memory address of the first element of a into the memory address of b , which is not allowed. We cannot change the memory address of a variable since this is determined by the OS.","title":"Array Decay"},{"location":"14-array.html#returning-array-from-a-function","text":"Now that we have a better understanding of how we can pass an array as a pointer into a function, let's see how we can return an array from a function. Exploiting array decay, we can return the array as a pointer from a function. Consider the square function that computes the square of every element in the list: 1 2 3 4 5 6 7 long * square ( const long length , long list [ len ]) { for ( long i = 1 ; i != length ; i += 1 ) { list [ i ] = list [ i ] * list [ i ]; } return list ; } We can call the function like this: 1 2 3 long a [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; long * a2 ; a2 = square ( 5 , a ); If you examine the content of a2 , you will find that a2 correctly contains the square of the input array a . We are, however, passing in a as a reference, the code snippet above modifies a as well! One might argue that it is pointless to return an array in this case, since we could have just defined the function as a void function: 1 2 3 4 5 6 void square ( const long length , long list [ len ]) { for ( long i = 1 ; i != length ; i += 1 ) { list [ i ] = list [ i ] * list [ i ]; } } and assign a2 to a a to a2 (if we want to store the squared list in a2 ). 1 2 3 4 long a [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; square ( 5 , a ); long * a2 ; a2 = a ; Is there a way then, to keep list unmodified, while returning a \"new\" array? You might be tempted to do this: 1 2 3 4 5 6 7 8 long * square ( const long length , const long list [ len ]) { long squared [ length ]; for ( long i = 1 ; i != length ; i += 1 ) { squared [ i ] = list [ i ] * list [ i ]; } return squared ; } This is wrong for two reasons: We are declaring an array squared with a variable size on the stack. This is called a variable-length array, or VLA. This is a misnomer since once the array is created, the length is fixed. VLA is banned in CS1010. Even outside of CS1010, VLA should be used with extreme care. A VLA is allocated on the stack, which typically has very limited memory. If the stack runs out of memory, your program would crash! The situation is worse if the size of the VLA is read as an input from the users -- this implies that an external user could enter malicious input to crash your program. By returning squared , we are returning the memory address of an array allocated on the stack. Recall that when a function exits, the memory allocated to it on the stack is reclaimed and reused. Thus, the array squared no longer exists, and the content of the returned array is not now undetermined. There is a right way to do this involving allocating memory on the heap, but we will explore it in a later unit. But, in short, at this point, you haven't learned enough yet to have a correct and meaningful way to return an array from a function.","title":"Returning Array from a Function"},{"location":"14-array.html#array-index-out-of-bound","text":"A common bug when we work with arrays is accessing a location beyond what is allocated to the array. Unlike other languages like Java, which checks the bound for you, C does not. So we could write the following code and it would compile perfectly. 1 2 3 4 5 6 7 int main () { long a [ 10 ]; for ( long i = 0 ; i <= 10 ; i += 1 ) { a [ i ] = 1 ; } } Running this, however, would lead to memory corruption , since we are writing to a[10] (the 11-th element) but we only asked for 10 elements for the array a . So we are writing to a memory that we are not supposed to and thus causing your program to behave incorrectly. Similarly, reading from a memory location that we are not supposed to could lead to a misbehaving program. You have seen this in Problem 1.1(d).","title":"Array Index Out of Bound"},{"location":"14-array.html#other-facts-about-arrays","text":"","title":"Other Facts About Arrays"},{"location":"14-array.html#skipping-elements-during-initialization","text":"If we have a large array, and we want most of it to be initialized to 0, and only some non-zero, we can use element designators , putting the index of the element we want to initialize to non-zero in square brackets [ and ] . 1 long vector [ 100 ] = { 1 , [ 5 ] = 2 , 3 , [ 99 ] = -1 }; This statement initializes vector[0] to 1, vector[5] to 2, vector[6] to 3, and vector[99] to -1. The rest of the elements will be 0.","title":"Skipping Elements During Initialization"},{"location":"14-array.html#skipping-the-size-in-declaration","text":"If you supply an initialization list, the number of elements already indicates the length to the compiler, so you can skip the length. 1 long marks [] = { 1 , 3 , 2 , 8 , 5 ,} This makes it easy to add or remove items from the array, without having to remember to keep the array length consistent.","title":"Skipping the Size in Declaration"},{"location":"14-array.html#determining-the-number-of-elements-in-the-array","text":"C provides a sizeof operator, which returns the number of bytes allocated to a type. We can use sizeof long for instance, to determine the number of bytes allocated to long on a platform. We can also use sizeof on a variable instead of the type. This becomes useful to determine, programmatically, the length of an array (esp if the array length is skipped in the array declaration). We can calculate the number of elements in marks with 1 2 long marks [] = { 1 , 2 , 3 , 5 , 8 }; long num_of_elem = sizeof marks / sizeof marks [ 0 ];","title":"Determining the Number of Elements in the Array"},{"location":"14-array.html#problem-set-14","text":"","title":"Problem Set 14"},{"location":"14-array.html#problem-141","text":"Consider the snippet below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void doThat ( long a [], long b []) { a [ 0 ] = 100 ; b [ 1 ] = 200 ; // Line A } void doThis ( long a []) { long * b = a ; doThat ( a , b ); } int main () { long a [ 3 ] = { 0 , 0 , 0 }; doThis ( a ); // Line B } a. Show the content of the stack at Line A if the program above is executed. b. What is the content of array a at Line B?","title":"Problem 14.1"},{"location":"14-array.html#problem-142","text":"Consider the snippet below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void doThat ( long list []) { list [ 1 ] = 200 ; // Line A } void doThis ( const long a []) { long b [ 2 ] = { 10 , 10 }; a = b ; doThat ( a ); } int main () { long a [ 3 ] = { 0 , 0 , 0 }; doThis ( a ); // Line B } a. Does the code compile cleanly? b. Show the content of the stack at Line A if the program above is executed. c. What is the content of array a at Line B?","title":"Problem 14.2"},{"location":"15-pointers.html","text":"Unit 15: Pointers Learning Objectives After this unit, students should: understand what the address-of operator, & , represents and what is its type be able to use the & operator to access the address of a variable understand what the dereference operator, * , represents be aware that there is a pointer type associated with each type in C and that when * is used in the variable declaration it has a different meaning to the dereference operator be able to define pointer type variables and use the * operator, including: declaration of a pointer type variable assigning an address (of the appropriate type) to a pointer type variable accessing/assigning the value that a pointer variable points at assigning a new value by dereferencing a pointer variable understand why we cannot only change the address referenced by a variable understand the units being stored by a pointer and thus, how arithmetic operations would affect pointers be aware of pointers to pointers (and more), and the possibility of multiple levels of dereferencing be aware of the NULL pointer, understand what it represents, and be able to use it Memory Address You have learned that each variable must have three things: (i) a name, (ii) a type, and (iii) a value. A variable must be stored somewhere in the memory. Every location in the memory has an address. So, there is a fourth thing that every variable must have: a memory address. Unlike many higher-level languages, such as Java, Python, and JavaScript, C allows us direct access to memory addresses. This empowers programmers to do wonderful things that cannot be done in other languages. But, it is also dangerous at the same time -- using it improperly can lead to bugs that are hard to track down and debug. The Address-of Operator Given a variable, we can get its memory address with the \"address-of\" operator, denoted by & . Let say that we have a variable 1 long c ; We can refer to the memory address of c with the expression &c . The expression &c has the type \"address of a long \" and evaluates to a number that corresponds to the memory address of c . Note that \"address of a long \" and long are two different types to C. In general, the expression &x has the type \"address of \\(T\\) \" where \\(T\\) is the type of variable x . You have also seen in Unit 14 that a variable that stores a memory address is called a pointer. So we also interchangeably refer to the type of &c as \"pointer to a long \". Suppose we want to print out the address of c . We cannot use cs1010_println_long(&c) , since the type does not match. The CS1010 library has a function to print a pointer variable, which prints out the address in decimal format. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \"cs1010.h\" void add ( long sum , long a , long b ) { sum = a + b ; cs1010_println_pointer ( & sum ); } int main () { long x = 1 ; long sum = 0 ; add ( sum , x , 10 ); cs1010_println_pointer ( & sum ); } Running the program above prints something like this: 1 2 140723025685528 140723025685552 Your results will most likely be different since the OS allocates different regions of the memory to this program every time it is run. The Dereference Operator The dereference operator is the reversed of address-of and is denoted by * . Think of this as the \"location-of\" operator. We use this operator in two places: to declare a pointer variable, and to reference the location of an address. You have seen how we can declare a pointer variable in Unit 14 . For example, 1 double * addr ; declares a variable addr that is an address to a variable of type double . The way to read this is that *addr (or the memory location of addr ) stores a variable of type double , so addr is an address of a memory location containing a double . Changing the Value via Pointer Suppose we declare a pointer to a double variable (or, for short, a double pointer): 1 double * addr ; We can use *addr just like a normal double variable: 1 * addr = 1.0 ; The line above means that, we take the address stored in addr, go to the location at that address, and store the value 1.0 in the location. This is where things can get dangerous. You could be changing the value in a memory location that you do not mean to. If you are lucky, your program crashes with a segmentation fault error 1 . We say that your program has segfault. If you are unlucky, your program runs normally but produces incorrect output occasionally. So, always make sure that your pointer is pointing to the right location before dereferencing and writing to the location. In the code above, if we write: 1 2 double * addr ; * addr = 1.0 ; back-to-back, the program will almost certainly segfault, because the pointer variable addr is not initialized, so it is pointing to the location of whatever address happens to be in the memory at that time. We should point addr to a valid location first, like this: 1 2 3 4 double c ; double * addr ; addr = & c ; * addr = 1.0 ; Of course, the above could be simply written as: 1 double c = 1.0 ; I am just doing it the complicated way (which you should avoid unless you have good reasons to do so) to demonstrate the concept of pointers. Note that the two lines: 1 2 double * addr ; addr = & c ; can be shorten to: 1 double * addr = & c ; Basic Rules About Using Pointers When we use pointers, it must point to the variable of the same type as that declared by the pointer. For instance, 1 2 3 4 5 double pi = 3.1415926 ; long radius = 5 ; double * addr ; addr = & pi ; // ok addr = & radius ; // not ok Line 5 above would lead to a compilation error since we try to point a double pointer to a long . One exception to this rule is the type void * . A pointer to void has a special place in C and it can be used to point to any other type without type errors. The function cs1010_println_pointer , for instance, takes in a parameter of type void * , hence we can pass a pointer of any type to this function as an argument. We cannot change the address of a variable. For instance 1 2 3 long x = 1 ; long y = 2 ; & x = & y ; We try to set the address of x to be the address of y . This is not allowed since the allocation of variables in the memory is determined by the OS, a process we have no control over. We can perform arithmetic operations on pointers, but not in the way you expect. Suppose we have a pointer: 1 2 3 4 5 long x ; long * ptr ; x = 1 ; ptr = & x ; ptr += 1 ; Suppose that x is stored in memory address 1000, after Line 4, ptr would have the value of 1000. After the line ptr += 1 , using normal arithmetic operation, we would think that ptr will have a value of 1001. However, the semantic for arithmetic operations differ for pointers. The + operation for ptr causes the ptr variable to move forward by the size of the variable pointed to by the pointer. In this example, ptr points to long , assuming that long is 8 bytes, after ptr += 1 , ptr will have the value of 1008. We can only do addition and subtraction for pointers. Note that the array notation a[i] is synonym with *(a + i) . Pointer of Pointer (of Pointer..) A pointer variable is also stored in the memory, so it has an address too. 1 2 3 long x ; long * ptr ; ptr = & x ; For instance, in the above, ptr would have a memory location allocated on the stack too, and so it has an address, and we can have a variable ptrptr referring to the address of ptr . What would the type of this variable be? Since ptr is an address of long , ptrptr is an address of an address of long , and can be written as: 1 2 3 4 5 long x ; long * ptr ; long ** ptrptr ; ptr = & x ; ptrptr = & ptr ; This dereference can go on since ptrptr is also a variable and has been allocated in some memory location on the stack. We rarely need to dereference more than twice in practice, but if the situation arises, such multiple layers of dereferencing are possible. The NULL Pointer NULL is a special value that is used to indicate that a pointer is pointing to nothing. In C, NULL is actually 0 (i.e., pointing to memory location 0). We use NULL to indicate that the pointer is invalid, typically to mean that we have not initialized the pointer or to flag an error condition. Billion Dollar Mistakes Sir Tony Hoare (the same one whom we met when we talked about Assertion ) also invented the null pointer. He called it his billion-dollar mistake. Quoting from him: \"I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.\" As you start to use pointers in CS1010, you will see why it is a pain. Problem Set 15 Problem 15.1 Sketch the content of the memory while tracing through the following code. What would be printed? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 long * ptr1 ; long * ptr2 ; long x ; long y ; ptr1 = & x ; ptr2 = & y ; * ptr1 = 123 ; * ptr2 = -1 ; cs1010_println_long ( x ); cs1010_println_long ( y ); cs1010_println_long ( * ptr1 ); cs1010_println_long ( * ptr2 ); ptr1 = ptr2 ; * ptr1 = 1946 ; cs1010_println_long ( x ); cs1010_println_long ( y ); cs1010_println_long ( * ptr1 ); cs1010_println_long ( * ptr2 ); y = 10 ; cs1010_println_long ( x ); cs1010_println_long ( y ); cs1010_println_long ( * ptr1 ); cs1010_println_long ( * ptr2 ); Problem 15.2 What is wrong with both programs below? 1 2 3 4 5 6 7 8 9 10 11 12 13 double * addr_of ( double x ) { return & x ; } int main () { double c = 0.0 ; double * ptr ; ptr = addr_of ( c ); * ptr = 10 ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 double * triple_of ( double x ) { double triple = 3 * x ; return & triple ; } int main () { double * ptr ; ptr = triple_of ( 10 ); cs1010_println_double ( * ptr ); } I leave it to the later OS classes CG2271 / CS2106 to explain the term \"segmentation\" and \"fault\". Interested students can always google and read on Wikipedia . \u21a9","title":"15. Pointer"},{"location":"15-pointers.html#unit-15-pointers","text":"","title":"Unit 15: Pointers"},{"location":"15-pointers.html#learning-objectives","text":"After this unit, students should: understand what the address-of operator, & , represents and what is its type be able to use the & operator to access the address of a variable understand what the dereference operator, * , represents be aware that there is a pointer type associated with each type in C and that when * is used in the variable declaration it has a different meaning to the dereference operator be able to define pointer type variables and use the * operator, including: declaration of a pointer type variable assigning an address (of the appropriate type) to a pointer type variable accessing/assigning the value that a pointer variable points at assigning a new value by dereferencing a pointer variable understand why we cannot only change the address referenced by a variable understand the units being stored by a pointer and thus, how arithmetic operations would affect pointers be aware of pointers to pointers (and more), and the possibility of multiple levels of dereferencing be aware of the NULL pointer, understand what it represents, and be able to use it","title":"Learning Objectives"},{"location":"15-pointers.html#memory-address","text":"You have learned that each variable must have three things: (i) a name, (ii) a type, and (iii) a value. A variable must be stored somewhere in the memory. Every location in the memory has an address. So, there is a fourth thing that every variable must have: a memory address. Unlike many higher-level languages, such as Java, Python, and JavaScript, C allows us direct access to memory addresses. This empowers programmers to do wonderful things that cannot be done in other languages. But, it is also dangerous at the same time -- using it improperly can lead to bugs that are hard to track down and debug.","title":"Memory Address"},{"location":"15-pointers.html#the-address-of-operator","text":"Given a variable, we can get its memory address with the \"address-of\" operator, denoted by & . Let say that we have a variable 1 long c ; We can refer to the memory address of c with the expression &c . The expression &c has the type \"address of a long \" and evaluates to a number that corresponds to the memory address of c . Note that \"address of a long \" and long are two different types to C. In general, the expression &x has the type \"address of \\(T\\) \" where \\(T\\) is the type of variable x . You have also seen in Unit 14 that a variable that stores a memory address is called a pointer. So we also interchangeably refer to the type of &c as \"pointer to a long \". Suppose we want to print out the address of c . We cannot use cs1010_println_long(&c) , since the type does not match. The CS1010 library has a function to print a pointer variable, which prints out the address in decimal format. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \"cs1010.h\" void add ( long sum , long a , long b ) { sum = a + b ; cs1010_println_pointer ( & sum ); } int main () { long x = 1 ; long sum = 0 ; add ( sum , x , 10 ); cs1010_println_pointer ( & sum ); } Running the program above prints something like this: 1 2 140723025685528 140723025685552 Your results will most likely be different since the OS allocates different regions of the memory to this program every time it is run.","title":"The Address-of Operator"},{"location":"15-pointers.html#the-dereference-operator","text":"The dereference operator is the reversed of address-of and is denoted by * . Think of this as the \"location-of\" operator. We use this operator in two places: to declare a pointer variable, and to reference the location of an address. You have seen how we can declare a pointer variable in Unit 14 . For example, 1 double * addr ; declares a variable addr that is an address to a variable of type double . The way to read this is that *addr (or the memory location of addr ) stores a variable of type double , so addr is an address of a memory location containing a double .","title":"The Dereference Operator"},{"location":"15-pointers.html#changing-the-value-via-pointer","text":"Suppose we declare a pointer to a double variable (or, for short, a double pointer): 1 double * addr ; We can use *addr just like a normal double variable: 1 * addr = 1.0 ; The line above means that, we take the address stored in addr, go to the location at that address, and store the value 1.0 in the location. This is where things can get dangerous. You could be changing the value in a memory location that you do not mean to. If you are lucky, your program crashes with a segmentation fault error 1 . We say that your program has segfault. If you are unlucky, your program runs normally but produces incorrect output occasionally. So, always make sure that your pointer is pointing to the right location before dereferencing and writing to the location. In the code above, if we write: 1 2 double * addr ; * addr = 1.0 ; back-to-back, the program will almost certainly segfault, because the pointer variable addr is not initialized, so it is pointing to the location of whatever address happens to be in the memory at that time. We should point addr to a valid location first, like this: 1 2 3 4 double c ; double * addr ; addr = & c ; * addr = 1.0 ; Of course, the above could be simply written as: 1 double c = 1.0 ; I am just doing it the complicated way (which you should avoid unless you have good reasons to do so) to demonstrate the concept of pointers. Note that the two lines: 1 2 double * addr ; addr = & c ; can be shorten to: 1 double * addr = & c ;","title":"Changing the Value via Pointer"},{"location":"15-pointers.html#basic-rules-about-using-pointers","text":"When we use pointers, it must point to the variable of the same type as that declared by the pointer. For instance, 1 2 3 4 5 double pi = 3.1415926 ; long radius = 5 ; double * addr ; addr = & pi ; // ok addr = & radius ; // not ok Line 5 above would lead to a compilation error since we try to point a double pointer to a long . One exception to this rule is the type void * . A pointer to void has a special place in C and it can be used to point to any other type without type errors. The function cs1010_println_pointer , for instance, takes in a parameter of type void * , hence we can pass a pointer of any type to this function as an argument. We cannot change the address of a variable. For instance 1 2 3 long x = 1 ; long y = 2 ; & x = & y ; We try to set the address of x to be the address of y . This is not allowed since the allocation of variables in the memory is determined by the OS, a process we have no control over. We can perform arithmetic operations on pointers, but not in the way you expect. Suppose we have a pointer: 1 2 3 4 5 long x ; long * ptr ; x = 1 ; ptr = & x ; ptr += 1 ; Suppose that x is stored in memory address 1000, after Line 4, ptr would have the value of 1000. After the line ptr += 1 , using normal arithmetic operation, we would think that ptr will have a value of 1001. However, the semantic for arithmetic operations differ for pointers. The + operation for ptr causes the ptr variable to move forward by the size of the variable pointed to by the pointer. In this example, ptr points to long , assuming that long is 8 bytes, after ptr += 1 , ptr will have the value of 1008. We can only do addition and subtraction for pointers. Note that the array notation a[i] is synonym with *(a + i) .","title":"Basic Rules About Using Pointers"},{"location":"15-pointers.html#pointer-of-pointer-of-pointer","text":"A pointer variable is also stored in the memory, so it has an address too. 1 2 3 long x ; long * ptr ; ptr = & x ; For instance, in the above, ptr would have a memory location allocated on the stack too, and so it has an address, and we can have a variable ptrptr referring to the address of ptr . What would the type of this variable be? Since ptr is an address of long , ptrptr is an address of an address of long , and can be written as: 1 2 3 4 5 long x ; long * ptr ; long ** ptrptr ; ptr = & x ; ptrptr = & ptr ; This dereference can go on since ptrptr is also a variable and has been allocated in some memory location on the stack. We rarely need to dereference more than twice in practice, but if the situation arises, such multiple layers of dereferencing are possible.","title":"Pointer of Pointer (of Pointer..)"},{"location":"15-pointers.html#the-null-pointer","text":"NULL is a special value that is used to indicate that a pointer is pointing to nothing. In C, NULL is actually 0 (i.e., pointing to memory location 0). We use NULL to indicate that the pointer is invalid, typically to mean that we have not initialized the pointer or to flag an error condition. Billion Dollar Mistakes Sir Tony Hoare (the same one whom we met when we talked about Assertion ) also invented the null pointer. He called it his billion-dollar mistake. Quoting from him: \"I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.\" As you start to use pointers in CS1010, you will see why it is a pain.","title":"The NULL Pointer"},{"location":"15-pointers.html#problem-set-15","text":"","title":"Problem Set 15"},{"location":"15-pointers.html#problem-151","text":"Sketch the content of the memory while tracing through the following code. What would be printed? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 long * ptr1 ; long * ptr2 ; long x ; long y ; ptr1 = & x ; ptr2 = & y ; * ptr1 = 123 ; * ptr2 = -1 ; cs1010_println_long ( x ); cs1010_println_long ( y ); cs1010_println_long ( * ptr1 ); cs1010_println_long ( * ptr2 ); ptr1 = ptr2 ; * ptr1 = 1946 ; cs1010_println_long ( x ); cs1010_println_long ( y ); cs1010_println_long ( * ptr1 ); cs1010_println_long ( * ptr2 ); y = 10 ; cs1010_println_long ( x ); cs1010_println_long ( y ); cs1010_println_long ( * ptr1 ); cs1010_println_long ( * ptr2 );","title":"Problem 15.1"},{"location":"15-pointers.html#problem-152","text":"What is wrong with both programs below? 1 2 3 4 5 6 7 8 9 10 11 12 13 double * addr_of ( double x ) { return & x ; } int main () { double c = 0.0 ; double * ptr ; ptr = addr_of ( c ); * ptr = 10 ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 double * triple_of ( double x ) { double triple = 3 * x ; return & triple ; } int main () { double * ptr ; ptr = triple_of ( 10 ); cs1010_println_double ( * ptr ); } I leave it to the later OS classes CG2271 / CS2106 to explain the term \"segmentation\" and \"fault\". Interested students can always google and read on Wikipedia . \u21a9","title":"Problem 15.2"},{"location":"16-call-by-reference.html","text":"Unit 16: Call by Reference Learning Objectives After completing this unit, students should: understand the differences between call-by-value and call-by-reference understand the mechanism we can perform call-by-reference in C using stack and pointers know the situations where call-by-reference is useful be able to read and write code that uses call-by-references know how to write Doxygen documentation to document the parameters of a function. Call By Reference In Unit 14 , we have seen how an array is being passed by reference. When we pass an array a into a function, due to array decay, we are passing in the pointer to the first element of the array ( &a[0] ). So, what gets copied onto the call stack is the pointer to the array, not the actual array itself. Now, with this pointer, we can modify the elements in the array directly. Passing Non-Array Variables by References We mentioned that for all other non-array variables when we pass in a variable, the value of the variable gets copied onto the stack. This mechanism is called call-by-value. The call-by-value mechanism has its limitation. Sometimes, it is useful for a function to return more than one result. You have seen an example before in your Assignment 2 , where, for the collatz problem, you are supposed to find both the largest stopping time and the value with the largest stopping time. C functions, however, can only return at most one value. One way to get around this limitation is to use call-by-reference, the other is to use struct . We will leave the discussion of struct for another day, so let's see use call-by-reference on non-array variables. We use call-by-reference by passing in the a pointer to a variable into a function, instead of the value of variable . Here is an example taken from the collatz problem. Example: Collatz 1 2 3 4 5 6 7 8 9 10 11 void find_max_steps ( long n , long * max_n , long * max_num_steps ) { * max_num_steps = 0 ; * max_n = 1 ; for ( long i = 1 ; i <= n ; i += 1 ) { long num_of_steps = count_num_of_steps ( i ); if ( num_of_steps >= * max_num_steps ) { * max_n = i ; * max_num_steps = num_of_steps ; } } } The method find_max_steps takes in two pointers. Inside the function, we use the deference operator * to modify the variable pointed to by the pointers (Lines 2, 3, 7, and 8). To use this function, we have: 1 2 3 4 5 6 7 8 9 int main () { long n = cs1010_read_long (); long max_num_steps ; long max_n ; find_max_steps ( n , & max_n , & max_num_steps ); cs1010_println_long ( max_n ); cs1010_println_long ( max_num_steps ); } In Line 4 above, we pass in the address of max_n and max_num_steps into find_max_steps . find_max_steps updates both variables for us. Example: Swapping Two Variables Another example of call-by-reference is a function that swaps two variables. Here is one that swaps two long variables. 1 2 3 4 5 void swap ( long * a , long * b ) { long temp = * a ; * a = * b ; * b = temp ; } To see swap in action, consider: 1 2 3 long a = 10 ; long b = -4 ; swap ( & a , & b ); After calling swap , the value for a becomes -4, b becomes 10. Documenting Call-by-Reference Parameters A parameter passed as a pointer could be used in three different ways: The parameter could be a read-only input, and the main purpose of passing in the value is so that the function has access to the value of the pointer. The parameter could be used as a vessel for the function to pass a value to the caller, similar to the parameters max_n and max_num_steps in the function find_max_steps above. In this case, the value contained in the variable pointed to by the pointer does not matter. The parameter could be used as both input and output. The value contained in the parameter is read inside the function, and the value is updated from inside the function. For example, the parameters passed to swap above. In CS1010, we will be using the Doxygen format to document our functions. There are three types of parameters, corresponding to the three situations above: @param[in] is used to document a read-only parameter (note that this applies to all read-only parameters, not just pointers). @param[out] is used to document an output-only parameter, and @param[in,out] is used to document a parameter that is both input and output. Problem Set Problem 16.1 Consider the program below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void foo ( double * ptr , double trouble ) { ptr = & trouble ; * ptr = 10.0 ; } int main () { double * ptr ; double x = -3.0 ; double y = 7.0 ; ptr = & y ; foo ( ptr , x ); cs1010_println_double ( x ); cs1010_println_double ( y ); } What would be printed?","title":"16. Call-by-Reference"},{"location":"16-call-by-reference.html#unit-16-call-by-reference","text":"","title":"Unit 16: Call by Reference"},{"location":"16-call-by-reference.html#learning-objectives","text":"After completing this unit, students should: understand the differences between call-by-value and call-by-reference understand the mechanism we can perform call-by-reference in C using stack and pointers know the situations where call-by-reference is useful be able to read and write code that uses call-by-references know how to write Doxygen documentation to document the parameters of a function.","title":"Learning Objectives"},{"location":"16-call-by-reference.html#call-by-reference","text":"In Unit 14 , we have seen how an array is being passed by reference. When we pass an array a into a function, due to array decay, we are passing in the pointer to the first element of the array ( &a[0] ). So, what gets copied onto the call stack is the pointer to the array, not the actual array itself. Now, with this pointer, we can modify the elements in the array directly.","title":"Call By Reference"},{"location":"16-call-by-reference.html#passing-non-array-variables-by-references","text":"We mentioned that for all other non-array variables when we pass in a variable, the value of the variable gets copied onto the stack. This mechanism is called call-by-value. The call-by-value mechanism has its limitation. Sometimes, it is useful for a function to return more than one result. You have seen an example before in your Assignment 2 , where, for the collatz problem, you are supposed to find both the largest stopping time and the value with the largest stopping time. C functions, however, can only return at most one value. One way to get around this limitation is to use call-by-reference, the other is to use struct . We will leave the discussion of struct for another day, so let's see use call-by-reference on non-array variables. We use call-by-reference by passing in the a pointer to a variable into a function, instead of the value of variable . Here is an example taken from the collatz problem.","title":"Passing Non-Array Variables by References"},{"location":"16-call-by-reference.html#example-collatz","text":"1 2 3 4 5 6 7 8 9 10 11 void find_max_steps ( long n , long * max_n , long * max_num_steps ) { * max_num_steps = 0 ; * max_n = 1 ; for ( long i = 1 ; i <= n ; i += 1 ) { long num_of_steps = count_num_of_steps ( i ); if ( num_of_steps >= * max_num_steps ) { * max_n = i ; * max_num_steps = num_of_steps ; } } } The method find_max_steps takes in two pointers. Inside the function, we use the deference operator * to modify the variable pointed to by the pointers (Lines 2, 3, 7, and 8). To use this function, we have: 1 2 3 4 5 6 7 8 9 int main () { long n = cs1010_read_long (); long max_num_steps ; long max_n ; find_max_steps ( n , & max_n , & max_num_steps ); cs1010_println_long ( max_n ); cs1010_println_long ( max_num_steps ); } In Line 4 above, we pass in the address of max_n and max_num_steps into find_max_steps . find_max_steps updates both variables for us.","title":"Example: Collatz"},{"location":"16-call-by-reference.html#example-swapping-two-variables","text":"Another example of call-by-reference is a function that swaps two variables. Here is one that swaps two long variables. 1 2 3 4 5 void swap ( long * a , long * b ) { long temp = * a ; * a = * b ; * b = temp ; } To see swap in action, consider: 1 2 3 long a = 10 ; long b = -4 ; swap ( & a , & b ); After calling swap , the value for a becomes -4, b becomes 10.","title":"Example: Swapping Two Variables"},{"location":"16-call-by-reference.html#documenting-call-by-reference-parameters","text":"A parameter passed as a pointer could be used in three different ways: The parameter could be a read-only input, and the main purpose of passing in the value is so that the function has access to the value of the pointer. The parameter could be used as a vessel for the function to pass a value to the caller, similar to the parameters max_n and max_num_steps in the function find_max_steps above. In this case, the value contained in the variable pointed to by the pointer does not matter. The parameter could be used as both input and output. The value contained in the parameter is read inside the function, and the value is updated from inside the function. For example, the parameters passed to swap above. In CS1010, we will be using the Doxygen format to document our functions. There are three types of parameters, corresponding to the three situations above: @param[in] is used to document a read-only parameter (note that this applies to all read-only parameters, not just pointers). @param[out] is used to document an output-only parameter, and @param[in,out] is used to document a parameter that is both input and output.","title":"Documenting Call-by-Reference Parameters"},{"location":"16-call-by-reference.html#problem-set","text":"","title":"Problem Set"},{"location":"16-call-by-reference.html#problem-161","text":"Consider the program below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void foo ( double * ptr , double trouble ) { ptr = & trouble ; * ptr = 10.0 ; } int main () { double * ptr ; double x = -3.0 ; double y = 7.0 ; ptr = & y ; foo ( ptr , x ); cs1010_println_double ( x ); cs1010_println_double ( y ); } What would be printed?","title":"Problem 16.1"},{"location":"17-heap.html","text":"Unit 17: Heap Learning Objectives After completing this unit, students should: understand the differences between the stack and the heap be able to use malloc and calloc to declare dynamically-sized arrays on the heap understand the importance of (i) checking for NULL and (ii) free the memory allocated on the heap aware of the possibility of memory leakage and avoid common mistakes that could lead to memory leaks Variables on Heap We have already seen what a call stack is and how the call stack works in Unit 13 . There is another important area of memory used by our programs, called the heap . The memory allocation on the heap can be done automatically or manually. For variables allocated on the heap, its lifetime is either the same as the lifetime of the whole program. An example of such a variable is a global variable -- a variable that is declared outside of any function and can be read or write anywhere in the program. We have banned the use of global variables in CS1010. Using a global variable makes your code hard to understand or reason about: 1 2 3 x = 1 ; foo (); // { x == ?? } Suppose x is a global variable, we cannot assert anything about the property of x after calling foo , since x can be modified by foo or any function it calls, even though we never pass x into foo . This is worse than passing an array as we have seen in Unit 16 ! Since now, to assert something about x , we need to trace through every line the code to how x is updated, even if the function does not take in x as a parameter. Manual Memory Allocation / Deallocation Allocating memory on the heap, however, is useful if we want to allocate an array dynamically, i.e., not knowing what is the size of the array when we write the program. Often, we need an array whose size depends on the input from the user, such as reading a string or reading a sequence of numbers. We cannot use a fixed-length array unless we know for sure that the input size is limited, and we cannot use a variable-length array, since we may get a segfault if the array size is too big for the stack. The only viable solution is to allocate the array on the heap. The C standard library provides a few functions related to memory allocation on the heap. The header file for these functions is stdlib.h . We are interested in malloc and calloc . malloc (memory allocation) is declared as: 1 void * malloc ( size_t size ); It takes in a parameter, size , which is the number of bytes of memory to be allocated and returns a pointer to the memory allocated if successful, or NULL otherwise. This is a general function so the type of pointer returned is void * rather than a pointer to a specific type. The type of size is size_t , which is an unsigned integer type defined in stdlib.h to represent the size of a type/variable in memory. You can read a size_t variable from the standard input using the CS1010 library function cs1010_read_size_t() . The function calloc (clear allocation) is declared as: 1 void * calloc ( size_t count , size_t size ); calloc allocates memory for count items, each of size number of bytes, in a contiguous region in the memory and initializes all bits in this memory region to 0. Except for the fact that calloc initializes the bits to 0, calloc(count, size) is the same as malloc(count * size) . We have seen in Unit 5 that the number of bytes needed to represent a type depends on the platform. Suppose we want to allocate enough memory for, say, 10 long values, how do we know how many bytes are needed? A long can be 4 bytes on some platforms, 8 bytes on others. For this purpose, C provides a sizeof operator, that returns the number of bytes needed for a type or a variable (of type size_t ) So, to allocate memory for 10 long values, we say: 1 long * array = malloc ( 10 * sizeof ( long )); Memory Deallocation Even though the memory available on the heap is larger than the stack, it is not unlimited, and therefore we should still use the memory judiciously. In particular, after we are done using the memory allocated to us, we should call the method free , passing in the pointer the memory region allocated, to have the memory region deallocated, returned to the OS to be reused by others. A common bug is for a programmer to access a memory that has been freed or free an allocated memory region more than once. This would cause strange behaviors, possible crashes in random places if we access memory that is being used by others. It is a good practice to set the pointer to NULL after free -ing the memory region so that we do not accidentally use it. 1 2 free(buffer); buffer = NULL; Another common bug is for programmers to request memory via malloc or related functions, but forgot to free it back to the OS. As a result, as the program runs, it starts to hog the memory and the system will become slower and slower. This bug is known as memory leak . Another possible bug is for programmers to change the pointer to the region of memory allocated. For instance, 1 2 long *buffer = calloc(how_many, sizeof(long)); buffer = cs1010_read_long_array(how_many); After we execute the code such as the above, the pointer buffer will point to something new, and there is no longer a pointer pointing to allocate memory. The memory allocated becomes unreachable, and therefore we can no longer free it! In CS1010, from now on, you are to make sure that memory that is allocated via malloc and related functions are free after it is used, including those allocated in the CS1010 I/O library. The API documentation tells you what are the values returned by the library that should be deallocated by the caller via free . Memory Reallocation If we allocate an array on the heap, we can even change the size of the array dynamically during run-time. For instance, there could be cases where we don't know the size of the array we need. We can allocate an array, say, of size n , at the beginning of our program. As we populate the array, we may realize that n is too small, and we need a bigger array. We can use the method realloc to reallocate our array to a larger size as needed. Interested students can read the man page for realloc for more details. CS1010 I/O Library To wrap up this unit, we will look at the CS1010 library functions that help us read in an array of either long values or double values. These functions, cs1010_read_long_array or cs1010_read_double_array take in a parameter, which is the number of elements to read (of type size_t ) and it returns a pointer to the array allocated within the function. A typical usage is as follows: we first read the size of the array size with cs1010_read_size_t() , then use cs1010_read_long_array(size) to read the array. Here is the incomplete version: 1 2 3 4 5 6 size_t num_of_students = cs1010_read_size_t (); long * marks ; marks = cs1010_read_long_array ( num_of_students ); for ( size_t i = 0 ; i < num_of_students ; i += 1 ) { cs1010_println_long ( marks [ i ]); } This should be straightforward enough. There are, however, two cases to consider. What if the OS failed to allocate the memory for our array? In this case, marks would be NULL and access marks[i] would cause a segfault. Second, we must return the memory allocated to us back to the OS once we are done. To let go of this memory, we call the function free . The complete code looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 size_t num_of_students = cs1010_read_size_t (); long * marks ; marks = cs1010_read_long_array ( num_of_students ); if ( marks == NULL ) { // signal error and return } for ( size_t i = 0 ; i < num_of_students ; i += 1 ) { cs1010_println_long ( marks [ i ]); } // do other things to marks : free ( marks ); The CS1010 I/O library, internally, allocates memory on the heap so that we can read in words, lines, or arrays of arbitrary length. The following shows the example of how cs1010_read_long_array is implemented with calloc . 1 2 3 4 5 6 7 8 9 10 11 12 13 long * cs1010_read_long_array ( size_t how_many ) { long * buffer = calloc ( how_many , sizeof ( long )); if ( buffer == NULL ) { return NULL ; } for ( size_t i = 0 ; i < how_many ; i += 1 ) { buffer [ i ] = cs1010_read_long (); } return buffer ; } Problem Set Problem Set 17.1 Draw the call stack and the heap, showing what happened when we run the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void foo ( long * y , long * z ) { y [ 0 ] = -7 ; y [ 1 ] = -8 ; z [ 0 ] = 4 ; z [ 1 ] = 5 ; } int main () { long y [ 2 ] = { 1 , 2 }; long * z = calloc ( 2 , sizeof ( long )); z [ 0 ] = y [ 0 ]; z [ 1 ] = y [ 1 ]; foo ( y , z ); }","title":"17. Heap"},{"location":"17-heap.html#unit-17-heap","text":"","title":"Unit 17: Heap"},{"location":"17-heap.html#learning-objectives","text":"After completing this unit, students should: understand the differences between the stack and the heap be able to use malloc and calloc to declare dynamically-sized arrays on the heap understand the importance of (i) checking for NULL and (ii) free the memory allocated on the heap aware of the possibility of memory leakage and avoid common mistakes that could lead to memory leaks","title":"Learning Objectives"},{"location":"17-heap.html#variables-on-heap","text":"We have already seen what a call stack is and how the call stack works in Unit 13 . There is another important area of memory used by our programs, called the heap . The memory allocation on the heap can be done automatically or manually. For variables allocated on the heap, its lifetime is either the same as the lifetime of the whole program. An example of such a variable is a global variable -- a variable that is declared outside of any function and can be read or write anywhere in the program. We have banned the use of global variables in CS1010. Using a global variable makes your code hard to understand or reason about: 1 2 3 x = 1 ; foo (); // { x == ?? } Suppose x is a global variable, we cannot assert anything about the property of x after calling foo , since x can be modified by foo or any function it calls, even though we never pass x into foo . This is worse than passing an array as we have seen in Unit 16 ! Since now, to assert something about x , we need to trace through every line the code to how x is updated, even if the function does not take in x as a parameter.","title":"Variables on Heap"},{"location":"17-heap.html#manual-memory-allocation-deallocation","text":"Allocating memory on the heap, however, is useful if we want to allocate an array dynamically, i.e., not knowing what is the size of the array when we write the program. Often, we need an array whose size depends on the input from the user, such as reading a string or reading a sequence of numbers. We cannot use a fixed-length array unless we know for sure that the input size is limited, and we cannot use a variable-length array, since we may get a segfault if the array size is too big for the stack. The only viable solution is to allocate the array on the heap. The C standard library provides a few functions related to memory allocation on the heap. The header file for these functions is stdlib.h . We are interested in malloc and calloc . malloc (memory allocation) is declared as: 1 void * malloc ( size_t size ); It takes in a parameter, size , which is the number of bytes of memory to be allocated and returns a pointer to the memory allocated if successful, or NULL otherwise. This is a general function so the type of pointer returned is void * rather than a pointer to a specific type. The type of size is size_t , which is an unsigned integer type defined in stdlib.h to represent the size of a type/variable in memory. You can read a size_t variable from the standard input using the CS1010 library function cs1010_read_size_t() . The function calloc (clear allocation) is declared as: 1 void * calloc ( size_t count , size_t size ); calloc allocates memory for count items, each of size number of bytes, in a contiguous region in the memory and initializes all bits in this memory region to 0. Except for the fact that calloc initializes the bits to 0, calloc(count, size) is the same as malloc(count * size) . We have seen in Unit 5 that the number of bytes needed to represent a type depends on the platform. Suppose we want to allocate enough memory for, say, 10 long values, how do we know how many bytes are needed? A long can be 4 bytes on some platforms, 8 bytes on others. For this purpose, C provides a sizeof operator, that returns the number of bytes needed for a type or a variable (of type size_t ) So, to allocate memory for 10 long values, we say: 1 long * array = malloc ( 10 * sizeof ( long ));","title":"Manual Memory Allocation / Deallocation"},{"location":"17-heap.html#memory-deallocation","text":"Even though the memory available on the heap is larger than the stack, it is not unlimited, and therefore we should still use the memory judiciously. In particular, after we are done using the memory allocated to us, we should call the method free , passing in the pointer the memory region allocated, to have the memory region deallocated, returned to the OS to be reused by others. A common bug is for a programmer to access a memory that has been freed or free an allocated memory region more than once. This would cause strange behaviors, possible crashes in random places if we access memory that is being used by others. It is a good practice to set the pointer to NULL after free -ing the memory region so that we do not accidentally use it. 1 2 free(buffer); buffer = NULL; Another common bug is for programmers to request memory via malloc or related functions, but forgot to free it back to the OS. As a result, as the program runs, it starts to hog the memory and the system will become slower and slower. This bug is known as memory leak . Another possible bug is for programmers to change the pointer to the region of memory allocated. For instance, 1 2 long *buffer = calloc(how_many, sizeof(long)); buffer = cs1010_read_long_array(how_many); After we execute the code such as the above, the pointer buffer will point to something new, and there is no longer a pointer pointing to allocate memory. The memory allocated becomes unreachable, and therefore we can no longer free it! In CS1010, from now on, you are to make sure that memory that is allocated via malloc and related functions are free after it is used, including those allocated in the CS1010 I/O library. The API documentation tells you what are the values returned by the library that should be deallocated by the caller via free .","title":"Memory Deallocation"},{"location":"17-heap.html#memory-reallocation","text":"If we allocate an array on the heap, we can even change the size of the array dynamically during run-time. For instance, there could be cases where we don't know the size of the array we need. We can allocate an array, say, of size n , at the beginning of our program. As we populate the array, we may realize that n is too small, and we need a bigger array. We can use the method realloc to reallocate our array to a larger size as needed. Interested students can read the man page for realloc for more details.","title":"Memory Reallocation"},{"location":"17-heap.html#cs1010-io-library","text":"To wrap up this unit, we will look at the CS1010 library functions that help us read in an array of either long values or double values. These functions, cs1010_read_long_array or cs1010_read_double_array take in a parameter, which is the number of elements to read (of type size_t ) and it returns a pointer to the array allocated within the function. A typical usage is as follows: we first read the size of the array size with cs1010_read_size_t() , then use cs1010_read_long_array(size) to read the array. Here is the incomplete version: 1 2 3 4 5 6 size_t num_of_students = cs1010_read_size_t (); long * marks ; marks = cs1010_read_long_array ( num_of_students ); for ( size_t i = 0 ; i < num_of_students ; i += 1 ) { cs1010_println_long ( marks [ i ]); } This should be straightforward enough. There are, however, two cases to consider. What if the OS failed to allocate the memory for our array? In this case, marks would be NULL and access marks[i] would cause a segfault. Second, we must return the memory allocated to us back to the OS once we are done. To let go of this memory, we call the function free . The complete code looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 size_t num_of_students = cs1010_read_size_t (); long * marks ; marks = cs1010_read_long_array ( num_of_students ); if ( marks == NULL ) { // signal error and return } for ( size_t i = 0 ; i < num_of_students ; i += 1 ) { cs1010_println_long ( marks [ i ]); } // do other things to marks : free ( marks ); The CS1010 I/O library, internally, allocates memory on the heap so that we can read in words, lines, or arrays of arbitrary length. The following shows the example of how cs1010_read_long_array is implemented with calloc . 1 2 3 4 5 6 7 8 9 10 11 12 13 long * cs1010_read_long_array ( size_t how_many ) { long * buffer = calloc ( how_many , sizeof ( long )); if ( buffer == NULL ) { return NULL ; } for ( size_t i = 0 ; i < how_many ; i += 1 ) { buffer [ i ] = cs1010_read_long (); } return buffer ; }","title":"CS1010 I/O Library"},{"location":"17-heap.html#problem-set","text":"","title":"Problem Set"},{"location":"17-heap.html#problem-set-171","text":"Draw the call stack and the heap, showing what happened when we run the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void foo ( long * y , long * z ) { y [ 0 ] = -7 ; y [ 1 ] = -8 ; z [ 0 ] = 4 ; z [ 1 ] = 5 ; } int main () { long y [ 2 ] = { 1 , 2 }; long * z = calloc ( 2 , sizeof ( long )); z [ 0 ] = y [ 0 ]; z [ 1 ] = y [ 1 ]; foo ( y , z ); }","title":"Problem Set 17.1"},{"location":"18-string.html","text":"Unit 18: Characters and Strings Learning Objectives After this unit, students should: understand that a string is an array of chars know that a string always ends with a char with value 0 (or '\\0' ) be aware of the different types of special chars understand what the empty string represents be able to use the CS1010 library functions to read strings and arrays of strings The char type Recall that the char type is of size 8 bits. The ASCII code maps each bit sequence to character the letters, digits, punctuations, and some non-visible characters such as null, escape, newline, beep, etc. To denote a character literal, we use the single quote ' . For instance, we can write something like this: 1 char x = 'A' ; Further, recall that the type of a variable determines how we interpret a bit sequence. Given the same bit sequence, we can interpret it differently if we assign it to a different type. If we call 1 2 3 char x = 'A' ; putchar ( x ); cs1010_println_long ( x ); We will see that the character A is first printed, followed by its numeric value 41 . We can use this property to manipulate the char variable with arithmetic operations. For instance, 1 2 char x = 'A' ; putchar ( x + 1 ); would print B . Special Characters The use of the backslash \\ creates an escape sequence that can be used to denote characters that would otherwise not be visible on the screen. For instance, '\\n' refers to the newline character, '\\t' refers to the tab character, '\\a' refers to the beep character. Furthermore, since we already use \\ to indicate the escape sequence, ' to indicate a character, and \" to indicate a string, to use these characters, we need to \"escape\" them -- we use '\\\\' for the backslash character, '\\'' , the single quote character, and the '\\\"' double-quote character. String We have seen strings as a sequence of characters stored in double quotes, e.g., \"hello!\". Note how we distinguish between a string and a char by the quotes used. String uses double quotes \" ; a char uses a single quote ' . In C, a string is nothing more than just an array of char values. The only thing special about a string is that it always end with a 0 value (note: not character '0' which has a value of 48, but the value 0). Since the character with value 0 is called the null character, written as '\\0' , we refer to that strings in C as null-terminated strings. The following two ways of initializing a string is thus equivalent: 1 2 char hello1 [ 7 ] = { 'h' , 'e' , 'l' , 'l' , 'o' , '!' , '\\0' }; char hello2 [ 7 ] = \"hello!\" ; The second way is more easily readable. We can also skip the size of the array, as mentioned above, or, more commonly, use a char * type for a variable storing a constant string. 1 2 char hello3 [] = \"hello!\" ; char * hello4 = \"hello!\" ; String Literals A string literal refers to a string written between two \" characters, such as \"Hello world!\" . Such a string is still internally stored as an array of char values. The location these arrays are stored depends on the platform, but usually, they are stored in a read-only region of the memory called the text region. These strings are not meant to be modified. Hence, trying something like this: 1 2 char * str1 = \"Hello!\" ; str1 [ 5 ] = '.' ; is not allowed and would crash your program. The following, however, is OK: 1 2 char str2 [ 7 ] = \"Hello!\" ; str2 [ 5 ] = '.' ; The difference between the two is that str1 points to a read-only region in the memory, while str2 contains a copy of the string on the stack. Empty String We commonly use the empty string \"\" to indicate a special condition or to initialize a string variable, where appropriate. The empty string is nothing but an array where the 0-th element is '\\0'. Common Bugs A very common bug for beginners to C programming is to forget about the terminating '\\0' char in a string. For instance, suppose you want to copy one string to another: 1 2 3 4 5 char src [ 6 ] = \"hello!\" char dst [ 6 ]; for ( long i = 0 ; i < 6 ; i += 1 ) { dst [ i ] = src [ i ]; } The string variable dst is not terminated and C would treat whatever follows the memory location as part of the string! The other common bug is to create an array that is too small for the string. Suppose you use the function strcpy provided by C to copy the string instead. 1 2 3 char src [ 6 ] = \"hello!\" char dst [ 6 ]; strcpy ( dst , src ); strcpy would properly copy the characters 'h' , 'e' , .. '!' , AND the terminating '\\0' . That's a total of 7 characters. The code, however, only allocated the space of 6 characters for dst . So overflow occurs and your program might crash. So, remember to always account for the \"invincible friend\" at the end of every string, and leave a space for it. CS1010 I/O Library The CS1010 I/O library provides two functions, one to read a word (separated by white-space characters) and the other to read a line (separated by a newline character). They are cs1010_read_word() and cs1010_read_line() respectively. We can also read multiple words and multiple lines with cs1010_read_word_array() and cs1010_read_line_array() . The results are stored in an array of strings. The arrays and strings returned by these functions need to be deallocated by the caller. Particularly, note that when an array of strings are returned by both cs1010_read_word_array() and cs1010_read_line_array() , the strings and the array holding the strings all need to be freed. A typical usage is as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 size_t k = cs1010_read_size_t (); char ** lines = cs1010_read_line_array ( k ); if ( lines == NULL ) { // Deal with error return ; } // Do something with array lines : : for ( size_t i = 0 ; i < k ; i += 1 ) { free ( lines [ i ]); } free ( lines );","title":"18. String"},{"location":"18-string.html#unit-18-characters-and-strings","text":"","title":"Unit 18: Characters and Strings"},{"location":"18-string.html#learning-objectives","text":"After this unit, students should: understand that a string is an array of chars know that a string always ends with a char with value 0 (or '\\0' ) be aware of the different types of special chars understand what the empty string represents be able to use the CS1010 library functions to read strings and arrays of strings","title":"Learning Objectives"},{"location":"18-string.html#the-char-type","text":"Recall that the char type is of size 8 bits. The ASCII code maps each bit sequence to character the letters, digits, punctuations, and some non-visible characters such as null, escape, newline, beep, etc. To denote a character literal, we use the single quote ' . For instance, we can write something like this: 1 char x = 'A' ; Further, recall that the type of a variable determines how we interpret a bit sequence. Given the same bit sequence, we can interpret it differently if we assign it to a different type. If we call 1 2 3 char x = 'A' ; putchar ( x ); cs1010_println_long ( x ); We will see that the character A is first printed, followed by its numeric value 41 . We can use this property to manipulate the char variable with arithmetic operations. For instance, 1 2 char x = 'A' ; putchar ( x + 1 ); would print B .","title":"The char type"},{"location":"18-string.html#special-characters","text":"The use of the backslash \\ creates an escape sequence that can be used to denote characters that would otherwise not be visible on the screen. For instance, '\\n' refers to the newline character, '\\t' refers to the tab character, '\\a' refers to the beep character. Furthermore, since we already use \\ to indicate the escape sequence, ' to indicate a character, and \" to indicate a string, to use these characters, we need to \"escape\" them -- we use '\\\\' for the backslash character, '\\'' , the single quote character, and the '\\\"' double-quote character.","title":"Special Characters"},{"location":"18-string.html#string","text":"We have seen strings as a sequence of characters stored in double quotes, e.g., \"hello!\". Note how we distinguish between a string and a char by the quotes used. String uses double quotes \" ; a char uses a single quote ' . In C, a string is nothing more than just an array of char values. The only thing special about a string is that it always end with a 0 value (note: not character '0' which has a value of 48, but the value 0). Since the character with value 0 is called the null character, written as '\\0' , we refer to that strings in C as null-terminated strings. The following two ways of initializing a string is thus equivalent: 1 2 char hello1 [ 7 ] = { 'h' , 'e' , 'l' , 'l' , 'o' , '!' , '\\0' }; char hello2 [ 7 ] = \"hello!\" ; The second way is more easily readable. We can also skip the size of the array, as mentioned above, or, more commonly, use a char * type for a variable storing a constant string. 1 2 char hello3 [] = \"hello!\" ; char * hello4 = \"hello!\" ;","title":"String"},{"location":"18-string.html#string-literals","text":"A string literal refers to a string written between two \" characters, such as \"Hello world!\" . Such a string is still internally stored as an array of char values. The location these arrays are stored depends on the platform, but usually, they are stored in a read-only region of the memory called the text region. These strings are not meant to be modified. Hence, trying something like this: 1 2 char * str1 = \"Hello!\" ; str1 [ 5 ] = '.' ; is not allowed and would crash your program. The following, however, is OK: 1 2 char str2 [ 7 ] = \"Hello!\" ; str2 [ 5 ] = '.' ; The difference between the two is that str1 points to a read-only region in the memory, while str2 contains a copy of the string on the stack.","title":"String Literals"},{"location":"18-string.html#empty-string","text":"We commonly use the empty string \"\" to indicate a special condition or to initialize a string variable, where appropriate. The empty string is nothing but an array where the 0-th element is '\\0'.","title":"Empty String"},{"location":"18-string.html#common-bugs","text":"A very common bug for beginners to C programming is to forget about the terminating '\\0' char in a string. For instance, suppose you want to copy one string to another: 1 2 3 4 5 char src [ 6 ] = \"hello!\" char dst [ 6 ]; for ( long i = 0 ; i < 6 ; i += 1 ) { dst [ i ] = src [ i ]; } The string variable dst is not terminated and C would treat whatever follows the memory location as part of the string! The other common bug is to create an array that is too small for the string. Suppose you use the function strcpy provided by C to copy the string instead. 1 2 3 char src [ 6 ] = \"hello!\" char dst [ 6 ]; strcpy ( dst , src ); strcpy would properly copy the characters 'h' , 'e' , .. '!' , AND the terminating '\\0' . That's a total of 7 characters. The code, however, only allocated the space of 6 characters for dst . So overflow occurs and your program might crash. So, remember to always account for the \"invincible friend\" at the end of every string, and leave a space for it.","title":"Common Bugs"},{"location":"18-string.html#cs1010-io-library","text":"The CS1010 I/O library provides two functions, one to read a word (separated by white-space characters) and the other to read a line (separated by a newline character). They are cs1010_read_word() and cs1010_read_line() respectively. We can also read multiple words and multiple lines with cs1010_read_word_array() and cs1010_read_line_array() . The results are stored in an array of strings. The arrays and strings returned by these functions need to be deallocated by the caller. Particularly, note that when an array of strings are returned by both cs1010_read_word_array() and cs1010_read_line_array() , the strings and the array holding the strings all need to be freed. A typical usage is as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 size_t k = cs1010_read_size_t (); char ** lines = cs1010_read_line_array ( k ); if ( lines == NULL ) { // Deal with error return ; } // Do something with array lines : : for ( size_t i = 0 ; i < k ; i += 1 ) { free ( lines [ i ]); } free ( lines );","title":"CS1010 I/O Library"},{"location":"1819s1.html","text":"CS1010 from AY2018/19 Semester 1 Here are some information and materials from the offering of CS1010 in AY 2018/19 Semester 1. Student Feedback Midterm Final (Questions only) Final (w Answers) PE 1 PE 2 Lecture Slides Screencast 1 2 3 4 5 6 7 8 9 10 11 12 Note: Screencasts are password protected.","title":"18/19 Semester 1"},{"location":"1819s1.html#cs1010-from-ay201819-semester-1","text":"Here are some information and materials from the offering of CS1010 in AY 2018/19 Semester 1.","title":"CS1010 from AY2018/19 Semester 1"},{"location":"1819s1.html#student-feedback","text":"","title":"Student Feedback"},{"location":"1819s1.html#midterm","text":"","title":"Midterm"},{"location":"1819s1.html#final-questions-only","text":"","title":"Final (Questions only)"},{"location":"1819s1.html#final-w-answers","text":"","title":"Final (w Answers)"},{"location":"1819s1.html#pe-1","text":"","title":"PE 1"},{"location":"1819s1.html#pe-2","text":"Lecture Slides Screencast 1 2 3 4 5 6 7 8 9 10 11 12 Note: Screencasts are password protected.","title":"PE 2"},{"location":"19-md-array.html","text":"Unit 19: Multi-Dimensional Arrays Learning Objectives After completing this unit, students should: be comfortable reading and writing code that involves multi-dimensional arrays be able to declare and allocate multi-dimensional arrays on the stack and the heap be able to decide when to use a fixed-size multi-dimensional array, a dynamically-sized multi-dimensional array, or a mixture of the two understand how we can pass a multi-dimensional array into a function understand the differences in C syntax, between an array of pointers and a pointer to an array. be able to declare and allocate jagged arrays Fixed-size 2D Array At the beginning of Unit 14, we say that an array can hold one or more values of some type \\(T\\) . \\(T\\) can be any type, including an array! So, we can have an array where each element is another array. For instance, 1 long matrix [ 10 ][ 20 ]; Here, we have an array of 10 elements, and each element is an array of 20 long values. When we access the elements in the array, we can use the notation matrix[i][j] . This notation is actually a simpler form of (matrix[i])[j] -- matrix[i] refers the i+1 -th element in matrix , which is an array of 20 elements. So (matrix[i])[j] accesses the j+1 -th element in this array of 20 elements. Such an array is called a two-dimensional array, or 2D array. We can have a 3D array, 4D array, and so on. We have seen three types of arrays. On the stack, we have fixed-length arrays and variable-length arrays. On the heap, we have dynamically allocated arrays. A 2D array can mix different types of arrays. Since we ban the use of variable length arrays, we will focus on fixed-length arrays and dynamically allocated arrays only. The example matrix above is a fixed-length 2D array. In the memory, a continuous space to store 200 long values is been allocated. We can visualize this as having 10 rows of long array, each array contains 20 columns of long values. Since matrix[i] is an array in the example above, matrix[i] decays to &matrix[i][0] , the address of the first element in matrix[i]. After decay, matrix[i] can be treated as having the type long * . Further, since matrix[i] is a 1D array, we can pass matrix[i] , which is one of the rows in matrix , just like a normal 1D array: 1 2 3 void bar ( size_t num_of_cols , long matrix_row [ num_of_cols ]) { .. } void bar ( size_t num_of_cols , long matrix_row []) { .. } void bar ( size_t num_of_cols , long * matrix_row ) { .. } We can then invoke the function bar like: 1 bar ( 20 , matrix [ i ]); Things get a bit tricky when we want to pass a 2D array into a function. By array decay, when we use the array name matrix , it is equivalent to &matrix[0] , which is the address of the first element in matrix , which is the memory address of an array of 20 long elements. Pointer to Array Since an array in C consists only of a contiguous region of memory that stores the elements of the array, the address of an array is the same as the address of the first element of the array. The following five statements would print out exactly the same values. 1 2 3 4 5 cs1010_println_pointer ( matrix ); cs1010_println_pointer ( matrix [ 0 ]); cs1010_println_pointer ( & matrix ); cs1010_println_pointer ( & matrix [ 0 ]); cs1010_println_pointer ( & matrix [ 0 ][ 0 ]); We have seen that matrix[0] and &matrix[0][0] both are memory addresses of a long value. The variable matrix and &matrix[0] , however, have the type memory address of a long array . To declare a variable a that is the memory address of an array, we write: 1 long ( * a )[ 20 ]; We can understand this as follows: (*a) is an array of 20 long values. * is the deference operator to an address, so a must then be a memory address of an array of 20 long values. C is very particular about the type of an array. An array of 20 long values is different from an array of 19 long values. Trying to point a pointer to an array of 20 long elements to an array of 19 long elements would lead to error: 1 2 3 4 5 long x [ 19 ]; long y [ 20 ]; long ( * a )[ 20 ]; a = & x ; // error a = & y ; // ok In other words, the size of a fixed-size array is part of the type information. To pass a 2D array into a function, say foo , we can write 1 2 3 4 void foo ( size_t num_of_rows , size_t num_of_cols , long matrix_row [ num_of_rows ][ 20 ]) { .. } void foo ( size_t num_of_rows , size_t num_of_cols , long matrix_row [ 10 ][ 20 ]]) { .. } void foo ( size_t num_of_rows , size_t num_of_cols , long matrix_row [][ 20 ]]) { .. } void foo ( size_t num_of_rows , size_t num_of_cols , long ( * matrix_row )[ 20 ]) { .. } Here, we cannot omit the number 20 since it is part of the type information. With the declaration above, we can then call the function foo and pass in the 2D array as such: 1 foo ( 10 , 20 , matrix ); Note that the position of the parentheses when we declare a variable that is a pointer to an array is important and is not optional. If we write it as either: 1 2 long * a [ 20 ]; long * ( a [ 20 ]); then we are declaring a as an array of 20 pointers to long instead! We will see such declaration in use in the next section. Fixed Size Array of Dynamically Allocated Array Suppose that we know only one of the dimensions of the array in advance, but not the other dimension. We can allocate a fixed-length array for the known dimension, and allocate the other dimension dynamically using calloc . We can declare an array like this: 1 2 3 4 5 double * buckets [ 10 ]; size_t num_of_cols = cs1010_read_size_t (); for ( long i = 0 ; i < 10 ; i += 1 ) { buckets [ i ] = calloc ( num_of_cols , sizeof ( double )); } Here, bucket is a 1D array of 10 pointers to double . So, we can easily pass bucket to a function just like any other 1D array: void baz(size_t num_of_rows, size_t num_of_cols, double **bucket) void baz(size_t num_of_rows, size_t num_of_cols, double *bucket[]) void baz(size_t num_of_rows, size_t num_of_cols, double *bucket[num_of_cols]) Accessing individual elements in such type of array is no different from accessing a fixed-length 2D array: we use bucket[i][j] . Just like a dynamically allocated 1D array, we need to free the allocated memory after we are done: 1 2 3 for ( size_t i = 0 ; i < 10 ; i += 1 ) { free ( buckets [ i ]); } Dealing with Allocation Failures Just like a dynamically allocated 1D array, we need to deal with the possibility that memory allocation can fail. To do this, we need to check if each calloc is successful or not. In case one of the memory allocations fails, then we would have a partially allocated 2D array. We will need to deallocate all those partially allocated memory with free . 1 2 3 4 5 6 7 8 9 10 11 12 double * buckets [ 10 ]; size_t num_of_cols = cs1010_read_size_t (); for ( size_t i = 0 ; i < 10 ; i += 1 ) { buckets [ i ] = calloc ( num_of_cols , sizeof ( double )); if ( buckets [ i ] == NULL ) { cs1010_println_string ( \"unable to allocate array\" ); for ( size_t j = 0 ; j < i ; j += 1 ) { free ( buckets [ j ]); } return 1 ; } } An alternative is to allocate a single contiguous region of memory with a single calloc call, and then point the pointers in our array in the right memory location. 1 2 3 4 5 6 7 8 9 10 double * buckets [ 10 ]; size_t num_of_cols = cs1010_read_size_t (); buckets [ 0 ] = calloc ( num_of_cols * 10 , sizeof ( double )); if ( buckets [ 0 ] == NULL ) { cs1010_println_string ( \"unable to allocate array\" ); return 1 ; } for ( size_t i = 1 ; i < 10 ; i += 1 ) { buckets [ i ] = buckets [ i - 1 ] + num_of_cols ; } Dynamically Size 2D Array Suppose that we do not know both dimensions in advance, then we can allocate both dimensions of the array dynamically on the heap. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 double ** canvas ; size_t num_of_rows = cs1010_read_size_t (); size_t num_of_cols = cs1010_read_size_t (); canvas = calloc ( num_of_rows , sizeof ( double * )); // note the call to sizeof for ( size_t i = 0 ; i < num_of_rows ; i += 1 ) { canvas [ i ] = calloc ( num_of_cols , sizeof ( double )); if ( canvas [ i ] == NULL ) { cs1010_println_string ( \"unable to allocate array\" ); for ( size_t j = 0 ; j < i ; j += 1 ) { free ( canvas [ j ]); } free ( canvas ); } } Passing such an array into a function is no different from a 2D array where only one dimension is dynamically allocated above. Remember to free the allocated memory for both dimensions after we are done, as well as if one of the rows encounters an error. 1 2 3 4 for ( size_t i = 0 ; size_t i < num_of_rows ; i += 1 ) { free ( canvas [ i ]); } free ( canvas ); Note that during the deallocation of memory, we need to do it in the reverse order of memory allocation. If we call free(canvas) first, we are no longer guaranteed to be able to access canvas[i] with the correct pointers inside, so calling free(canvas[i]) after free(canvas) might lead to an error. Just like before, there is an alternative where we can also allocate a single contiguous region of memory with a single calloc call, and then point the pointers in our array in the right memory location. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 double ** canvas ; size_t num_of_rows = cs1010_read_size_t (); size_t num_of_cols = cs1010_read_size_t (); canvas = calloc ( num_of_rows , sizeof ( double * )); if ( canvas == NULL ) { cs1010_println_string ( \"unable to allocate memory\" ); return 1 ; } canvas [ 0 ] = calloc ( num_of_rows * num_of_cols , sizeof ( double )); if ( canvas [ 0 ] == NULL ) { cs1010_println_string ( \"unable to allocate memory\" ); free ( canvas ); return 1 ; } for ( size_t i = 1 ; i < num_of_rows ; i += 1 ) { canvas [ i ] = canvas [ i -1 ] + num_of_cols ; } If we allocate a single contiguous region of memory for canvas , then we only need to free(canvas[0]) and free(canvas) once we are done. Jagged Array One advantage of using a dynamically allocated array is that it allows a jagged 2D array, where each row has a different size. The example below allocate memory for a 2D array that is shaped like a half-square: the first row has one element, the second row has two elements, the third row has three, and so on. 1 2 3 4 double * half_square [ 10 ]; for ( size_t i = 0 ; i < 10 ; i += 1 ) { half_square [ i ] = calloc ( i + 1 , sizeof ( double )); } Initializing a Multidimensional Array Just like a 1D-array, we can initialize a multi-dimensional array with initializers during declaration: 1 2 3 4 5 long matrix [ 3 ][ 3 ] = { { 1 , 0 , -1 }, { -1 , 1 , 0 }, { 0 , -1 , 1 } }; Note that we use nested { and } here. There are other variations to the syntax above, which you may read up on your own if you are interested as we do not need to write complex initializers for multi-dimensional arrays that often. Problem Set Problem 19.1 Suppose we have a 2D array 1 2 3 4 long m [ 3 ][ 3 ]; long * n = & m [ 0 ][ 0 ]; m [ 0 ][ 3 ] = 3 ; // warning n [ 3 ] = 10 ; Suppose we ignore the compile warning generated by the code above and execute the program anyway. Explain what happens when Line 3 and Line 4 are executed. Problem 19.2 We need to represent the distance in km between every major city in the world. Let's label every city with a number, ranging from 0 .. \\(n-1\\) , where \\(n\\) is the number of cities. The distance between city \\(i\\) and \\(j\\) is the same as the distance between city \\(j\\) and \\(i\\) . The distance can be represented with long . Explain how you would represent this information using a jagged two-dimensional array in C efficiently. We have information about a few thousand cities to store. Explain how you would write a function long dist(long **d, long i, long j) to retrieve the distance between any two cities \\(i\\) and \\(j\\) .","title":"19. ND Array"},{"location":"19-md-array.html#unit-19-multi-dimensional-arrays","text":"","title":"Unit 19: Multi-Dimensional Arrays"},{"location":"19-md-array.html#learning-objectives","text":"After completing this unit, students should: be comfortable reading and writing code that involves multi-dimensional arrays be able to declare and allocate multi-dimensional arrays on the stack and the heap be able to decide when to use a fixed-size multi-dimensional array, a dynamically-sized multi-dimensional array, or a mixture of the two understand how we can pass a multi-dimensional array into a function understand the differences in C syntax, between an array of pointers and a pointer to an array. be able to declare and allocate jagged arrays","title":"Learning Objectives"},{"location":"19-md-array.html#fixed-size-2d-array","text":"At the beginning of Unit 14, we say that an array can hold one or more values of some type \\(T\\) . \\(T\\) can be any type, including an array! So, we can have an array where each element is another array. For instance, 1 long matrix [ 10 ][ 20 ]; Here, we have an array of 10 elements, and each element is an array of 20 long values. When we access the elements in the array, we can use the notation matrix[i][j] . This notation is actually a simpler form of (matrix[i])[j] -- matrix[i] refers the i+1 -th element in matrix , which is an array of 20 elements. So (matrix[i])[j] accesses the j+1 -th element in this array of 20 elements. Such an array is called a two-dimensional array, or 2D array. We can have a 3D array, 4D array, and so on. We have seen three types of arrays. On the stack, we have fixed-length arrays and variable-length arrays. On the heap, we have dynamically allocated arrays. A 2D array can mix different types of arrays. Since we ban the use of variable length arrays, we will focus on fixed-length arrays and dynamically allocated arrays only. The example matrix above is a fixed-length 2D array. In the memory, a continuous space to store 200 long values is been allocated. We can visualize this as having 10 rows of long array, each array contains 20 columns of long values. Since matrix[i] is an array in the example above, matrix[i] decays to &matrix[i][0] , the address of the first element in matrix[i]. After decay, matrix[i] can be treated as having the type long * . Further, since matrix[i] is a 1D array, we can pass matrix[i] , which is one of the rows in matrix , just like a normal 1D array: 1 2 3 void bar ( size_t num_of_cols , long matrix_row [ num_of_cols ]) { .. } void bar ( size_t num_of_cols , long matrix_row []) { .. } void bar ( size_t num_of_cols , long * matrix_row ) { .. } We can then invoke the function bar like: 1 bar ( 20 , matrix [ i ]); Things get a bit tricky when we want to pass a 2D array into a function. By array decay, when we use the array name matrix , it is equivalent to &matrix[0] , which is the address of the first element in matrix , which is the memory address of an array of 20 long elements.","title":"Fixed-size 2D Array"},{"location":"19-md-array.html#pointer-to-array","text":"Since an array in C consists only of a contiguous region of memory that stores the elements of the array, the address of an array is the same as the address of the first element of the array. The following five statements would print out exactly the same values. 1 2 3 4 5 cs1010_println_pointer ( matrix ); cs1010_println_pointer ( matrix [ 0 ]); cs1010_println_pointer ( & matrix ); cs1010_println_pointer ( & matrix [ 0 ]); cs1010_println_pointer ( & matrix [ 0 ][ 0 ]); We have seen that matrix[0] and &matrix[0][0] both are memory addresses of a long value. The variable matrix and &matrix[0] , however, have the type memory address of a long array . To declare a variable a that is the memory address of an array, we write: 1 long ( * a )[ 20 ]; We can understand this as follows: (*a) is an array of 20 long values. * is the deference operator to an address, so a must then be a memory address of an array of 20 long values. C is very particular about the type of an array. An array of 20 long values is different from an array of 19 long values. Trying to point a pointer to an array of 20 long elements to an array of 19 long elements would lead to error: 1 2 3 4 5 long x [ 19 ]; long y [ 20 ]; long ( * a )[ 20 ]; a = & x ; // error a = & y ; // ok In other words, the size of a fixed-size array is part of the type information. To pass a 2D array into a function, say foo , we can write 1 2 3 4 void foo ( size_t num_of_rows , size_t num_of_cols , long matrix_row [ num_of_rows ][ 20 ]) { .. } void foo ( size_t num_of_rows , size_t num_of_cols , long matrix_row [ 10 ][ 20 ]]) { .. } void foo ( size_t num_of_rows , size_t num_of_cols , long matrix_row [][ 20 ]]) { .. } void foo ( size_t num_of_rows , size_t num_of_cols , long ( * matrix_row )[ 20 ]) { .. } Here, we cannot omit the number 20 since it is part of the type information. With the declaration above, we can then call the function foo and pass in the 2D array as such: 1 foo ( 10 , 20 , matrix ); Note that the position of the parentheses when we declare a variable that is a pointer to an array is important and is not optional. If we write it as either: 1 2 long * a [ 20 ]; long * ( a [ 20 ]); then we are declaring a as an array of 20 pointers to long instead! We will see such declaration in use in the next section.","title":"Pointer to Array"},{"location":"19-md-array.html#fixed-size-array-of-dynamically-allocated-array","text":"Suppose that we know only one of the dimensions of the array in advance, but not the other dimension. We can allocate a fixed-length array for the known dimension, and allocate the other dimension dynamically using calloc . We can declare an array like this: 1 2 3 4 5 double * buckets [ 10 ]; size_t num_of_cols = cs1010_read_size_t (); for ( long i = 0 ; i < 10 ; i += 1 ) { buckets [ i ] = calloc ( num_of_cols , sizeof ( double )); } Here, bucket is a 1D array of 10 pointers to double . So, we can easily pass bucket to a function just like any other 1D array: void baz(size_t num_of_rows, size_t num_of_cols, double **bucket) void baz(size_t num_of_rows, size_t num_of_cols, double *bucket[]) void baz(size_t num_of_rows, size_t num_of_cols, double *bucket[num_of_cols]) Accessing individual elements in such type of array is no different from accessing a fixed-length 2D array: we use bucket[i][j] . Just like a dynamically allocated 1D array, we need to free the allocated memory after we are done: 1 2 3 for ( size_t i = 0 ; i < 10 ; i += 1 ) { free ( buckets [ i ]); }","title":"Fixed Size Array of Dynamically Allocated Array"},{"location":"19-md-array.html#dealing-with-allocation-failures","text":"Just like a dynamically allocated 1D array, we need to deal with the possibility that memory allocation can fail. To do this, we need to check if each calloc is successful or not. In case one of the memory allocations fails, then we would have a partially allocated 2D array. We will need to deallocate all those partially allocated memory with free . 1 2 3 4 5 6 7 8 9 10 11 12 double * buckets [ 10 ]; size_t num_of_cols = cs1010_read_size_t (); for ( size_t i = 0 ; i < 10 ; i += 1 ) { buckets [ i ] = calloc ( num_of_cols , sizeof ( double )); if ( buckets [ i ] == NULL ) { cs1010_println_string ( \"unable to allocate array\" ); for ( size_t j = 0 ; j < i ; j += 1 ) { free ( buckets [ j ]); } return 1 ; } } An alternative is to allocate a single contiguous region of memory with a single calloc call, and then point the pointers in our array in the right memory location. 1 2 3 4 5 6 7 8 9 10 double * buckets [ 10 ]; size_t num_of_cols = cs1010_read_size_t (); buckets [ 0 ] = calloc ( num_of_cols * 10 , sizeof ( double )); if ( buckets [ 0 ] == NULL ) { cs1010_println_string ( \"unable to allocate array\" ); return 1 ; } for ( size_t i = 1 ; i < 10 ; i += 1 ) { buckets [ i ] = buckets [ i - 1 ] + num_of_cols ; }","title":"Dealing with Allocation Failures"},{"location":"19-md-array.html#dynamically-size-2d-array","text":"Suppose that we do not know both dimensions in advance, then we can allocate both dimensions of the array dynamically on the heap. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 double ** canvas ; size_t num_of_rows = cs1010_read_size_t (); size_t num_of_cols = cs1010_read_size_t (); canvas = calloc ( num_of_rows , sizeof ( double * )); // note the call to sizeof for ( size_t i = 0 ; i < num_of_rows ; i += 1 ) { canvas [ i ] = calloc ( num_of_cols , sizeof ( double )); if ( canvas [ i ] == NULL ) { cs1010_println_string ( \"unable to allocate array\" ); for ( size_t j = 0 ; j < i ; j += 1 ) { free ( canvas [ j ]); } free ( canvas ); } } Passing such an array into a function is no different from a 2D array where only one dimension is dynamically allocated above. Remember to free the allocated memory for both dimensions after we are done, as well as if one of the rows encounters an error. 1 2 3 4 for ( size_t i = 0 ; size_t i < num_of_rows ; i += 1 ) { free ( canvas [ i ]); } free ( canvas ); Note that during the deallocation of memory, we need to do it in the reverse order of memory allocation. If we call free(canvas) first, we are no longer guaranteed to be able to access canvas[i] with the correct pointers inside, so calling free(canvas[i]) after free(canvas) might lead to an error. Just like before, there is an alternative where we can also allocate a single contiguous region of memory with a single calloc call, and then point the pointers in our array in the right memory location. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 double ** canvas ; size_t num_of_rows = cs1010_read_size_t (); size_t num_of_cols = cs1010_read_size_t (); canvas = calloc ( num_of_rows , sizeof ( double * )); if ( canvas == NULL ) { cs1010_println_string ( \"unable to allocate memory\" ); return 1 ; } canvas [ 0 ] = calloc ( num_of_rows * num_of_cols , sizeof ( double )); if ( canvas [ 0 ] == NULL ) { cs1010_println_string ( \"unable to allocate memory\" ); free ( canvas ); return 1 ; } for ( size_t i = 1 ; i < num_of_rows ; i += 1 ) { canvas [ i ] = canvas [ i -1 ] + num_of_cols ; } If we allocate a single contiguous region of memory for canvas , then we only need to free(canvas[0]) and free(canvas) once we are done.","title":"Dynamically Size 2D Array"},{"location":"19-md-array.html#jagged-array","text":"One advantage of using a dynamically allocated array is that it allows a jagged 2D array, where each row has a different size. The example below allocate memory for a 2D array that is shaped like a half-square: the first row has one element, the second row has two elements, the third row has three, and so on. 1 2 3 4 double * half_square [ 10 ]; for ( size_t i = 0 ; i < 10 ; i += 1 ) { half_square [ i ] = calloc ( i + 1 , sizeof ( double )); }","title":"Jagged Array"},{"location":"19-md-array.html#initializing-a-multidimensional-array","text":"Just like a 1D-array, we can initialize a multi-dimensional array with initializers during declaration: 1 2 3 4 5 long matrix [ 3 ][ 3 ] = { { 1 , 0 , -1 }, { -1 , 1 , 0 }, { 0 , -1 , 1 } }; Note that we use nested { and } here. There are other variations to the syntax above, which you may read up on your own if you are interested as we do not need to write complex initializers for multi-dimensional arrays that often.","title":"Initializing a Multidimensional Array"},{"location":"19-md-array.html#problem-set","text":"","title":"Problem Set"},{"location":"19-md-array.html#problem-191","text":"Suppose we have a 2D array 1 2 3 4 long m [ 3 ][ 3 ]; long * n = & m [ 0 ][ 0 ]; m [ 0 ][ 3 ] = 3 ; // warning n [ 3 ] = 10 ; Suppose we ignore the compile warning generated by the code above and execute the program anyway. Explain what happens when Line 3 and Line 4 are executed.","title":"Problem 19.1"},{"location":"19-md-array.html#problem-192","text":"We need to represent the distance in km between every major city in the world. Let's label every city with a number, ranging from 0 .. \\(n-1\\) , where \\(n\\) is the number of cities. The distance between city \\(i\\) and \\(j\\) is the same as the distance between city \\(j\\) and \\(i\\) . The distance can be represented with long . Explain how you would represent this information using a jagged two-dimensional array in C efficiently. We have information about a few thousand cities to store. Explain how you would write a function long dist(long **d, long i, long j) to retrieve the distance between any two cities \\(i\\) and \\(j\\) .","title":"Problem 19.2"},{"location":"20-macro.html","text":"Unit 20: C Preprocessor: Constants and Macros Learning Objectives After this unit, students should: understand how the preprocessing step in the compilation pipeline works understand how #include statements work understand why we should avoid hard-coding magic constants and start having the habit of using #define to define constants in their code. understand how #define can be used to define macros be able to explain the differences between macros and functions be able to write macros in a way that avoid the common pitfalls Revisiting C Compilation Process In this unit, we are going to delve deeper into the C compilation process, focusing on a step called pre-processing . This step is usually the first step in the compilation process. In the first lecture, we lumped this process under compile (etc) in the figure below. We can now separate one of the steps under \"etc\" as the pre-processing step, Preprocessing Preprocessing is, in essence, a text processing and substitution process, and so it is not specific to C. In C, this process is used to implement, among other things: (i) file inclusion, (ii) macro, and (iii) conditional compilation. A C pre-processor processes all the lines in the input file that start with a # character. Any line that starts with # is a preprocessor directive . You have seen two of such directives, #include to include a file, and #define to define a constant. #include The #include directive has the format 1 #include <filename> or 1 #include \"filename\" When the C pre-processor sees this directive, it reads the file specified by the given filename, and inserts the text, line-by-line, from this file, into the current file, in the location where the line #include occurs. Any C preprocessor directive in the included file is recursively processed. #define Constant We have seen how we can use #define to define constant values in our code in our exercises and assignments. For instance, in Exercise 2, rectangle.c , you have seen: 1 2 3 4 5 6 #define TOP_LEFT \"\u2554\" #define TOP_RIGHT \"\u2557\" #define BOTTOM_RIGHT \"\u255d\" #define BOTTOM_LEFT \"\u255a\" #define HORIZONTAL \"\u2550\" #define VERTICAL \"\u2551\" What is the advantage of using TOP_LEFT (which is 8 characters) instead of just one character \u2554 ? It is a good programming practice to avoid hardcoding constant values (also called magic constants ) in our code so that our code can be easily changed when the requirement of our program has changed. Defining these constants as #define allows us to easily modify our program. For instance, suppose that we wish to change the way we draw the rectangle. Instead of 1 2 3 4 5 6 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d We wish to draw it like this: 1 2 3 4 5 6 +--------+ | | | | | | | | +--------+ All we have to do is to change the defined constants: 1 2 3 4 5 6 #define TOP_LEFT \"+\" #define TOP_RIGHT \"+\" #define BOTTOM_RIGHT \"+\" #define BOTTOM_LEFT \"+\" #define HORIZONTAL \"-\" #define VERTICAL \"|\" We do not have to make any changes to the code to draw the rectangles! This reduces the chances that you introduce bugs into the code. Let's consider the second example, taxi.c from Assignment 1: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 double metered_fare ( long distance ) { double fare = 3.20 ; // The first 1 km or less if ( distance <= 1000 ) { return fare ; } distance -= 1000 ; if ( distance <= 9000 ) { fare += 0.22 * lceil ( distance , 400 ); return fare ; } // more than 10km // 0.22 * ceil(9000 / 400) = 0.22*23 = 5.06 fare += 5.06 ; distance -= 9000 ; fare += 0.22 * lceil ( distance , 350 ); return fare ; } In the snippet above, there are many hard-coded values. Suppose one day, the taxi fare changes (and that day will come). Perhaps the base fare is more, perhaps the distance threshold is shorter. We will have to change the code above to calculate the new fare. By littering the code above with hardcoded values, the code is difficult and error-prone to change. You might think that we can just search and replace to update the code when the fare changes. But this is error-prone as well! Suppose that the taxi fare increases to $0.25 per 350m after 10km, but remains $0.22 between 1 - 10km, then we cannot just replace every occurrence of 0.22 with 0.25 . We can make our code \"future-ready\" by abstracting out all the magic numbers and define constants for each of them. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #define BASE_FARE 3.20 #define BASE_DISTANCE 1000 #define TIER_ONE_FARE 0.22 #define TIER_ONE_DISTANCE 400 #define TIER_ONE_LIMIT 10000 #define TIER_TWO_FARE 0.22 #define TIER_TWO_DISTANCE 350 double metered_fare ( long distance ) { double fare = BASE_FARE ; distance -= BASE_DISTANCE ; if ( distance <= 0 ) { return fare ; } if ( distance <= TIER_ONE_LIMIT ) { fare += TIER_ONE_FARE * lceil ( distance , TIER_ONE_DISTANCE ); } else { fare += TIER_ONE_FARE * ( TIER_ONE_LIMIT / TIER_ONE_DISTANCE ); } distance -= TIER_ONE_LIMIT ; if ( distance <= 0 ) { return fare ; } fare += TIER_TWO_FARE * lceil ( distance , TIER_TWO_DISTANCE ); return fare ; } Replacing the magic numbers with constants make the code a bit harder to read, but now, it is super easy to change. Suppose, one day, the base taxi fare is increased to $3.40, and then $0.20 per 500m subsequently up to 10km, and $0.15 per 600m thereafter, we only need to change: 1 2 3 4 5 6 7 #define BASE_FARE 3.40 #define BASE_DISTANCE 1000 #define TIER_ONE_FARE 0.20 #define TIER_ONE_DISTANCE 500 #define TIER_ONE_LIMIT 10000 #define TIER_TWO_FARE 0.15 #define TIER_TWO_DISTANCE 600 The logic of the code remains the same. How does the C pre-processor process the #define directive? When we write a #define directive, the directive should be followed by an identifier and a token . The token may contain space but must be terminated by a newline . In the example above, BASE_FARE is the identifier, and 3.40 is the token. When the C pre-processor sees the #define directive, it replaces all instances of the identifier in the file with the token. This is merely a text substitution operation. The #include Directive Another commonly used directive is #include . You have seen how we used this to \"import\" the cs1010.h , stdbool.h , math.h , etc. When we introduced this at the beginning of the lecture, we compared this to the import require , use commands seen in other programming languages. But the mechanism for #include is very different from the others. The #include directive merely performs text substitution -- it recursively reads the lines from the included file and inserts them into the location where the #include directive is. Consider the example below. Suppose we have three files: 1 2 3 4 5 6 7 8 9 10 /** * @file: a.c */ #include \"b.h\" int main () { foo ( PI ); } 1 2 3 4 5 6 /** * @file: b.h */ #include \"c.h\" #define PI 3.1415926 1 2 3 4 5 /** * @file: c.h */ void foo ( double x ); Let's see what happens when we run C pre-processor on the file a.c . We can ask clang to stop the compilation process after the pre-processing phase, using the flag -E 1 . 1 clang -E a.c The command will produce the output after C pre-processing: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 1 \"a.c\" # 1 \"<built-in>\" 1 # 1 \"<built-in>\" 3 # 360 \"<built-in>\" 3 # 1 \"<command line>\" 1 # 1 \"<built-in>\" 2 # 1 \"a.c\" 2 # 1 \"./b.h\" 1 # 1 \"./c.h\" 1 void foo ( double x ); # 6 \"./b.h\" 2 # 5 \"a.c\" 2 int main () { foo ( 3.1415926 ); } The lines that start with # are metadata meant for the compiler. If we ignore those, we can see that the file a.c has been expanded into 1 2 3 4 5 void foo ( double x ); int main () { foo ( 3.1415926 ); } Line 1 above is included from file c.h , which in turn is included from file b.h . The C pre-processor also substitutes the text PI with the text 3.1415926 , as the identifier PI is defined in b.h . In C, we usually use #include to share common function declarations and constants. #define Macro The #define directive can be used for a more flexible and powerful text substitution feature called macro . A macro is a block of code that is given an identifying name and is substituted and expanded during pre-processing. For instance, we can write the following: 1 #define SQUARE(x) x*x This macro is named SQUARE , just like a function we defined in Lecture 3 and it takes in a parameter x as well. But that's where the similarity ends. There are a few important differences between macros and functions in C: Macros are not called. They are only substituted during the preprocessing phase which performs text processing on the source code. Macros have no information about types. It has no return type and the parameters have no type. Take the example below. The file: 1 2 3 4 5 6 7 #define SQUARE(x) x*x #define PI 3.1415926 int main () { double radius = 4.0 ; cs1010_print_double ( PI * SQUARE ( radius )); } Get expanded into: 1 2 3 4 5 int main () { double radius = 4.0 ; cs1010_print_double ( 3.1415926 * radius * radius ); } Let's look at another example. We have seen how to write a function that swaps two of the value of variables. The one we wrote swaps two double . If we want to swap two long , or two char * , etc, we will need to write a new function for each one. Let's write a generic macro that does swapping for any type. 1 2 3 4 5 6 7 8 9 10 11 12 13 #define SWAP(T, x, y) {\\ T temp;\\ temp = x;\\ x = y;\\ y = temp;\\ } int main () { long x = 3.0 ; long y = -1.0 ; SWAP ( long , x , y ); } The macro SWAP takes in three parameters, the first is the type T, the second and the third are the variables to be swapped. This macro definition spans multiple lines. Since C preprocessor ends the definition of a macro with the end of the line, we add a backslash character to \"escape\" the newline, telling the preprocessor not to treat the newline as the end of the macro definition. The code above gets expanded to: 1 2 3 4 5 6 int main () { long x = 3.0 ; long y = -1.0 ; { long temp ; temp = x ; x = y ; y = temp ;}; } You might be bothered by the appearance of { and } on Line 5. But note that this is perfectly valid syntax. Recall that we said { and } defines a block, while we commonly define a block in the context of a function body, if , else , for , etc. We can define a block anywhere in C. The reason why it is necessary to place the substituted text within a block is left as an exercise (Problem 20.2). Pitfalls and Best Practices It is easy to forget that macro is doing simple text substitution without an understanding of C syntax. When we write macros, we should always guard against improper usage of macros. Let's consider this: 1 #define SQUARE(x) x*x 1 SQUARE ( radius + 2 ) When the pre-processor substitutes the macro SQUARE , it replaces all instances of the text x with the text radius + 2 . After substitution, we get radius + 2*radius + 2 ! This is not what we expected. To prevent such unexpected expansion, we should always add parenthesis to our macro expression: 1 #define SQUARE(x) ((x)*(x)) So now, 1 SQUARE(radius + 2) gets expanded into ((radius + 2)*(radius + 2)) , which is what we would expect when we call SQUARE . To help the readers of your code know that you are referencing a macro rather than a function, all macros should be written with uppercase letters. The assert macros You have learned what an assertion is and how it can help you to reason about your programs. Previously we have only seen the use of an assertion as a commenting tool, to comment on certain properties that are guaranteed to be true at a certain point of a program. Now, we will make the concept of assertion even more powerful -- we can cause our program to throw an error if an assertion is ever violated. This way, we can tell immediately if certain assumptions or properties that we made in our code are violated. C provides a macro called assert() (in the header file assert.h ) which takes in a logical expression. This logical expression must always evaluate to true when assert is used. Otherwise, assert will throw an error, giving the file and the line number where the error occurred. Using assertions and the assert macro can help us pinpoint exactly where our code goes wrong, quickly. Take the following code for is_prime , for instance: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * Test if a number is prime or not. * * @pre n > 1 * @param[in] n The number to test if is prime * @return true if n is prime, false otherwise */ bool is_prime ( long n ) { for ( long i = 2 ; i <= sqrt ( n ); i += 1 ) { if ( n % i == 0 ) { return false ; } } return true ; } The code has a precondition that n is larger than 1. If n is 1, the function would return true, which is incorrect since 1 is not a prime. The writer of this function intended that this function should be called with n larger than 1 only. But we don't have control over how others call our function and if someone missed the pre-condition and call is_prime with n = 1, we will have a buggy program. One way to prevent this is to use the assert macro, and add an assert statement like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * Test if a number is prime or not. * * @pre n > 1 * @param[in] n The number to test if is prime * @return true if n is prime, false otherwise */ bool is_prime ( long n ) { assert ( n > 1 ); for ( long i = 2 ; i <= sqrt ( n ); i += 1 ) { if ( n % i == 0 ) { return false ; } } return true ; } If is_prime is called with n = 1, the program will crash with the message: 1 Assertion failed: (n > 1), function main, file teh.c, line 70. Adding assert is helpful during development time to catch errors. Such statements, however, would slow down the execution. The nice thing about assert is that it can be disabled easily with a compilation flag -DNDEBUG , allowing us to turn off assert checks when we are ready to release and deploy our code for production or customers. Problem Set 20 Problem 20.1 a) Consider the macro below: 1 2 3 4 #define MIN(a,b) a < b ? a : b long i = MIN ( 10 , 20 ); long j = MIN ( 10 , 20 ) + 1 ; What are the values for i and j after executing the above? b) CS1010-trained students should know better than to use the ++ operator, which combines two steps into one and has the side effects on value i . Let's say someone who is not trained this way wrote the following code: 1 2 3 4 5 #define MIN(a,b) a < b ? a : b long i = 10 ; long j = 20 ; long k = MIN ( j , i ++ ); What are the values of i and k after executing the above? Explain what happen. Problem 20.2 Suppose we write our SWAP macro without the opening and closing brackets: 1 2 3 #define SWAP(T, x, y) T temp = x;\\ x = y;\\ y = temp; CS1010-trained students should know better than to write if - else block without { and } . Suppose someone writes an if-else block without { and } . What could go wrong if they use the macro above, also without the opening and closing brackets? You can also run the C pre-processor directly by invoking the command cpp . \u21a9","title":"20. C preprocessor"},{"location":"20-macro.html#unit-20-c-preprocessor-constants-and-macros","text":"","title":"Unit 20: C Preprocessor: Constants and Macros"},{"location":"20-macro.html#learning-objectives","text":"After this unit, students should: understand how the preprocessing step in the compilation pipeline works understand how #include statements work understand why we should avoid hard-coding magic constants and start having the habit of using #define to define constants in their code. understand how #define can be used to define macros be able to explain the differences between macros and functions be able to write macros in a way that avoid the common pitfalls","title":"Learning Objectives"},{"location":"20-macro.html#revisiting-c-compilation-process","text":"In this unit, we are going to delve deeper into the C compilation process, focusing on a step called pre-processing . This step is usually the first step in the compilation process. In the first lecture, we lumped this process under compile (etc) in the figure below. We can now separate one of the steps under \"etc\" as the pre-processing step,","title":"Revisiting C Compilation Process"},{"location":"20-macro.html#preprocessing","text":"Preprocessing is, in essence, a text processing and substitution process, and so it is not specific to C. In C, this process is used to implement, among other things: (i) file inclusion, (ii) macro, and (iii) conditional compilation. A C pre-processor processes all the lines in the input file that start with a # character. Any line that starts with # is a preprocessor directive . You have seen two of such directives, #include to include a file, and #define to define a constant.","title":"Preprocessing"},{"location":"20-macro.html#include","text":"The #include directive has the format 1 #include <filename> or 1 #include \"filename\" When the C pre-processor sees this directive, it reads the file specified by the given filename, and inserts the text, line-by-line, from this file, into the current file, in the location where the line #include occurs. Any C preprocessor directive in the included file is recursively processed.","title":"#include"},{"location":"20-macro.html#define-constant","text":"We have seen how we can use #define to define constant values in our code in our exercises and assignments. For instance, in Exercise 2, rectangle.c , you have seen: 1 2 3 4 5 6 #define TOP_LEFT \"\u2554\" #define TOP_RIGHT \"\u2557\" #define BOTTOM_RIGHT \"\u255d\" #define BOTTOM_LEFT \"\u255a\" #define HORIZONTAL \"\u2550\" #define VERTICAL \"\u2551\" What is the advantage of using TOP_LEFT (which is 8 characters) instead of just one character \u2554 ? It is a good programming practice to avoid hardcoding constant values (also called magic constants ) in our code so that our code can be easily changed when the requirement of our program has changed. Defining these constants as #define allows us to easily modify our program. For instance, suppose that we wish to change the way we draw the rectangle. Instead of 1 2 3 4 5 6 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d We wish to draw it like this: 1 2 3 4 5 6 +--------+ | | | | | | | | +--------+ All we have to do is to change the defined constants: 1 2 3 4 5 6 #define TOP_LEFT \"+\" #define TOP_RIGHT \"+\" #define BOTTOM_RIGHT \"+\" #define BOTTOM_LEFT \"+\" #define HORIZONTAL \"-\" #define VERTICAL \"|\" We do not have to make any changes to the code to draw the rectangles! This reduces the chances that you introduce bugs into the code. Let's consider the second example, taxi.c from Assignment 1: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 double metered_fare ( long distance ) { double fare = 3.20 ; // The first 1 km or less if ( distance <= 1000 ) { return fare ; } distance -= 1000 ; if ( distance <= 9000 ) { fare += 0.22 * lceil ( distance , 400 ); return fare ; } // more than 10km // 0.22 * ceil(9000 / 400) = 0.22*23 = 5.06 fare += 5.06 ; distance -= 9000 ; fare += 0.22 * lceil ( distance , 350 ); return fare ; } In the snippet above, there are many hard-coded values. Suppose one day, the taxi fare changes (and that day will come). Perhaps the base fare is more, perhaps the distance threshold is shorter. We will have to change the code above to calculate the new fare. By littering the code above with hardcoded values, the code is difficult and error-prone to change. You might think that we can just search and replace to update the code when the fare changes. But this is error-prone as well! Suppose that the taxi fare increases to $0.25 per 350m after 10km, but remains $0.22 between 1 - 10km, then we cannot just replace every occurrence of 0.22 with 0.25 . We can make our code \"future-ready\" by abstracting out all the magic numbers and define constants for each of them. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #define BASE_FARE 3.20 #define BASE_DISTANCE 1000 #define TIER_ONE_FARE 0.22 #define TIER_ONE_DISTANCE 400 #define TIER_ONE_LIMIT 10000 #define TIER_TWO_FARE 0.22 #define TIER_TWO_DISTANCE 350 double metered_fare ( long distance ) { double fare = BASE_FARE ; distance -= BASE_DISTANCE ; if ( distance <= 0 ) { return fare ; } if ( distance <= TIER_ONE_LIMIT ) { fare += TIER_ONE_FARE * lceil ( distance , TIER_ONE_DISTANCE ); } else { fare += TIER_ONE_FARE * ( TIER_ONE_LIMIT / TIER_ONE_DISTANCE ); } distance -= TIER_ONE_LIMIT ; if ( distance <= 0 ) { return fare ; } fare += TIER_TWO_FARE * lceil ( distance , TIER_TWO_DISTANCE ); return fare ; } Replacing the magic numbers with constants make the code a bit harder to read, but now, it is super easy to change. Suppose, one day, the base taxi fare is increased to $3.40, and then $0.20 per 500m subsequently up to 10km, and $0.15 per 600m thereafter, we only need to change: 1 2 3 4 5 6 7 #define BASE_FARE 3.40 #define BASE_DISTANCE 1000 #define TIER_ONE_FARE 0.20 #define TIER_ONE_DISTANCE 500 #define TIER_ONE_LIMIT 10000 #define TIER_TWO_FARE 0.15 #define TIER_TWO_DISTANCE 600 The logic of the code remains the same. How does the C pre-processor process the #define directive? When we write a #define directive, the directive should be followed by an identifier and a token . The token may contain space but must be terminated by a newline . In the example above, BASE_FARE is the identifier, and 3.40 is the token. When the C pre-processor sees the #define directive, it replaces all instances of the identifier in the file with the token. This is merely a text substitution operation.","title":"#define Constant"},{"location":"20-macro.html#the-include-directive","text":"Another commonly used directive is #include . You have seen how we used this to \"import\" the cs1010.h , stdbool.h , math.h , etc. When we introduced this at the beginning of the lecture, we compared this to the import require , use commands seen in other programming languages. But the mechanism for #include is very different from the others. The #include directive merely performs text substitution -- it recursively reads the lines from the included file and inserts them into the location where the #include directive is. Consider the example below. Suppose we have three files: 1 2 3 4 5 6 7 8 9 10 /** * @file: a.c */ #include \"b.h\" int main () { foo ( PI ); } 1 2 3 4 5 6 /** * @file: b.h */ #include \"c.h\" #define PI 3.1415926 1 2 3 4 5 /** * @file: c.h */ void foo ( double x ); Let's see what happens when we run C pre-processor on the file a.c . We can ask clang to stop the compilation process after the pre-processing phase, using the flag -E 1 . 1 clang -E a.c The command will produce the output after C pre-processing: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 1 \"a.c\" # 1 \"<built-in>\" 1 # 1 \"<built-in>\" 3 # 360 \"<built-in>\" 3 # 1 \"<command line>\" 1 # 1 \"<built-in>\" 2 # 1 \"a.c\" 2 # 1 \"./b.h\" 1 # 1 \"./c.h\" 1 void foo ( double x ); # 6 \"./b.h\" 2 # 5 \"a.c\" 2 int main () { foo ( 3.1415926 ); } The lines that start with # are metadata meant for the compiler. If we ignore those, we can see that the file a.c has been expanded into 1 2 3 4 5 void foo ( double x ); int main () { foo ( 3.1415926 ); } Line 1 above is included from file c.h , which in turn is included from file b.h . The C pre-processor also substitutes the text PI with the text 3.1415926 , as the identifier PI is defined in b.h . In C, we usually use #include to share common function declarations and constants.","title":"The #include Directive"},{"location":"20-macro.html#define-macro","text":"The #define directive can be used for a more flexible and powerful text substitution feature called macro . A macro is a block of code that is given an identifying name and is substituted and expanded during pre-processing. For instance, we can write the following: 1 #define SQUARE(x) x*x This macro is named SQUARE , just like a function we defined in Lecture 3 and it takes in a parameter x as well. But that's where the similarity ends. There are a few important differences between macros and functions in C: Macros are not called. They are only substituted during the preprocessing phase which performs text processing on the source code. Macros have no information about types. It has no return type and the parameters have no type. Take the example below. The file: 1 2 3 4 5 6 7 #define SQUARE(x) x*x #define PI 3.1415926 int main () { double radius = 4.0 ; cs1010_print_double ( PI * SQUARE ( radius )); } Get expanded into: 1 2 3 4 5 int main () { double radius = 4.0 ; cs1010_print_double ( 3.1415926 * radius * radius ); } Let's look at another example. We have seen how to write a function that swaps two of the value of variables. The one we wrote swaps two double . If we want to swap two long , or two char * , etc, we will need to write a new function for each one. Let's write a generic macro that does swapping for any type. 1 2 3 4 5 6 7 8 9 10 11 12 13 #define SWAP(T, x, y) {\\ T temp;\\ temp = x;\\ x = y;\\ y = temp;\\ } int main () { long x = 3.0 ; long y = -1.0 ; SWAP ( long , x , y ); } The macro SWAP takes in three parameters, the first is the type T, the second and the third are the variables to be swapped. This macro definition spans multiple lines. Since C preprocessor ends the definition of a macro with the end of the line, we add a backslash character to \"escape\" the newline, telling the preprocessor not to treat the newline as the end of the macro definition. The code above gets expanded to: 1 2 3 4 5 6 int main () { long x = 3.0 ; long y = -1.0 ; { long temp ; temp = x ; x = y ; y = temp ;}; } You might be bothered by the appearance of { and } on Line 5. But note that this is perfectly valid syntax. Recall that we said { and } defines a block, while we commonly define a block in the context of a function body, if , else , for , etc. We can define a block anywhere in C. The reason why it is necessary to place the substituted text within a block is left as an exercise (Problem 20.2).","title":"#define Macro"},{"location":"20-macro.html#pitfalls-and-best-practices","text":"It is easy to forget that macro is doing simple text substitution without an understanding of C syntax. When we write macros, we should always guard against improper usage of macros. Let's consider this: 1 #define SQUARE(x) x*x 1 SQUARE ( radius + 2 ) When the pre-processor substitutes the macro SQUARE , it replaces all instances of the text x with the text radius + 2 . After substitution, we get radius + 2*radius + 2 ! This is not what we expected. To prevent such unexpected expansion, we should always add parenthesis to our macro expression: 1 #define SQUARE(x) ((x)*(x)) So now, 1 SQUARE(radius + 2) gets expanded into ((radius + 2)*(radius + 2)) , which is what we would expect when we call SQUARE . To help the readers of your code know that you are referencing a macro rather than a function, all macros should be written with uppercase letters.","title":"Pitfalls and Best Practices"},{"location":"20-macro.html#the-assert-macros","text":"You have learned what an assertion is and how it can help you to reason about your programs. Previously we have only seen the use of an assertion as a commenting tool, to comment on certain properties that are guaranteed to be true at a certain point of a program. Now, we will make the concept of assertion even more powerful -- we can cause our program to throw an error if an assertion is ever violated. This way, we can tell immediately if certain assumptions or properties that we made in our code are violated. C provides a macro called assert() (in the header file assert.h ) which takes in a logical expression. This logical expression must always evaluate to true when assert is used. Otherwise, assert will throw an error, giving the file and the line number where the error occurred. Using assertions and the assert macro can help us pinpoint exactly where our code goes wrong, quickly. Take the following code for is_prime , for instance: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** * Test if a number is prime or not. * * @pre n > 1 * @param[in] n The number to test if is prime * @return true if n is prime, false otherwise */ bool is_prime ( long n ) { for ( long i = 2 ; i <= sqrt ( n ); i += 1 ) { if ( n % i == 0 ) { return false ; } } return true ; } The code has a precondition that n is larger than 1. If n is 1, the function would return true, which is incorrect since 1 is not a prime. The writer of this function intended that this function should be called with n larger than 1 only. But we don't have control over how others call our function and if someone missed the pre-condition and call is_prime with n = 1, we will have a buggy program. One way to prevent this is to use the assert macro, and add an assert statement like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * Test if a number is prime or not. * * @pre n > 1 * @param[in] n The number to test if is prime * @return true if n is prime, false otherwise */ bool is_prime ( long n ) { assert ( n > 1 ); for ( long i = 2 ; i <= sqrt ( n ); i += 1 ) { if ( n % i == 0 ) { return false ; } } return true ; } If is_prime is called with n = 1, the program will crash with the message: 1 Assertion failed: (n > 1), function main, file teh.c, line 70. Adding assert is helpful during development time to catch errors. Such statements, however, would slow down the execution. The nice thing about assert is that it can be disabled easily with a compilation flag -DNDEBUG , allowing us to turn off assert checks when we are ready to release and deploy our code for production or customers.","title":"The assert macros"},{"location":"20-macro.html#problem-set-20","text":"","title":"Problem Set 20"},{"location":"20-macro.html#problem-201","text":"a) Consider the macro below: 1 2 3 4 #define MIN(a,b) a < b ? a : b long i = MIN ( 10 , 20 ); long j = MIN ( 10 , 20 ) + 1 ; What are the values for i and j after executing the above? b) CS1010-trained students should know better than to use the ++ operator, which combines two steps into one and has the side effects on value i . Let's say someone who is not trained this way wrote the following code: 1 2 3 4 5 #define MIN(a,b) a < b ? a : b long i = 10 ; long j = 20 ; long k = MIN ( j , i ++ ); What are the values of i and k after executing the above? Explain what happen.","title":"Problem 20.1"},{"location":"20-macro.html#problem-202","text":"Suppose we write our SWAP macro without the opening and closing brackets: 1 2 3 #define SWAP(T, x, y) T temp = x;\\ x = y;\\ y = temp; CS1010-trained students should know better than to write if - else block without { and } . Suppose someone writes an if-else block without { and } . What could go wrong if they use the macro above, also without the opening and closing brackets? You can also run the C pre-processor directly by invoking the command cpp . \u21a9","title":"Problem 20.2"},{"location":"21-efficiency.html","text":"Unit 21: Efficiency Learning Objectives After completing this unit, students should: be aware that efficiency translates to less (and hopefully minimal) computation and space being used by a program Understand that increasing efficiency typically requires that there are no redundancies and no duplication (i.e., not repeat work already done) understand that when analyzing efficiency, we wish to bound the computation required and thus look at the worst-case scenario understand that Big-O bounds capture the highest order of growth for some algorithm/code be able to determine the Big-O bounds for most code used in CS1010 be able to compare the efficiency between code using Big-O analysis No Redundant Work We have been asking you to write efficient code, but we have not been very formal about quantifying what is efficiency. In this unit, we will recap the various good habits to write efficient code, and introduces the notion of time complexity of a code, using the Big-O notation. Writing efficient code means that we should not write code that runs unnecessarily. Let's consider the following two versions of the is_prime function. 1 2 3 4 5 6 7 8 9 10 bool is_prime ( long n ) { bool is_prime = true ; for ( long i = 2 ; i <= n - 1 ; i += 1 ) { if ( n % i == 0 ) { is_prime = false ; } } return is_prime ; } 1 2 3 4 5 6 7 8 9 bool is_prime ( long n ) { for ( long i = 2 ; i <= sqrt ( n ); i += 1 ) { if ( n % i == 0 ) { return false ; } } return true ; } Both versions are correct -- they produce true when the input n is prime, and false otherwise. But they take a vastly different amount of time to run. On my machine, the slowest version of is_prime took ~100s, while the fast one runs ~3ms when invoked with is_prime(10000000001) . The time taken is a five order of magnitude difference! The second version of is_prime is faster as it follows the following mantra: \"No redundant work\" We came across this when we discussed short-circuiting earlier -- we want to order our logical expression so that we don't do extra, unnecessary, work. Here, we improve the efficiency of is_prime by (i) returning false as soon as we found \"proof\" that the input is not a prime, and (ii) not checking for divisor that is redundant. Worst-Case Performance The two techniques we employed above behave slightly differently. For (i), we opportunistically stop our computation once we know the answer when the input is not a prime. However, in the worst case , when the input is a prime, we still have to check through all \\(n-2\\) divisors, from 2 up to \\(n-1\\) , before we can conclude that the input is a prime. Thus, for (i), we make our program faster for certain inputs but in the worst case, we are not able to speed up the program. The second technique is more interesting and more fruitful. With a little math, we can show that we only need to check for the divisor up to \\(\\sqrt{n}\\) . Here, we are improving the worst case performance of is_prime , so whether the input is prime or not, we always have a speedup. How much is the speed up in the worst case? In the input above, with the original slow code, in the worst case, I need to check through ~10,000,000,001 divisors. With the faster version, I only need to check ~ \\(\\sqrt{10,000,000,001}\\) = ~10,000 divisors. That's where the five orders of magnitude speedup come from! No Duplication The second principle to improving the efficiency of the program is that \"No duplication\" -- we should not repeat work that has been done before. Let's look at the example from earlier this semester, where you are asked to compute the range of a list. Recall that the range of a list is the absolute difference between the largest element and the smallest element. We use this problem to motivate the use of function, where we denote \\(range(L, k) = |max(L, k) - min(L, k)|\\) . If we are to implement this solution in C, however, we would end up scanning through the list twice: first to find the max, then to find the min. But we could easily just go through the list once, use call-by-reference to output both the max and the min if we are willing to forgo the notion of pure functions and function-as-a-black-box. The performance improvement for not scanning through a list twice is modest at most. Let's look at another example where, by not repeating ourselves, we can gain significant performance improvement. Finding Fibonacci Numbers Recall from your Exercise 4, the Fibonacci sequence of numbers are numbers formed by adding the previous two numbers to form the next numbers. In other words, the \\(i\\) -th Fibonacci number is computed as the sum of the previous two Fibonacci numbers, the \\((i-2)\\) -th, and the \\((i-1)\\) -th. Here is one way we can find the Fibonacci numbers with a loop: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 long fib ( long n ) { if ( n == 1 || n == 2 ) { return 1 ; } long first = 1 ; long second = 1 ; long third = 2 ; for ( long i = 2 ; i != n ; i += 1 ) { first = second ; second = third ; third = first + second ; } return third ; } To find the \\(n\\) -th Fibonacci number, we take \\(n\\) steps in a loop. Now, let's see the following elegant recursive solution: 1 2 3 4 5 6 7 long fib ( long n ) { if ( n == 1 || n == 2 ) { return 1 ; } return fib ( n -1 ) + fib ( n -2 ); } This solution is short and follows directly from the definition of Fibonacci numbers. Running this, however, reveals something very disturbing. Let's say we call fib(n) . This invocation in turns calls fib(n-1) and fib(n-2) . fib(n-1) then calls fib(n-2) and fib(n-3) . So, fib(n-2) will be called twice -- so we are repeating ourselves, violating the no duplication principles. We will invoke fib() a large number of times. Big-O Notation How do we characterize the number of times fib() is called? To answer this, we will introduce to you the Big-O notation. The Big-O function is a mathematical function that computer scientists use to characterize the time and space efficiency of an algorithm. In CS1010, we will not go into the formal definition of the notation but will introduce Big-O using the intuition that it is the \"rate of growth\" of a function. Formal definition For those mathematically inclined students who can't wait until CS2040C or CS3230 for a formal definition, here it is: Given two functions \\(f\\) and \\(g\\) , we say that \\(f(x) = O(g(x))\\) if the exists a position real number \\(c\\) and a real number \\(x_0\\) such that \\[ |f(x)| \\le cg(x), \\,\\, \\forall x \\ge x_0\\] To motivate Big-O, let's consider how we can count the number of \"steps\" taken by an algorithm. Let's consider this again: 1 2 3 4 5 for ( long i = 2 ; i != n ; i += 1 ) { first = second ; second = third ; third = first + second ; } If we consider each of the fundamental operations: comparison, addition, and assignment, as a step, then we can see that, in each loop, there is one comparison ( i != n ), two additions ( i + 1 , third = first + second ), four assignments. So we have seven operations per loop, with a total of \\(n-1\\) loops. So we have \\(7n - 7\\) operations. In addition, we also need to count for the assignment i = 2 and the additional comparison before we exit the loop ( i != n ). So, in total, we have \\(7n - 5\\) operations. As you can see, such detailed counting of the steps is tedious, and in fact, not very meaningful. For instance, we did not account for reading values from the memory and writing of values into the memory, the performance of which becomes dependant on the architecture underneath. To free us from such low-level accounting of the number of steps, let's focus on the big picture. No matter how we count the number of steps, in the end, it is a linear function of \\(n\\) . In order words, the number of steps taken by the algorithm to compute Fibonacci in a loop grows linearly with \\(n\\) . Using the Big-O notation, we say that it takes \\(O(n)\\) steps. Given a mathematical function with multiple terms, the Big-O of this function is obtained by dropping any multiplicative constants and all terms, except for the one with the highest rate of growth . For instance, \\(O(\\frac{n^4}{10} + 10000n^2 - n) = O(n^4)\\) . Due to this focus on the term with the highest rate of growth, and not bothering about other terms or multiplicative constants, it becomes very convenient for us to express the time efficiency of an algorithm with \\(O()\\) -- we no longer need to count the steps precisely but just focus on the number of times it takes to run the algorithm in terms of \\(n\\) . Take the example of is_prime . The slow algorithm takes \\(O(n)\\) , the fast algorithm takes \\(O(\\sqrt{n})\\) . Take another example: to find the range of a list, both algorithms, regardless of whether we are taking two passes or one pass, take \\(O(n)\\) time. Comparing Rate of Growth Given two functions \\(f(n)\\) and \\(g(n)\\) , how do we determine which one has a higher rate of growth? We say that \\(f(n)\\) grows faster than \\(g(n)\\) if we can find a \\(n_0\\) , such that \\(f(n) > cg(n)\\) for all \\(n \\ge n_0\\) and for some constant \\(c\\) . For instance, which one grows faster? \\(f(n) = n^n\\) or \\(g(n) = 2^n\\) ? Pick \\(n = 1\\) , we have \\(f(1) < g(1)\\) 1 . Pick \\(n = 2\\) , we have \\(f(2)\\) equals \\(g(2)\\) . Pick \\(n = 3\\) , we have \\(f(3) > g(3)\\) now, and we can see that for any \\(n > 3\\) , \\(n^n > 2^n\\) , so we can conclude that \\(f(n)\\) grows faster than \\(g(n)\\) . Running Time or Time Complexity of an Algorithm Using the big-O notation, we can quantify how many steps an algorithm takes to run. This measurement is called the running time or the time complexity of the algorithm. In CS1010, when we express the running time, we are interested in the worst-case performance, or worst-case running time. Computer scientists also find measuring the average running time useful in certain scenarios. You will learn about analyzing the average running time in CS3230. There are a couple of things to note when expressing the running of an algorithm in big-O notation: We should express it in its simplest form -- without multiplicative constants, and dropping all lower terms. Since we are specifying the worst-case performance, we are measuring an upper bound on the running time. We should express an upper bound that is as tight as possible. Example: Selection Sort Now, consider the algorithm to perform selection sort. The code is given below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 size_t max ( size_t length , const long list []) { long max_so_far = list [ 0 ]; size_t max_index = 0 ; for ( size_t i = 1 ; i <= length ; i += 1 ) { if ( list [ i ] > max_so_far ) { max_so_far = list [ i ]; max_index = i ; } } return max_index ; } void selection_sort ( size_t n , long list [ n ]) { for ( size_t j = n - 1 ; j >= 1 ; j -= 1 ) { size_t max_pos = max ( j , list ); swap ( list , max_pos , j ); } } What is the running time of the function selection_sort , expressed in Big-O notation in terms of \\(n\\) , the length of the input array? To analyze the running time, we focus on the big picture, the part of the code that takes the most time, and we ignore all the other operations that take negligible time. In the function selection_sort above, Lines 17-18 are repeated \\(n-1\\) times, so let's focus on that. Looking at the looping conditions, we can conclude that Lines 17-18 repeats \\(O(n-1) = O(n)\\) times. It is tempting to conclude that selection_sort takes \\(O(n)\\) steps here, but it would be wrong. Notice that Line 17 calls another function max . What is the running time of max ? Inside max , there is another loop that repeats \\(j - 1\\) times. Each time we call max , j decreases, so the loop in max takes one fewer step each time the function is called. To calculate the total number of steps, we can compute the following sum \\(\\sum_{j=1}^{n-1}(j-1)\\) , which is just \\(0 + 1 + 2 + .. + (n-3) + (n-2)\\) This sum is the sum of an arithmetic series and equals to \\((n-2)(n-1)/2\\) . Since we use the Big-O notation, we can focus on the term with the highest rate of growth, \\(n^2\\) , and ignore everything else. We have obtained the running time for selection_sort function above as \\(O(n^2)\\) . Example: Fibonacci Let's get back to the recursive Fibonacci number example. What is the running time of fib ? 1 2 3 4 5 6 7 long fib ( long n ) { if ( n == 1 || n == 2 ) { return 1 ; } return fib ( n -1 ) + fib ( n -2 ); } Answering this question is trickier since this is a recursive function. But, we can use the same \"wishful thinking\" approach we used when writing this code to analyze its running time. Let \\(T(n)\\) is the running time of fib(n) . Since fib(n) calls fib(n-1) and fib(n-2) , we can write \\(T(n) = T(n-1) + T(n-2)\\) . Just like the recursive function there is a base case: \\(T(n) = O(1)\\) if \\(n \\le 2\\) . Note that \\(O(1)\\) is also known as constant running time 1 . The equation for \\(T(n)\\) above is known as a recurrence relation . There are standard techniques to solve it (search for Master Theorem on the web), but we won't go into them in CS1010. We will solve it from the first principle, by expanding the equation and observing the pattern. We know that \\(T(n-1) > T(n-2)\\) . So, \\[ T(n) < T(n-1) + T(n-1), \\] therefore, \\[ T(n) < 2T(n-1). \\] So \\[ T(n) < 2T(n-1) < 4T(n-2) < 8T(n-3) < .. 2^{n-1}T(1) < O(\\frac{1}{2}2^n) \\] Since we can drop the multiplicative constant in Big-O notation, we have \\(T(n) = O(2^n)\\) . This explains why the recursive solution to Fibonacci is so much slower than the iterative version, which is \\(O(n)\\) -- one grows exponentially while the other linearly in terms of \\(n\\) . Note: the original note contains the derivation of relation \\(T(n) > O(\\frac{1}{4}2^n)\\) , which is buggy. The correct derivation of this turns out to be more complicated than I intended. I therefore omit it in the revised version. Example: Collatz Not every program has a running time that is easy to analyze. For instance, take collatz 1 2 3 4 5 6 7 8 9 long count_num_of_steps ( long n ) { long num_of_steps = 0 ; while ( n != 1 ) { n = collatz ( n ); num_of_steps += 1 ; } return num_of_steps ; } Recall that this program is based on the Collatz conjecture, which has not been proven. So we cannot say that the loop above will always terminate after a given number of steps. The running time for the code above remains unknown. Space Efficiency We have focused mostly on efficiency in terms of time in this unit. Note that the notion of efficiency extends to space (memory usage) as well. Big-O notation can be used to quantify how much space is used as well. Problem Set 21 Problem 21.1 Order the following functions in the increasing order of rate of growth: \\(n!\\) , \\(2^n\\) , \\(\\log_{10} n\\) , \\(\\ln n\\) , \\(n^4\\) , \\(n\\ln n\\) , \\(n\\) , \\(n^2\\) , \\(e^n\\) , \\(\\sqrt{n}\\) Problem 21.2 What is the Big-O running time of the following code, in terms of \\(n\\) ? a) 1 2 3 4 5 for ( long i = 0 ; i < n ; i += 1 ) { for ( long j = 0 ; j < n ; j += 2 ) { cs1010_println_long ( i + j ); } } b) 1 2 3 4 5 for ( long i = 1 ; i < n ; i *= 2 ) { for ( long j = 1 ; j < n ; j *= 2 ) { cs1010_println_long ( i + j ); } } c) 1 2 3 4 5 6 7 long k = 1 ; for ( long j = 0 ; j < n ; j += 1 ) { k *= 2 ; for ( long i = 0 ; i < k ; i += 1 ) { cs1010_println_long ( i + j ); } } The \\(1\\) in \\(O(1)\\) has nothing to do with the function returning 1 . But we write it this way because we can drop multiplicative constants in the big-O notation. \u21a9 \u21a9","title":"21. Efficiency"},{"location":"21-efficiency.html#unit-21-efficiency","text":"","title":"Unit 21: Efficiency"},{"location":"21-efficiency.html#learning-objectives","text":"After completing this unit, students should: be aware that efficiency translates to less (and hopefully minimal) computation and space being used by a program Understand that increasing efficiency typically requires that there are no redundancies and no duplication (i.e., not repeat work already done) understand that when analyzing efficiency, we wish to bound the computation required and thus look at the worst-case scenario understand that Big-O bounds capture the highest order of growth for some algorithm/code be able to determine the Big-O bounds for most code used in CS1010 be able to compare the efficiency between code using Big-O analysis","title":"Learning Objectives"},{"location":"21-efficiency.html#no-redundant-work","text":"We have been asking you to write efficient code, but we have not been very formal about quantifying what is efficiency. In this unit, we will recap the various good habits to write efficient code, and introduces the notion of time complexity of a code, using the Big-O notation. Writing efficient code means that we should not write code that runs unnecessarily. Let's consider the following two versions of the is_prime function. 1 2 3 4 5 6 7 8 9 10 bool is_prime ( long n ) { bool is_prime = true ; for ( long i = 2 ; i <= n - 1 ; i += 1 ) { if ( n % i == 0 ) { is_prime = false ; } } return is_prime ; } 1 2 3 4 5 6 7 8 9 bool is_prime ( long n ) { for ( long i = 2 ; i <= sqrt ( n ); i += 1 ) { if ( n % i == 0 ) { return false ; } } return true ; } Both versions are correct -- they produce true when the input n is prime, and false otherwise. But they take a vastly different amount of time to run. On my machine, the slowest version of is_prime took ~100s, while the fast one runs ~3ms when invoked with is_prime(10000000001) . The time taken is a five order of magnitude difference! The second version of is_prime is faster as it follows the following mantra: \"No redundant work\" We came across this when we discussed short-circuiting earlier -- we want to order our logical expression so that we don't do extra, unnecessary, work. Here, we improve the efficiency of is_prime by (i) returning false as soon as we found \"proof\" that the input is not a prime, and (ii) not checking for divisor that is redundant.","title":"No Redundant Work"},{"location":"21-efficiency.html#worst-case-performance","text":"The two techniques we employed above behave slightly differently. For (i), we opportunistically stop our computation once we know the answer when the input is not a prime. However, in the worst case , when the input is a prime, we still have to check through all \\(n-2\\) divisors, from 2 up to \\(n-1\\) , before we can conclude that the input is a prime. Thus, for (i), we make our program faster for certain inputs but in the worst case, we are not able to speed up the program. The second technique is more interesting and more fruitful. With a little math, we can show that we only need to check for the divisor up to \\(\\sqrt{n}\\) . Here, we are improving the worst case performance of is_prime , so whether the input is prime or not, we always have a speedup. How much is the speed up in the worst case? In the input above, with the original slow code, in the worst case, I need to check through ~10,000,000,001 divisors. With the faster version, I only need to check ~ \\(\\sqrt{10,000,000,001}\\) = ~10,000 divisors. That's where the five orders of magnitude speedup come from!","title":"Worst-Case Performance"},{"location":"21-efficiency.html#no-duplication","text":"The second principle to improving the efficiency of the program is that \"No duplication\" -- we should not repeat work that has been done before. Let's look at the example from earlier this semester, where you are asked to compute the range of a list. Recall that the range of a list is the absolute difference between the largest element and the smallest element. We use this problem to motivate the use of function, where we denote \\(range(L, k) = |max(L, k) - min(L, k)|\\) . If we are to implement this solution in C, however, we would end up scanning through the list twice: first to find the max, then to find the min. But we could easily just go through the list once, use call-by-reference to output both the max and the min if we are willing to forgo the notion of pure functions and function-as-a-black-box. The performance improvement for not scanning through a list twice is modest at most. Let's look at another example where, by not repeating ourselves, we can gain significant performance improvement.","title":"No Duplication"},{"location":"21-efficiency.html#finding-fibonacci-numbers","text":"Recall from your Exercise 4, the Fibonacci sequence of numbers are numbers formed by adding the previous two numbers to form the next numbers. In other words, the \\(i\\) -th Fibonacci number is computed as the sum of the previous two Fibonacci numbers, the \\((i-2)\\) -th, and the \\((i-1)\\) -th. Here is one way we can find the Fibonacci numbers with a loop: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 long fib ( long n ) { if ( n == 1 || n == 2 ) { return 1 ; } long first = 1 ; long second = 1 ; long third = 2 ; for ( long i = 2 ; i != n ; i += 1 ) { first = second ; second = third ; third = first + second ; } return third ; } To find the \\(n\\) -th Fibonacci number, we take \\(n\\) steps in a loop. Now, let's see the following elegant recursive solution: 1 2 3 4 5 6 7 long fib ( long n ) { if ( n == 1 || n == 2 ) { return 1 ; } return fib ( n -1 ) + fib ( n -2 ); } This solution is short and follows directly from the definition of Fibonacci numbers. Running this, however, reveals something very disturbing. Let's say we call fib(n) . This invocation in turns calls fib(n-1) and fib(n-2) . fib(n-1) then calls fib(n-2) and fib(n-3) . So, fib(n-2) will be called twice -- so we are repeating ourselves, violating the no duplication principles. We will invoke fib() a large number of times.","title":"Finding Fibonacci Numbers"},{"location":"21-efficiency.html#big-o-notation","text":"How do we characterize the number of times fib() is called? To answer this, we will introduce to you the Big-O notation. The Big-O function is a mathematical function that computer scientists use to characterize the time and space efficiency of an algorithm. In CS1010, we will not go into the formal definition of the notation but will introduce Big-O using the intuition that it is the \"rate of growth\" of a function. Formal definition For those mathematically inclined students who can't wait until CS2040C or CS3230 for a formal definition, here it is: Given two functions \\(f\\) and \\(g\\) , we say that \\(f(x) = O(g(x))\\) if the exists a position real number \\(c\\) and a real number \\(x_0\\) such that \\[ |f(x)| \\le cg(x), \\,\\, \\forall x \\ge x_0\\] To motivate Big-O, let's consider how we can count the number of \"steps\" taken by an algorithm. Let's consider this again: 1 2 3 4 5 for ( long i = 2 ; i != n ; i += 1 ) { first = second ; second = third ; third = first + second ; } If we consider each of the fundamental operations: comparison, addition, and assignment, as a step, then we can see that, in each loop, there is one comparison ( i != n ), two additions ( i + 1 , third = first + second ), four assignments. So we have seven operations per loop, with a total of \\(n-1\\) loops. So we have \\(7n - 7\\) operations. In addition, we also need to count for the assignment i = 2 and the additional comparison before we exit the loop ( i != n ). So, in total, we have \\(7n - 5\\) operations. As you can see, such detailed counting of the steps is tedious, and in fact, not very meaningful. For instance, we did not account for reading values from the memory and writing of values into the memory, the performance of which becomes dependant on the architecture underneath. To free us from such low-level accounting of the number of steps, let's focus on the big picture. No matter how we count the number of steps, in the end, it is a linear function of \\(n\\) . In order words, the number of steps taken by the algorithm to compute Fibonacci in a loop grows linearly with \\(n\\) . Using the Big-O notation, we say that it takes \\(O(n)\\) steps. Given a mathematical function with multiple terms, the Big-O of this function is obtained by dropping any multiplicative constants and all terms, except for the one with the highest rate of growth . For instance, \\(O(\\frac{n^4}{10} + 10000n^2 - n) = O(n^4)\\) . Due to this focus on the term with the highest rate of growth, and not bothering about other terms or multiplicative constants, it becomes very convenient for us to express the time efficiency of an algorithm with \\(O()\\) -- we no longer need to count the steps precisely but just focus on the number of times it takes to run the algorithm in terms of \\(n\\) . Take the example of is_prime . The slow algorithm takes \\(O(n)\\) , the fast algorithm takes \\(O(\\sqrt{n})\\) . Take another example: to find the range of a list, both algorithms, regardless of whether we are taking two passes or one pass, take \\(O(n)\\) time.","title":"Big-O Notation"},{"location":"21-efficiency.html#comparing-rate-of-growth","text":"Given two functions \\(f(n)\\) and \\(g(n)\\) , how do we determine which one has a higher rate of growth? We say that \\(f(n)\\) grows faster than \\(g(n)\\) if we can find a \\(n_0\\) , such that \\(f(n) > cg(n)\\) for all \\(n \\ge n_0\\) and for some constant \\(c\\) . For instance, which one grows faster? \\(f(n) = n^n\\) or \\(g(n) = 2^n\\) ? Pick \\(n = 1\\) , we have \\(f(1) < g(1)\\) 1 . Pick \\(n = 2\\) , we have \\(f(2)\\) equals \\(g(2)\\) . Pick \\(n = 3\\) , we have \\(f(3) > g(3)\\) now, and we can see that for any \\(n > 3\\) , \\(n^n > 2^n\\) , so we can conclude that \\(f(n)\\) grows faster than \\(g(n)\\) .","title":"Comparing Rate of Growth"},{"location":"21-efficiency.html#running-time-or-time-complexity-of-an-algorithm","text":"Using the big-O notation, we can quantify how many steps an algorithm takes to run. This measurement is called the running time or the time complexity of the algorithm. In CS1010, when we express the running time, we are interested in the worst-case performance, or worst-case running time. Computer scientists also find measuring the average running time useful in certain scenarios. You will learn about analyzing the average running time in CS3230. There are a couple of things to note when expressing the running of an algorithm in big-O notation: We should express it in its simplest form -- without multiplicative constants, and dropping all lower terms. Since we are specifying the worst-case performance, we are measuring an upper bound on the running time. We should express an upper bound that is as tight as possible.","title":"Running Time or Time Complexity of an Algorithm"},{"location":"21-efficiency.html#example-selection-sort","text":"Now, consider the algorithm to perform selection sort. The code is given below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 size_t max ( size_t length , const long list []) { long max_so_far = list [ 0 ]; size_t max_index = 0 ; for ( size_t i = 1 ; i <= length ; i += 1 ) { if ( list [ i ] > max_so_far ) { max_so_far = list [ i ]; max_index = i ; } } return max_index ; } void selection_sort ( size_t n , long list [ n ]) { for ( size_t j = n - 1 ; j >= 1 ; j -= 1 ) { size_t max_pos = max ( j , list ); swap ( list , max_pos , j ); } } What is the running time of the function selection_sort , expressed in Big-O notation in terms of \\(n\\) , the length of the input array? To analyze the running time, we focus on the big picture, the part of the code that takes the most time, and we ignore all the other operations that take negligible time. In the function selection_sort above, Lines 17-18 are repeated \\(n-1\\) times, so let's focus on that. Looking at the looping conditions, we can conclude that Lines 17-18 repeats \\(O(n-1) = O(n)\\) times. It is tempting to conclude that selection_sort takes \\(O(n)\\) steps here, but it would be wrong. Notice that Line 17 calls another function max . What is the running time of max ? Inside max , there is another loop that repeats \\(j - 1\\) times. Each time we call max , j decreases, so the loop in max takes one fewer step each time the function is called. To calculate the total number of steps, we can compute the following sum \\(\\sum_{j=1}^{n-1}(j-1)\\) , which is just \\(0 + 1 + 2 + .. + (n-3) + (n-2)\\) This sum is the sum of an arithmetic series and equals to \\((n-2)(n-1)/2\\) . Since we use the Big-O notation, we can focus on the term with the highest rate of growth, \\(n^2\\) , and ignore everything else. We have obtained the running time for selection_sort function above as \\(O(n^2)\\) .","title":"Example: Selection Sort"},{"location":"21-efficiency.html#example-fibonacci","text":"Let's get back to the recursive Fibonacci number example. What is the running time of fib ? 1 2 3 4 5 6 7 long fib ( long n ) { if ( n == 1 || n == 2 ) { return 1 ; } return fib ( n -1 ) + fib ( n -2 ); } Answering this question is trickier since this is a recursive function. But, we can use the same \"wishful thinking\" approach we used when writing this code to analyze its running time. Let \\(T(n)\\) is the running time of fib(n) . Since fib(n) calls fib(n-1) and fib(n-2) , we can write \\(T(n) = T(n-1) + T(n-2)\\) . Just like the recursive function there is a base case: \\(T(n) = O(1)\\) if \\(n \\le 2\\) . Note that \\(O(1)\\) is also known as constant running time 1 . The equation for \\(T(n)\\) above is known as a recurrence relation . There are standard techniques to solve it (search for Master Theorem on the web), but we won't go into them in CS1010. We will solve it from the first principle, by expanding the equation and observing the pattern. We know that \\(T(n-1) > T(n-2)\\) . So, \\[ T(n) < T(n-1) + T(n-1), \\] therefore, \\[ T(n) < 2T(n-1). \\] So \\[ T(n) < 2T(n-1) < 4T(n-2) < 8T(n-3) < .. 2^{n-1}T(1) < O(\\frac{1}{2}2^n) \\] Since we can drop the multiplicative constant in Big-O notation, we have \\(T(n) = O(2^n)\\) . This explains why the recursive solution to Fibonacci is so much slower than the iterative version, which is \\(O(n)\\) -- one grows exponentially while the other linearly in terms of \\(n\\) . Note: the original note contains the derivation of relation \\(T(n) > O(\\frac{1}{4}2^n)\\) , which is buggy. The correct derivation of this turns out to be more complicated than I intended. I therefore omit it in the revised version.","title":"Example: Fibonacci"},{"location":"21-efficiency.html#example-collatz","text":"Not every program has a running time that is easy to analyze. For instance, take collatz 1 2 3 4 5 6 7 8 9 long count_num_of_steps ( long n ) { long num_of_steps = 0 ; while ( n != 1 ) { n = collatz ( n ); num_of_steps += 1 ; } return num_of_steps ; } Recall that this program is based on the Collatz conjecture, which has not been proven. So we cannot say that the loop above will always terminate after a given number of steps. The running time for the code above remains unknown.","title":"Example: Collatz"},{"location":"21-efficiency.html#space-efficiency","text":"We have focused mostly on efficiency in terms of time in this unit. Note that the notion of efficiency extends to space (memory usage) as well. Big-O notation can be used to quantify how much space is used as well.","title":"Space Efficiency"},{"location":"21-efficiency.html#problem-set-21","text":"","title":"Problem Set 21"},{"location":"21-efficiency.html#problem-211","text":"Order the following functions in the increasing order of rate of growth: \\(n!\\) , \\(2^n\\) , \\(\\log_{10} n\\) , \\(\\ln n\\) , \\(n^4\\) , \\(n\\ln n\\) , \\(n\\) , \\(n^2\\) , \\(e^n\\) , \\(\\sqrt{n}\\)","title":"Problem 21.1"},{"location":"21-efficiency.html#problem-212","text":"What is the Big-O running time of the following code, in terms of \\(n\\) ? a) 1 2 3 4 5 for ( long i = 0 ; i < n ; i += 1 ) { for ( long j = 0 ; j < n ; j += 2 ) { cs1010_println_long ( i + j ); } } b) 1 2 3 4 5 for ( long i = 1 ; i < n ; i *= 2 ) { for ( long j = 1 ; j < n ; j *= 2 ) { cs1010_println_long ( i + j ); } } c) 1 2 3 4 5 6 7 long k = 1 ; for ( long j = 0 ; j < n ; j += 1 ) { k *= 2 ; for ( long i = 0 ; i < k ; i += 1 ) { cs1010_println_long ( i + j ); } } The \\(1\\) in \\(O(1)\\) has nothing to do with the function returning 1 . But we write it this way because we can drop multiplicative constants in the big-O notation. \u21a9 \u21a9","title":"Problem 21.2"},{"location":"22-search.html","text":"Unit 23: Searching Learning Objectives After this unit students should be familiar with linear search and binary search algorithm, including understanding how the algorithms work, implementing the algorithms, arguing their correctness, and analyzing their running time. Linear Search Let's continue the discussion on efficiency on one of the fundamental problems in computing: how to look for something. Given a list of items \\(L\\) and query item \\(q\\) , we wish find if \\(q\\) is in \\(L\\) . If \\(q\\) is in \\(L\\) , then we return the index of \\(q\\) . Otherwise, we return -1. Let's write a function to solve this. 1 2 3 4 5 6 7 8 9 10 11 12 13 /** * Look for q in list[0]..list[n-1]. * * @return -1 if not found, the position of q in list otherwise. */ long search ( long n , const long list [ n ], long q ) { for ( long i = 0 ; i < n ; i += 1 ) { if ( list [ i ] == q ) { return i ; } } return -1 ; } What is the worst-case running time, expressed in Big-O notation, of the function above? Suppose the query \\(q\\) is not in the list, we will have to scan the whole list, once. The worst case running time is, therefore, \\(O(n)\\) . Can we do better? It turns out that this running time \\(O(n)\\) is also the best that we can do because we cannot be sure that \\(q\\) does not exist until we check every single element in the list. So there is no shortcut. In previous units, we have seen recursive, divide-and-conquer solution for max . We can easily adapt it to search as well: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Look for q in list[i]..list[j]. * * @return -1 if not found, the position of q in list otherwise. */ long search ( const long list [], long i , long j , long q ) { if ( i > j ) { return -1 ; } long mid = ( i + j ) / 2 ; if ( list [ mid ] == q ) { return mid ; } long found = search ( list , i , mid -1 , q ); if ( found >= 0 ) { return found ; } return search ( list , mid + 1 , j , q ); } We then call this function with: 1 search ( list , 0 , n -1 , q ); In the code above, we first handle the base case where i > j , which means that the sublist list[i]..list[j] to search for q in, is empty. In this case, q is not found and we return -1. If the list list[i] .. list[j] is not empty, we check the element in the middle if it is q . If we have not yet find q , then we first search the left sublist. If still not found, we search the right sublist. and return the result. In the worst case, when q is not in the list, we still have to check through every element in the list. So the running time is still \\(O(n)\\) . It is no faster than searching with a for loop. We can also argue that the running time of the code above is \\(O(n)\\) , using the recurrence relation: \\[ T(n)= \\begin{cases} 2T(\\frac{n}{2}) + 1,& \\text{if } n > 1\\\\ 1, & \\text{otherwise} \\end{cases} \\] Here, \\[ \\begin{align*} T(n) &= 2T\\left(\\frac{n}{2}\\right) + 1 \\\\ &= 4T\\left(\\frac{n}{4}\\right) + 2 = \\cdots \\\\ &= 2^kT\\left(\\frac{n}{2^k}\\right) + k = \\cdots \\\\ &= nT(1) + \\log n \\\\ &= O(n) \\\\ \\end{align*} \\] Binary Search But, do we always have to check every element in the list? It turns out that, like many real-life situations, if the input list is sorted , we do not have to scan through every element. We can eliminate a huge chunk of the elements based on whether a chosen element is bigger or smaller than \\(q\\) . Suppose that the input list is sorted in increasing order. Pick a random element \\(x\\) from the list. Any element to the left of \\(x\\) must be less than or equal to \\(x\\) , and any element to the right of \\(x\\) must be greater or equal to \\(x\\) . Suppose that \\(q > x\\) , then we know that \\(q\\) must be to the right of \\(x\\) , there is no need to search to the left of \\(x\\) . Otherwise, \\(q < x\\) , and \\(q\\) must be to the left of \\(x\\) , and there is no need to search to the right of \\(x\\) . We can modify the earlier recursive function into the one below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Look for q in list[i]..list[j]. * * @pre list is sorted * @return -1 if not found, the position of q in list otherwise. */ long search ( const long list [], long i , long j , long q ) { if ( i > j ) { return -1 ; } long mid = ( i + j ) / 2 ; if ( list [ mid ] == q ) { return mid ; } if ( list [ mid ] > q ) { return search ( list , i , mid -1 , q ); } return search ( list , mid + 1 , j , q ); } We have changed the function so that it only search either the left side or the right side, but never both. The search algorithm above is called binary search since it repeatedly cut the range of values to search by half. Why is it correct? It is not obvious at first glance that the code above correctly searches for \\(q\\) in \\(L\\) . Let's analyze this function more systematically by writing an assertion for this function. What we want to do here is to eliminate elements in the array that cannot possibly contain \\(q\\) -- these are elements outside of the list[i] .. list[j] range. In other words, we want to assert that 1 // { q is not in list[0]..list[i-1] and list[j+1]..list[n-1] } at the beginning of the function. In other words, this is a precondition for the function. Let's see if this precondition is true at the beginning. Since \\(i\\) is \\(0\\) and \\(j\\) is \\(n-1\\) , the ranges list[0]..list[i-1] and list[j+1]..list[n-1] are empty, so the assertion is true. What happen if \\(i > j\\) ? This implies that \\(i - 1 > j - 1\\) , so the range list[0] .. list[i-1] and the range list[j+1] .. list[n-1] overlap. We can be sure that \\(q\\) is not anywhere in list . Let's see how we ensure this assertion is true in the recursive call. 1 2 3 4 5 : if ( list [ mid ] > q ) { return search ( list , i , mid -1 , q ); } : Line 3 of the snippet above is invoked only if list[mid] > q . Since the array list is sorted, we know for sure that any element in list[mid+1] .. list[j] is larger than \\(q\\) . So, \\(q\\) cannot be anywhere in that range. We can assert, between Lines 2 and 3 above: 1 // { q is not in list[0]..list[i-1] and list[mid]..list[n-1] } Thus, when Line 3 is invoked, the same assertion holds true. You can apply the same argument to the call: 1 return search ( list , mid + 1 , j , q ); To summarize, we annotate the code above with the assertions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * Look for q in list[i]..list[j]. * * @pre list is sorted * @pre q is not in list[0]..list[i-1] and list[j+1]..list[n-1] * @return -1 if not found, the position of q in list otherwise. */ long search ( const long list [], long i , long j , long q ) { if ( i > j ) { // { q is not in list[0]..list[n-1] } return -1 ; } long mid = ( i + j ) / 2 ; if ( list [ mid ] == q ) { return mid ; } if ( list [ mid ] > q ) { // { q is not in list[0]..list[i-1] and list[mid]..list[n-1] } return search ( list , i , mid -1 , q ); } // { q is not in list[0]..list[mid] and list[j+1]..list[n-1] } return search ( list , mid + 1 , j , q ); } How Efficient is Binary Search We have seen that if the input list is not sorted, then we minimally have to check every element in the list, leading to an \\(O(n)\\) algorithm. With a sorted input and using binary search, however, we can do a better. Let's consider the worst case, where \\(q\\) is not in the list. Note that every comparison we make, we reduce the range of elements to search by half, until we reach one element. We start with \\(n\\) elements that could possibly contain \\(q\\) . After one comparison, we are left with \\(n/2\\) . After another comparison, we are left with \\(n/4\\) , etc. It takes only \\(O(\\log n)\\) steps until we reach one element in the list. This is a big improvement over \\(O(n)\\) time: Suppose n is 1,000,000,000,000,000. Instead of scanning through and comparing one quadrillion elements, we only need to compare 50 of them! We can also argue that the running time of the code above is \\(O(\\log n)\\) , using the recurrence relation: \\[ T(n)= \\begin{cases} T(\\frac{n}{2}) + 1,& \\text{if } n > 1\\\\ 1, & \\text{otherwise} \\end{cases} \\] Now, \\[ \\begin{align*} T(n) &= T\\left(\\frac{n}{2}\\right) + 1 \\\\ &= T\\left(\\frac{n}{4}\\right) + 2 = \\cdots \\\\ &= T\\left(\\frac{n}{2^k}\\right) + k = \\cdots \\\\ &= T(1) + \\log n \\\\ &= O(\\log n) \\\\ \\end{align*} \\] The \"Magic\" of Binary Search How did we reduce the running time of searching from \\(O(n)\\) , where we have to check every element, to \\(O(\\log n)\\) ? The secret ingredient here is that we exploit the underlying property of the input array -- in this case, the fact that the array is sorted -- to help us eliminate some possibilities, allowing us to avoid redundant checks. As you will see in your upcoming assignment, exploiting underlying properties of inputs is a crucial weapon we have in speeding up our algorithm. Problem Set 22 Problem 22.1 Re-write the binary search algorithm using a loop. Problem 22.2 Instead of returning -1 if the query q is not found, modify the binary search algorithm in Problem 22.1 such that it returns either: a position k , such as a[k] <= q <= a[k+1] . -1 if q < a[0] n-1 if q > a[n-1]","title":"22. Searching"},{"location":"22-search.html#unit-23-searching","text":"","title":"Unit 23: Searching"},{"location":"22-search.html#learning-objectives","text":"After this unit students should be familiar with linear search and binary search algorithm, including understanding how the algorithms work, implementing the algorithms, arguing their correctness, and analyzing their running time.","title":"Learning Objectives"},{"location":"22-search.html#linear-search","text":"Let's continue the discussion on efficiency on one of the fundamental problems in computing: how to look for something. Given a list of items \\(L\\) and query item \\(q\\) , we wish find if \\(q\\) is in \\(L\\) . If \\(q\\) is in \\(L\\) , then we return the index of \\(q\\) . Otherwise, we return -1. Let's write a function to solve this. 1 2 3 4 5 6 7 8 9 10 11 12 13 /** * Look for q in list[0]..list[n-1]. * * @return -1 if not found, the position of q in list otherwise. */ long search ( long n , const long list [ n ], long q ) { for ( long i = 0 ; i < n ; i += 1 ) { if ( list [ i ] == q ) { return i ; } } return -1 ; } What is the worst-case running time, expressed in Big-O notation, of the function above? Suppose the query \\(q\\) is not in the list, we will have to scan the whole list, once. The worst case running time is, therefore, \\(O(n)\\) . Can we do better? It turns out that this running time \\(O(n)\\) is also the best that we can do because we cannot be sure that \\(q\\) does not exist until we check every single element in the list. So there is no shortcut. In previous units, we have seen recursive, divide-and-conquer solution for max . We can easily adapt it to search as well: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Look for q in list[i]..list[j]. * * @return -1 if not found, the position of q in list otherwise. */ long search ( const long list [], long i , long j , long q ) { if ( i > j ) { return -1 ; } long mid = ( i + j ) / 2 ; if ( list [ mid ] == q ) { return mid ; } long found = search ( list , i , mid -1 , q ); if ( found >= 0 ) { return found ; } return search ( list , mid + 1 , j , q ); } We then call this function with: 1 search ( list , 0 , n -1 , q ); In the code above, we first handle the base case where i > j , which means that the sublist list[i]..list[j] to search for q in, is empty. In this case, q is not found and we return -1. If the list list[i] .. list[j] is not empty, we check the element in the middle if it is q . If we have not yet find q , then we first search the left sublist. If still not found, we search the right sublist. and return the result. In the worst case, when q is not in the list, we still have to check through every element in the list. So the running time is still \\(O(n)\\) . It is no faster than searching with a for loop. We can also argue that the running time of the code above is \\(O(n)\\) , using the recurrence relation: \\[ T(n)= \\begin{cases} 2T(\\frac{n}{2}) + 1,& \\text{if } n > 1\\\\ 1, & \\text{otherwise} \\end{cases} \\] Here, \\[ \\begin{align*} T(n) &= 2T\\left(\\frac{n}{2}\\right) + 1 \\\\ &= 4T\\left(\\frac{n}{4}\\right) + 2 = \\cdots \\\\ &= 2^kT\\left(\\frac{n}{2^k}\\right) + k = \\cdots \\\\ &= nT(1) + \\log n \\\\ &= O(n) \\\\ \\end{align*} \\]","title":"Linear Search"},{"location":"22-search.html#binary-search","text":"But, do we always have to check every element in the list? It turns out that, like many real-life situations, if the input list is sorted , we do not have to scan through every element. We can eliminate a huge chunk of the elements based on whether a chosen element is bigger or smaller than \\(q\\) . Suppose that the input list is sorted in increasing order. Pick a random element \\(x\\) from the list. Any element to the left of \\(x\\) must be less than or equal to \\(x\\) , and any element to the right of \\(x\\) must be greater or equal to \\(x\\) . Suppose that \\(q > x\\) , then we know that \\(q\\) must be to the right of \\(x\\) , there is no need to search to the left of \\(x\\) . Otherwise, \\(q < x\\) , and \\(q\\) must be to the left of \\(x\\) , and there is no need to search to the right of \\(x\\) . We can modify the earlier recursive function into the one below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Look for q in list[i]..list[j]. * * @pre list is sorted * @return -1 if not found, the position of q in list otherwise. */ long search ( const long list [], long i , long j , long q ) { if ( i > j ) { return -1 ; } long mid = ( i + j ) / 2 ; if ( list [ mid ] == q ) { return mid ; } if ( list [ mid ] > q ) { return search ( list , i , mid -1 , q ); } return search ( list , mid + 1 , j , q ); } We have changed the function so that it only search either the left side or the right side, but never both. The search algorithm above is called binary search since it repeatedly cut the range of values to search by half.","title":"Binary Search"},{"location":"22-search.html#why-is-it-correct","text":"It is not obvious at first glance that the code above correctly searches for \\(q\\) in \\(L\\) . Let's analyze this function more systematically by writing an assertion for this function. What we want to do here is to eliminate elements in the array that cannot possibly contain \\(q\\) -- these are elements outside of the list[i] .. list[j] range. In other words, we want to assert that 1 // { q is not in list[0]..list[i-1] and list[j+1]..list[n-1] } at the beginning of the function. In other words, this is a precondition for the function. Let's see if this precondition is true at the beginning. Since \\(i\\) is \\(0\\) and \\(j\\) is \\(n-1\\) , the ranges list[0]..list[i-1] and list[j+1]..list[n-1] are empty, so the assertion is true. What happen if \\(i > j\\) ? This implies that \\(i - 1 > j - 1\\) , so the range list[0] .. list[i-1] and the range list[j+1] .. list[n-1] overlap. We can be sure that \\(q\\) is not anywhere in list . Let's see how we ensure this assertion is true in the recursive call. 1 2 3 4 5 : if ( list [ mid ] > q ) { return search ( list , i , mid -1 , q ); } : Line 3 of the snippet above is invoked only if list[mid] > q . Since the array list is sorted, we know for sure that any element in list[mid+1] .. list[j] is larger than \\(q\\) . So, \\(q\\) cannot be anywhere in that range. We can assert, between Lines 2 and 3 above: 1 // { q is not in list[0]..list[i-1] and list[mid]..list[n-1] } Thus, when Line 3 is invoked, the same assertion holds true. You can apply the same argument to the call: 1 return search ( list , mid + 1 , j , q ); To summarize, we annotate the code above with the assertions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * Look for q in list[i]..list[j]. * * @pre list is sorted * @pre q is not in list[0]..list[i-1] and list[j+1]..list[n-1] * @return -1 if not found, the position of q in list otherwise. */ long search ( const long list [], long i , long j , long q ) { if ( i > j ) { // { q is not in list[0]..list[n-1] } return -1 ; } long mid = ( i + j ) / 2 ; if ( list [ mid ] == q ) { return mid ; } if ( list [ mid ] > q ) { // { q is not in list[0]..list[i-1] and list[mid]..list[n-1] } return search ( list , i , mid -1 , q ); } // { q is not in list[0]..list[mid] and list[j+1]..list[n-1] } return search ( list , mid + 1 , j , q ); }","title":"Why is it correct?"},{"location":"22-search.html#how-efficient-is-binary-search","text":"We have seen that if the input list is not sorted, then we minimally have to check every element in the list, leading to an \\(O(n)\\) algorithm. With a sorted input and using binary search, however, we can do a better. Let's consider the worst case, where \\(q\\) is not in the list. Note that every comparison we make, we reduce the range of elements to search by half, until we reach one element. We start with \\(n\\) elements that could possibly contain \\(q\\) . After one comparison, we are left with \\(n/2\\) . After another comparison, we are left with \\(n/4\\) , etc. It takes only \\(O(\\log n)\\) steps until we reach one element in the list. This is a big improvement over \\(O(n)\\) time: Suppose n is 1,000,000,000,000,000. Instead of scanning through and comparing one quadrillion elements, we only need to compare 50 of them! We can also argue that the running time of the code above is \\(O(\\log n)\\) , using the recurrence relation: \\[ T(n)= \\begin{cases} T(\\frac{n}{2}) + 1,& \\text{if } n > 1\\\\ 1, & \\text{otherwise} \\end{cases} \\] Now, \\[ \\begin{align*} T(n) &= T\\left(\\frac{n}{2}\\right) + 1 \\\\ &= T\\left(\\frac{n}{4}\\right) + 2 = \\cdots \\\\ &= T\\left(\\frac{n}{2^k}\\right) + k = \\cdots \\\\ &= T(1) + \\log n \\\\ &= O(\\log n) \\\\ \\end{align*} \\]","title":"How Efficient is Binary Search"},{"location":"22-search.html#the-magic-of-binary-search","text":"How did we reduce the running time of searching from \\(O(n)\\) , where we have to check every element, to \\(O(\\log n)\\) ? The secret ingredient here is that we exploit the underlying property of the input array -- in this case, the fact that the array is sorted -- to help us eliminate some possibilities, allowing us to avoid redundant checks. As you will see in your upcoming assignment, exploiting underlying properties of inputs is a crucial weapon we have in speeding up our algorithm.","title":"The \"Magic\" of Binary Search"},{"location":"22-search.html#problem-set-22","text":"","title":"Problem Set 22"},{"location":"22-search.html#problem-221","text":"Re-write the binary search algorithm using a loop.","title":"Problem 22.1"},{"location":"22-search.html#problem-222","text":"Instead of returning -1 if the query q is not found, modify the binary search algorithm in Problem 22.1 such that it returns either: a position k , such as a[k] <= q <= a[k+1] . -1 if q < a[0] n-1 if q > a[n-1]","title":"Problem 22.2"},{"location":"23-sort.html","text":"Unit 24: Sorting Learning Objectives After this unit, students should: be familiar with four sorting algorithms: counting sort, selection sort, bubble sort, and insertion sort be able to implement the above algorithms, argue that they are correct, and analyzing their running time be aware of the difference between comparison-based sorting algorithms and counting sort be aware of the situations where insertion sort performs better than selection sort and bubble sort. be aware of the situations where counting sort performs better than other sorting algorithms. Sorting Sorting is one of the most fundamental computational problems. Given a list of items, we want to rearrange the items in some order. We have seen in the previous unit that searching in a sorted list gives us tremendous improvement in efficiency. In this unit, we assume that the items we wish to rearrange are integers, and we wish to rearrange them in increasing order. We could, however, in practice, sort any type of items. We have seen two algorithms to sort in this module: counting sort and selection sort. We are going to see two more today. Counting Sort Let's revisit counting sort. We are given an array of numbers, guaranteed to fall between a given range, say 0 to \\(MAX\\) . We can scan through this input array and count how many times each number appears in the input. We use another array of size \\(MAX+1\\) (let's call this the frequency array) to keep track of the counts. Once we are done, we loop through the frequency array and put the elements back into the output. Here is the code that implements the counting sort algorithm. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * Perform counting sort on the input in[] and store the sorted * numbers in out[]. * * @param[in] in The array containing numbers to be sorted. * @param[out] out The array containing the sorted numbers. * @param[in] len The size of the input and output array. * * @pre in[i] is between 0 and MAX for all i. * @post out[] is sorted */ void counting_sort ( size_t len , const long in [ len ], long out [ len ]) { size_t freq [ MAX + 1 ] = { 0 }; for ( size_t i = 0 ; i < len ; i += 1 ) { freq [ in [ i ]] += 1 ; } size_t outpos = 0 ; for ( long i = 0 ; i <= MAX ; i += 1 ) { for ( size_t j = outpos ; j < outpos + freq [ i ]; j += 1 ) { out [ j ] = i ; } outpos += freq [ i ]; } } Let's consider the running time of counting sort. We will break it down into three steps of counting sort. First, initializing freq array to 0 takes \\(O(MAX)\\) time. Second, looping through in and counting takes \\(O(n)\\) time (where \\(n\\) is len ). What about the third step: populating the output array with sorted numbers? This step involves a double for loop. You shouldn't jump to the conclusion that it takes \\(O(MAX^2)\\) or \\(O(n^2)\\) . Let's analyze this more carefully. We will go with a more intuitive/informal approach first. What we do here is to store the sorted numbers into the output, there are \\(n\\) numbers, so it seems reasonable to assume that this step takes \\(O(n)\\) time. Let's verify now with a more formal and systematic way. The inner loop: 1 2 3 for ( size_t j = outpos ; j < outpos + freq [ i ]; j += 1 ) { out [ j ] = i ; } takes \\(O(f_i)\\) time, where \\(f_i\\) is the freq[i] the number of times \\(i\\) appears. The outer loop loops through this for different \\(i\\) , from \\(i = 0, .. MAX\\) . So the total number of times is: \\[ \\sum_{i=0}^{MAX} f_i \\] This corresponds to the total number of times each number appears in the input, which is, well, just \\(n\\) . So indeed the third step takes \\(O(n)\\) . The runnning time for counting sort is thus \\(O(n + n + MAX)\\) , which is just \\(O(n + MAX)\\) . Note that since we do not know the relationship between \\(n\\) and \\(MAX\\) , we cannot simplify this term to either \\(O(n)\\) or \\(O(MAX)\\) . Selection Sort Recall that selection sort repeatedly find the maximum element and move it to the back of the array (assuming we are sorting in increasing order). Here is an implementation of selection sort. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /** * Find the index of the largest element among list[0..last]. * * @param[in] last The last element to search. * @param[in] list Input list * @return The index of the max element among list[0..last]. * Breaking ties by choosing the smaller index. * @pre list is not NULL and list[0] .. list[last] are valid. */ size_t max ( size_t last , const long list []) { long max_so_far = list [ 0 ]; size_t max_index = 0 ; for ( size_t i = 1 ; i <= last ; i += 1 ) { if ( list [ i ] > max_so_far ) { max_so_far = list [ i ]; max_index = i ; } } return max_index ; } /** * Sort a list using selection sort. * * @param[in] n The size of the list to sort. * @param[in] list The input list * @pre list is not NULL and list[0]..list[n-1] are valid * @post The list is sorted. */ void selection_sort ( size_t n , long list [ n ]) { for ( size_t j = n - 1 ; j >= 1 ; j -= 1 ) { size_t max_pos = max ( j , list ); swap ( list , max_pos , j ); } } We have seen that the running time for selection sort is \\(O(n^2)\\) . Selection vs Counting Sort Comparing the running of counting sort \\(O(n + MAX)\\) vs selection sort \\(O(n^2)\\) , it is clear that counting sort is more efficient -- we say that counting sort is a linear time algorithm and selection sort is a quadratic time algorithm. What is the magic of counting sort? Why don't we just use counting sort all the time and why bother learning about other sorting algorithms? It turns out that counting sort is special because it has an assumption that the input numbers fall into a certain range. If \\(MAX\\) is small, then counting sort is efficient. If \\(MAX\\) is say, the maximum long values, \\(2^{63}-1\\) , then counting sort is not necessarily more efficient (both in terms of time and space) in practice than selection sort. Because of this assumption, counting sort does not need to compare the inputs during sorting, and thus it can achieve a linear time. Selection sort, on the other hand, does not assume the range of the input numbers. It is a comparison sort since it compares the input numbers during sorting. It is therefore more general and has a wider range of applications. We now look at two more comparison-based sorting algorithms. Bubble Sort Bubble sort is probably the most well known, under-performed sorting algorithm 1 , but is taught in most CS classes because of its simplicity. The idea of bubble sort is to make multiple passes through the list. In each pass, we look for all possible adjacent pairs of items. Any adjacent pair that is out of order is swapped so that they are in order. This process repeats until everything is in order. Let's look at an example. Suppose we have, as an input, the numbers 8 4 23 42 16 15 . In the first pass, we start from the first item and check from left to right. The pair 8 4 is out of order, so we swap them, and we get 4 8 23 42 16 15 . The pair 8 23 and 23 42 are in order, so we do not need to swap them. The pair 42 16 is out of order. We swap them and get 4 8 23 16 42 15 . The pair 42 15 is again out of order, so we swap them and get 4 8 23 16 15 42 . The following sequence show the first pass through the array: 1 2 3 4 5 6 7 8 9 10 11 8 4 23 42 16 15 <- swap -- -- 4 8 23 42 16 15 -- -- 4 8 23 42 16 15 -- -- 4 8 23 42 16 15 <- swap -- -- 4 8 23 16 42 15 <- swap -- -- 4 8 23 16 15 42 After the first pass, notice that the largest element, 42, \"bubbles\" up through the list until it reaches the maximum position. We can now make the second pass, but we can exclude the last item since it is already in place. 1 2 3 4 5 6 7 8 9 10 4 8 23 16 15 42 -- -- 4 8 23 16 15 42 -- -- 4 8 23 16 15 42 <- swap -- -- 4 8 16 23 15 42 <- swap -- -- 4 8 16 15 23 42 -- -- After the second pass, the second largest element, 23, is in its position. So we can exclude this item in the subsequent pass. The rest of the passes operates similarly. In the \\(i\\) -th pass, we scan through array item 0 to \\(n-i\\) , swapping any adjacent element that is out of order, until \\(i = n - 1\\) , in which case we only have two elements, we swap them if we are out of order, and we are done! The code for bubble sort can be written as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 void bubble_pass ( size_t last , long a []) { for ( size_t i = 0 ; i < last ; i += 1 ) { if ( a [ i ] > a [ i + 1 ]) { swap ( a , i , i + 1 ); } } } void bubble_sort ( size_t n , long a [ n ]) { for ( size_t last = n - 1 ; last > 0 ; last -= 1 ) { bubble_pass ( last , a ); } } How many steps does it take to bubble-sort an array of \\(n\\) elements? Since the \\(i\\) -th pass scans through \\(n-i\\) elements, and there are a \\(n\\) passes in total, the analysis is similar to the one we did for the algorithm to compute the selection sort -- bubble sort takes \\(O(n^2)\\) steps. Insertion Sort The next sorting algorithm we are going to discuss is the insertion sort. This is another classic algorithm, that could perform better than bubble sort in some scenarios. The idea of insertion sort is simple: we partition the input list into two, a sorted partition, and an unsorted partition. Then we repeatedly take the first element from the unsorted partition, find its rightful place in the sorted partition, and insert it into place. We start with a sorted partition of one element, and we end if the sorted partition contains all the elements. Take 8 4 23 42 16 15 as an example. I will use | to partition the array into a left sorted partition, and a right, unsorted, partition. 1 8 | 4 23 42 16 15 We pick the first element on the unsorted partition, 4, and insert it into the sorted partition. This involves shifting the elements in the sorted partition to the right until we find the rightful place for 4 . After this step, the sorted partition grows by 1 and the unsorted partition shrinks by 1. 1 4 8 | 23 42 16 15 In the next round, we take 23 , and finds its rightful place. It turns out 23 is already in its correct place. 1 4 8 23 | 42 16 15 In the next step, 42 is also in its correct place. 1 4 8 23 42 | 16 15 16 is the next element, and we insert it between 8 and 23. 1 4 8 16 23 42 | 15 Finally, we insert 15 and we are done, as there is no more element in the unsorted partition. 1 4 8 15 16 23 42 The code for insertion sort can be written as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void insert ( long a [], size_t curr ) { size_t i = curr ; long temp = a [ curr ]; while ( i >= 1 && temp < a [ i - 1 ]) { a [ i ] = a [ i - 1 ]; i -= 1 ; } a [ i ] = temp ; } void insertion_sort ( size_t n , long a [ n ]) { for ( size_t curr = 1 ; curr < n ; curr += 1 ) { insert ( a , curr ); } } Animation Animations for various sorting algorithms, including some which you will learn in CS2040C, are available online on VisuAlgo . Problem Set 23 Problem 23.1 In the implementation of bubble sort above, we always make \\(n-1\\) passes through the array. It is, however, possible to stop the whole sorting procedure, when a pass through the array does not lead to any swapping. Modify the code above to achieve this optimization. Problem 23.2 (a) Suppose the input list to insertion sort is already sorted. What is the running time of insertion sort? (b) Suppose the input list to insertion sort is inversely sorted. What is the running time of insertion sort? Problem 23.3 In certain scenarios, comparison is more expensive than assignment. For instance, comparing two strings is more expensive than assigning a string to a variable. In this case, we can reduce the number of comparisons during insertion sort by doing the following: repeat take the first element X from unsorted partition use binary search to find the correct position to insert X insert X into the right place until the unsorted partition is empty. Implement the variation to insertion sort above. You may use your solution from Problem 22.1. https://www.youtube.com/watch?v=k4RRi_ntQc8 \u21a9","title":"23. Sorting"},{"location":"23-sort.html#unit-24-sorting","text":"","title":"Unit 24: Sorting"},{"location":"23-sort.html#learning-objectives","text":"After this unit, students should: be familiar with four sorting algorithms: counting sort, selection sort, bubble sort, and insertion sort be able to implement the above algorithms, argue that they are correct, and analyzing their running time be aware of the difference between comparison-based sorting algorithms and counting sort be aware of the situations where insertion sort performs better than selection sort and bubble sort. be aware of the situations where counting sort performs better than other sorting algorithms.","title":"Learning Objectives"},{"location":"23-sort.html#sorting","text":"Sorting is one of the most fundamental computational problems. Given a list of items, we want to rearrange the items in some order. We have seen in the previous unit that searching in a sorted list gives us tremendous improvement in efficiency. In this unit, we assume that the items we wish to rearrange are integers, and we wish to rearrange them in increasing order. We could, however, in practice, sort any type of items. We have seen two algorithms to sort in this module: counting sort and selection sort. We are going to see two more today.","title":"Sorting"},{"location":"23-sort.html#counting-sort","text":"Let's revisit counting sort. We are given an array of numbers, guaranteed to fall between a given range, say 0 to \\(MAX\\) . We can scan through this input array and count how many times each number appears in the input. We use another array of size \\(MAX+1\\) (let's call this the frequency array) to keep track of the counts. Once we are done, we loop through the frequency array and put the elements back into the output. Here is the code that implements the counting sort algorithm. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * Perform counting sort on the input in[] and store the sorted * numbers in out[]. * * @param[in] in The array containing numbers to be sorted. * @param[out] out The array containing the sorted numbers. * @param[in] len The size of the input and output array. * * @pre in[i] is between 0 and MAX for all i. * @post out[] is sorted */ void counting_sort ( size_t len , const long in [ len ], long out [ len ]) { size_t freq [ MAX + 1 ] = { 0 }; for ( size_t i = 0 ; i < len ; i += 1 ) { freq [ in [ i ]] += 1 ; } size_t outpos = 0 ; for ( long i = 0 ; i <= MAX ; i += 1 ) { for ( size_t j = outpos ; j < outpos + freq [ i ]; j += 1 ) { out [ j ] = i ; } outpos += freq [ i ]; } } Let's consider the running time of counting sort. We will break it down into three steps of counting sort. First, initializing freq array to 0 takes \\(O(MAX)\\) time. Second, looping through in and counting takes \\(O(n)\\) time (where \\(n\\) is len ). What about the third step: populating the output array with sorted numbers? This step involves a double for loop. You shouldn't jump to the conclusion that it takes \\(O(MAX^2)\\) or \\(O(n^2)\\) . Let's analyze this more carefully. We will go with a more intuitive/informal approach first. What we do here is to store the sorted numbers into the output, there are \\(n\\) numbers, so it seems reasonable to assume that this step takes \\(O(n)\\) time. Let's verify now with a more formal and systematic way. The inner loop: 1 2 3 for ( size_t j = outpos ; j < outpos + freq [ i ]; j += 1 ) { out [ j ] = i ; } takes \\(O(f_i)\\) time, where \\(f_i\\) is the freq[i] the number of times \\(i\\) appears. The outer loop loops through this for different \\(i\\) , from \\(i = 0, .. MAX\\) . So the total number of times is: \\[ \\sum_{i=0}^{MAX} f_i \\] This corresponds to the total number of times each number appears in the input, which is, well, just \\(n\\) . So indeed the third step takes \\(O(n)\\) . The runnning time for counting sort is thus \\(O(n + n + MAX)\\) , which is just \\(O(n + MAX)\\) . Note that since we do not know the relationship between \\(n\\) and \\(MAX\\) , we cannot simplify this term to either \\(O(n)\\) or \\(O(MAX)\\) .","title":"Counting Sort"},{"location":"23-sort.html#selection-sort","text":"Recall that selection sort repeatedly find the maximum element and move it to the back of the array (assuming we are sorting in increasing order). Here is an implementation of selection sort. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /** * Find the index of the largest element among list[0..last]. * * @param[in] last The last element to search. * @param[in] list Input list * @return The index of the max element among list[0..last]. * Breaking ties by choosing the smaller index. * @pre list is not NULL and list[0] .. list[last] are valid. */ size_t max ( size_t last , const long list []) { long max_so_far = list [ 0 ]; size_t max_index = 0 ; for ( size_t i = 1 ; i <= last ; i += 1 ) { if ( list [ i ] > max_so_far ) { max_so_far = list [ i ]; max_index = i ; } } return max_index ; } /** * Sort a list using selection sort. * * @param[in] n The size of the list to sort. * @param[in] list The input list * @pre list is not NULL and list[0]..list[n-1] are valid * @post The list is sorted. */ void selection_sort ( size_t n , long list [ n ]) { for ( size_t j = n - 1 ; j >= 1 ; j -= 1 ) { size_t max_pos = max ( j , list ); swap ( list , max_pos , j ); } } We have seen that the running time for selection sort is \\(O(n^2)\\) .","title":"Selection Sort"},{"location":"23-sort.html#selection-vs-counting-sort","text":"Comparing the running of counting sort \\(O(n + MAX)\\) vs selection sort \\(O(n^2)\\) , it is clear that counting sort is more efficient -- we say that counting sort is a linear time algorithm and selection sort is a quadratic time algorithm. What is the magic of counting sort? Why don't we just use counting sort all the time and why bother learning about other sorting algorithms? It turns out that counting sort is special because it has an assumption that the input numbers fall into a certain range. If \\(MAX\\) is small, then counting sort is efficient. If \\(MAX\\) is say, the maximum long values, \\(2^{63}-1\\) , then counting sort is not necessarily more efficient (both in terms of time and space) in practice than selection sort. Because of this assumption, counting sort does not need to compare the inputs during sorting, and thus it can achieve a linear time. Selection sort, on the other hand, does not assume the range of the input numbers. It is a comparison sort since it compares the input numbers during sorting. It is therefore more general and has a wider range of applications. We now look at two more comparison-based sorting algorithms.","title":"Selection vs Counting Sort"},{"location":"23-sort.html#bubble-sort","text":"Bubble sort is probably the most well known, under-performed sorting algorithm 1 , but is taught in most CS classes because of its simplicity. The idea of bubble sort is to make multiple passes through the list. In each pass, we look for all possible adjacent pairs of items. Any adjacent pair that is out of order is swapped so that they are in order. This process repeats until everything is in order. Let's look at an example. Suppose we have, as an input, the numbers 8 4 23 42 16 15 . In the first pass, we start from the first item and check from left to right. The pair 8 4 is out of order, so we swap them, and we get 4 8 23 42 16 15 . The pair 8 23 and 23 42 are in order, so we do not need to swap them. The pair 42 16 is out of order. We swap them and get 4 8 23 16 42 15 . The pair 42 15 is again out of order, so we swap them and get 4 8 23 16 15 42 . The following sequence show the first pass through the array: 1 2 3 4 5 6 7 8 9 10 11 8 4 23 42 16 15 <- swap -- -- 4 8 23 42 16 15 -- -- 4 8 23 42 16 15 -- -- 4 8 23 42 16 15 <- swap -- -- 4 8 23 16 42 15 <- swap -- -- 4 8 23 16 15 42 After the first pass, notice that the largest element, 42, \"bubbles\" up through the list until it reaches the maximum position. We can now make the second pass, but we can exclude the last item since it is already in place. 1 2 3 4 5 6 7 8 9 10 4 8 23 16 15 42 -- -- 4 8 23 16 15 42 -- -- 4 8 23 16 15 42 <- swap -- -- 4 8 16 23 15 42 <- swap -- -- 4 8 16 15 23 42 -- -- After the second pass, the second largest element, 23, is in its position. So we can exclude this item in the subsequent pass. The rest of the passes operates similarly. In the \\(i\\) -th pass, we scan through array item 0 to \\(n-i\\) , swapping any adjacent element that is out of order, until \\(i = n - 1\\) , in which case we only have two elements, we swap them if we are out of order, and we are done! The code for bubble sort can be written as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 void bubble_pass ( size_t last , long a []) { for ( size_t i = 0 ; i < last ; i += 1 ) { if ( a [ i ] > a [ i + 1 ]) { swap ( a , i , i + 1 ); } } } void bubble_sort ( size_t n , long a [ n ]) { for ( size_t last = n - 1 ; last > 0 ; last -= 1 ) { bubble_pass ( last , a ); } } How many steps does it take to bubble-sort an array of \\(n\\) elements? Since the \\(i\\) -th pass scans through \\(n-i\\) elements, and there are a \\(n\\) passes in total, the analysis is similar to the one we did for the algorithm to compute the selection sort -- bubble sort takes \\(O(n^2)\\) steps.","title":"Bubble Sort"},{"location":"23-sort.html#insertion-sort","text":"The next sorting algorithm we are going to discuss is the insertion sort. This is another classic algorithm, that could perform better than bubble sort in some scenarios. The idea of insertion sort is simple: we partition the input list into two, a sorted partition, and an unsorted partition. Then we repeatedly take the first element from the unsorted partition, find its rightful place in the sorted partition, and insert it into place. We start with a sorted partition of one element, and we end if the sorted partition contains all the elements. Take 8 4 23 42 16 15 as an example. I will use | to partition the array into a left sorted partition, and a right, unsorted, partition. 1 8 | 4 23 42 16 15 We pick the first element on the unsorted partition, 4, and insert it into the sorted partition. This involves shifting the elements in the sorted partition to the right until we find the rightful place for 4 . After this step, the sorted partition grows by 1 and the unsorted partition shrinks by 1. 1 4 8 | 23 42 16 15 In the next round, we take 23 , and finds its rightful place. It turns out 23 is already in its correct place. 1 4 8 23 | 42 16 15 In the next step, 42 is also in its correct place. 1 4 8 23 42 | 16 15 16 is the next element, and we insert it between 8 and 23. 1 4 8 16 23 42 | 15 Finally, we insert 15 and we are done, as there is no more element in the unsorted partition. 1 4 8 15 16 23 42 The code for insertion sort can be written as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void insert ( long a [], size_t curr ) { size_t i = curr ; long temp = a [ curr ]; while ( i >= 1 && temp < a [ i - 1 ]) { a [ i ] = a [ i - 1 ]; i -= 1 ; } a [ i ] = temp ; } void insertion_sort ( size_t n , long a [ n ]) { for ( size_t curr = 1 ; curr < n ; curr += 1 ) { insert ( a , curr ); } }","title":"Insertion Sort"},{"location":"23-sort.html#animation","text":"Animations for various sorting algorithms, including some which you will learn in CS2040C, are available online on VisuAlgo .","title":"Animation"},{"location":"23-sort.html#problem-set-23","text":"","title":"Problem Set 23"},{"location":"23-sort.html#problem-231","text":"In the implementation of bubble sort above, we always make \\(n-1\\) passes through the array. It is, however, possible to stop the whole sorting procedure, when a pass through the array does not lead to any swapping. Modify the code above to achieve this optimization.","title":"Problem 23.1"},{"location":"23-sort.html#problem-232","text":"(a) Suppose the input list to insertion sort is already sorted. What is the running time of insertion sort? (b) Suppose the input list to insertion sort is inversely sorted. What is the running time of insertion sort?","title":"Problem 23.2"},{"location":"23-sort.html#problem-233","text":"In certain scenarios, comparison is more expensive than assignment. For instance, comparing two strings is more expensive than assigning a string to a variable. In this case, we can reduce the number of comparisons during insertion sort by doing the following: repeat take the first element X from unsorted partition use binary search to find the correct position to insert X insert X into the right place until the unsorted partition is empty. Implement the variation to insertion sort above. You may use your solution from Problem 22.1. https://www.youtube.com/watch?v=k4RRi_ntQc8 \u21a9","title":"Problem 23.3"},{"location":"29-stdio.html","text":"Unit 29: Standard I/O Functions We have been shielding you from the pain and pitfalls of using C I/O functions. Since you are close to \"graduate\" from CS1010, this is a good time to show you what the real world is like. printf The function printf is used to print a formatted string to the standard output. Unlike functions that we have seen so far, printf can take in a variable number of arguments, but it must have at least one argument -- a string written in a certain format. The rest of the arguments can be of different types. Let's look at an example: 1 2 char * name = \"Siri\" ; printf ( \"Hello! My name is %s. \\n \" , name ); The code above prints Hello! My name is Siri. . There are two arguments to printf , both are strings. The first is the string to print. There is a placeholder %s in the string, which will be replaced by the second argument name . The string to print ends with \\n , which is the new line character. The placeholder %s is called a format modifier . It controls how to interpret the arguments (i.e., what type) and how to format the output. The general format is: 1 %[flags][field_width][.precision][length_modifier]specifier The letter after % specifier controls the interpretation of the argument. s for string, c for character, d for integer (base 10), f for floating-point number, p for pointer (base 16). We can additionally prepend this with length modifier . ld for long integer, lld for long long , and lf for double . To format the output, we can prepend it with a number to indicate its field width , or minimum space used when printing. E.g., %3d will pad the number printed with space if the number printed is less than 3 digits. Adding a flag 0 in front, %03d , will pad the number with 0s if the number printed is less than 3 digits. Other flags include + , which tells printf to print a sign ( + or - ) for the number. For floating-point numbers, we can additionally control the precision , or the number of digits printed after the decimal point. %3.4lf will print a double to four decimal points. Note: cs1010_println_double uses %.4lf as the format modifier. Pitfalls when using printf Mismatch Types printf does not check for the type of arguments we pass to it. The compiler does, but it only politely warns us instead of throwing an error like other type mismatches. If you ignore such warnings, you might print strange things like: 1 printf ( \"%d %f \\n \" , 100000000000 , 100000000000 ); or worse, crash your program: 1 printf ( \"%s %s \\n \" , 100000000000 , 100000000000 ); Mismatch Number of Arguments Since printf expects a variable number of arguments, you can pass it fewer arguments than expected and the code would still compile (with warnings). If you push ahead and run it anyway, printf will start to fetch arguments from the stack, pretending that it is there, causing weird things to happen. Consider: 1 printf ( \"%d %s %s \\n \" , 10 ); It would cause printf to access the memory content of the stack as strings. Printing User Input We should also never do this: 1 2 char * str = cs1010_read_word (); printf ( str ); The reason is that we have no control over what the user would type as input: the user may type \"%s\" into the standard input, so the variable str now points to %s , which printf treats as a format modifier, and output the content of the stack! This is a huge security risk. We should always print a string using: 1 printf ( \"%s\" , str ); scanf The function scanf is used to read inputs from the standard input. It requires us to pass in pointers to variables where we want to store the input value is. Like printf , it takes in one or more arguments, with the first argument being a format string containing one or more format specifiers. The format specifier for scanf is simpler and has the following pattern: 1 %[*][field_width][length_modifier]specifier For instance, to read an integer, a floating-point number, and a string of at most 10 characters, 1 2 3 4 long l ; double d ; char s [ 11 ]; scanf ( \"%ld %lf %10s\" , & l , & d , s ); scanf scans the standard input, try to match it to the format specified. The space in between the format specifier matches zero or more white spaces (space, tab, newline). Scanning stops when an input character does not match such a format character or when an input conversion fails. Adding a * to the format modifier means that scanf should consume the inputs but not store it in any variables. This, combined with %[ ] is useful to clear any remaining data from the standard input. Pitfalls When Using scanf Checking for Error The function scanf fails silently when the input character does not match a format or when the input conversion fails. It might return an unexpected input. We should always check the return value of scanf to make sure that it is reading properly. 1 2 3 long a ; scanf ( \"%ld\" , & a ); printf ( \"%ld\" , a ); The code above might print an uninitialized value if the input is not an integer. We should check 1 2 3 4 5 long a ; long result = scanf ( \"%ld\" , & a ); if ( result == 1 ) { printf ( \"%ld\" , a ); } The above, however, does not properly \"clear\" the standard input of the incorrect input. So the next scanf calls would still try to read it again! To clear the input, we can use the %*[^\\n] modifier, which read in any characters expect ( ^ ) the newline ( \\n ). 1 2 3 4 5 6 7 long a ; long result = scanf ( \"%ld\" , & a ); if ( result == 1 ) { printf ( \"%ld\" , a ); } else { scanf ( \"*[^ \\n ]\" ); } As a side note, the %[] modifier is useful to read in strings containing a certain range of characters only. E.g., you can read %[a-zA-Z0-9] to match any sequence of alphanumeric characters. Invalid Pointers Since scanf expects the caller to pass in pointers to variables for it to store the results, we need to be careful about what we pass in. It is easy to pass in something like this: 1 2 long * a ; scanf ( \"%ld\" , a ); The compiler would not warn us since the type matches perfectly. The program may crash since the pointer is not pointing to a valid memory location accessible by the program. Buffer Overflow When we use scanf to read a string, it keeps reading until it reaches space, and stores everything that it reads into an array. The problem here is that we do not know when it will stop reading, and therefore how big is the array that we need to allocate for the input! Let's say we do: 1 2 3 4 char name [ 10 ]; printf ( \"What's your name?\" , name ); scanf ( \"%s\" , name ); printf ( \"Hello %s! \\n \" , name ); The program would crash if we enter a very long string in the standard input. You can read a beginners' guide away from scanf() for more information. fgets fgets is a better alternative to scanf for reading inputs (Note: this is what CS1010 library use internally). fgets takes three parameters, a pointer to a string (or buffer), the size of the buffer, and the input to read from (which can be a file, a network socket, or in our case, most of the time stdin ). The advantage of fgets is that it never overflows the buffer (it knows the size). Once we read the input, we can use functions such as strtol or strtod to convert the strings to long or double . Avoid atol or atof Instead of strtol or strtof , some old school textbooks might show you that you can convert a string to a long or a double using atol or atof . You should avoid these two functions (even the man pages of atof says so!). They do not provide any mechanism for error checking if the string is not a valid integer or if the input is out of range of the type. You can read the source code for the CS1010 library to see how it uses fgets , strtol and related functions to parse numbers and strings from the standard inputs.","title":"Unit 29: Standard I/O Functions"},{"location":"29-stdio.html#unit-29-standard-io-functions","text":"We have been shielding you from the pain and pitfalls of using C I/O functions. Since you are close to \"graduate\" from CS1010, this is a good time to show you what the real world is like.","title":"Unit 29: Standard I/O Functions"},{"location":"29-stdio.html#printf","text":"The function printf is used to print a formatted string to the standard output. Unlike functions that we have seen so far, printf can take in a variable number of arguments, but it must have at least one argument -- a string written in a certain format. The rest of the arguments can be of different types. Let's look at an example: 1 2 char * name = \"Siri\" ; printf ( \"Hello! My name is %s. \\n \" , name ); The code above prints Hello! My name is Siri. . There are two arguments to printf , both are strings. The first is the string to print. There is a placeholder %s in the string, which will be replaced by the second argument name . The string to print ends with \\n , which is the new line character. The placeholder %s is called a format modifier . It controls how to interpret the arguments (i.e., what type) and how to format the output. The general format is: 1 %[flags][field_width][.precision][length_modifier]specifier The letter after % specifier controls the interpretation of the argument. s for string, c for character, d for integer (base 10), f for floating-point number, p for pointer (base 16). We can additionally prepend this with length modifier . ld for long integer, lld for long long , and lf for double . To format the output, we can prepend it with a number to indicate its field width , or minimum space used when printing. E.g., %3d will pad the number printed with space if the number printed is less than 3 digits. Adding a flag 0 in front, %03d , will pad the number with 0s if the number printed is less than 3 digits. Other flags include + , which tells printf to print a sign ( + or - ) for the number. For floating-point numbers, we can additionally control the precision , or the number of digits printed after the decimal point. %3.4lf will print a double to four decimal points. Note: cs1010_println_double uses %.4lf as the format modifier.","title":"printf"},{"location":"29-stdio.html#pitfalls-when-using-printf","text":"","title":"Pitfalls when using printf"},{"location":"29-stdio.html#mismatch-types","text":"printf does not check for the type of arguments we pass to it. The compiler does, but it only politely warns us instead of throwing an error like other type mismatches. If you ignore such warnings, you might print strange things like: 1 printf ( \"%d %f \\n \" , 100000000000 , 100000000000 ); or worse, crash your program: 1 printf ( \"%s %s \\n \" , 100000000000 , 100000000000 );","title":"Mismatch Types"},{"location":"29-stdio.html#mismatch-number-of-arguments","text":"Since printf expects a variable number of arguments, you can pass it fewer arguments than expected and the code would still compile (with warnings). If you push ahead and run it anyway, printf will start to fetch arguments from the stack, pretending that it is there, causing weird things to happen. Consider: 1 printf ( \"%d %s %s \\n \" , 10 ); It would cause printf to access the memory content of the stack as strings.","title":"Mismatch Number of Arguments"},{"location":"29-stdio.html#printing-user-input","text":"We should also never do this: 1 2 char * str = cs1010_read_word (); printf ( str ); The reason is that we have no control over what the user would type as input: the user may type \"%s\" into the standard input, so the variable str now points to %s , which printf treats as a format modifier, and output the content of the stack! This is a huge security risk. We should always print a string using: 1 printf ( \"%s\" , str );","title":"Printing User Input"},{"location":"29-stdio.html#scanf","text":"The function scanf is used to read inputs from the standard input. It requires us to pass in pointers to variables where we want to store the input value is. Like printf , it takes in one or more arguments, with the first argument being a format string containing one or more format specifiers. The format specifier for scanf is simpler and has the following pattern: 1 %[*][field_width][length_modifier]specifier For instance, to read an integer, a floating-point number, and a string of at most 10 characters, 1 2 3 4 long l ; double d ; char s [ 11 ]; scanf ( \"%ld %lf %10s\" , & l , & d , s ); scanf scans the standard input, try to match it to the format specified. The space in between the format specifier matches zero or more white spaces (space, tab, newline). Scanning stops when an input character does not match such a format character or when an input conversion fails. Adding a * to the format modifier means that scanf should consume the inputs but not store it in any variables. This, combined with %[ ] is useful to clear any remaining data from the standard input.","title":"scanf"},{"location":"29-stdio.html#pitfalls-when-using-scanf","text":"","title":"Pitfalls When Using scanf"},{"location":"29-stdio.html#checking-for-error","text":"The function scanf fails silently when the input character does not match a format or when the input conversion fails. It might return an unexpected input. We should always check the return value of scanf to make sure that it is reading properly. 1 2 3 long a ; scanf ( \"%ld\" , & a ); printf ( \"%ld\" , a ); The code above might print an uninitialized value if the input is not an integer. We should check 1 2 3 4 5 long a ; long result = scanf ( \"%ld\" , & a ); if ( result == 1 ) { printf ( \"%ld\" , a ); } The above, however, does not properly \"clear\" the standard input of the incorrect input. So the next scanf calls would still try to read it again! To clear the input, we can use the %*[^\\n] modifier, which read in any characters expect ( ^ ) the newline ( \\n ). 1 2 3 4 5 6 7 long a ; long result = scanf ( \"%ld\" , & a ); if ( result == 1 ) { printf ( \"%ld\" , a ); } else { scanf ( \"*[^ \\n ]\" ); } As a side note, the %[] modifier is useful to read in strings containing a certain range of characters only. E.g., you can read %[a-zA-Z0-9] to match any sequence of alphanumeric characters.","title":"Checking for Error"},{"location":"29-stdio.html#invalid-pointers","text":"Since scanf expects the caller to pass in pointers to variables for it to store the results, we need to be careful about what we pass in. It is easy to pass in something like this: 1 2 long * a ; scanf ( \"%ld\" , a ); The compiler would not warn us since the type matches perfectly. The program may crash since the pointer is not pointing to a valid memory location accessible by the program.","title":"Invalid Pointers"},{"location":"29-stdio.html#buffer-overflow","text":"When we use scanf to read a string, it keeps reading until it reaches space, and stores everything that it reads into an array. The problem here is that we do not know when it will stop reading, and therefore how big is the array that we need to allocate for the input! Let's say we do: 1 2 3 4 char name [ 10 ]; printf ( \"What's your name?\" , name ); scanf ( \"%s\" , name ); printf ( \"Hello %s! \\n \" , name ); The program would crash if we enter a very long string in the standard input. You can read a beginners' guide away from scanf() for more information.","title":"Buffer Overflow"},{"location":"29-stdio.html#fgets","text":"fgets is a better alternative to scanf for reading inputs (Note: this is what CS1010 library use internally). fgets takes three parameters, a pointer to a string (or buffer), the size of the buffer, and the input to read from (which can be a file, a network socket, or in our case, most of the time stdin ). The advantage of fgets is that it never overflows the buffer (it knows the size). Once we read the input, we can use functions such as strtol or strtod to convert the strings to long or double .","title":"fgets"},{"location":"29-stdio.html#avoid-atol-or-atof","text":"Instead of strtol or strtof , some old school textbooks might show you that you can convert a string to a long or a double using atol or atof . You should avoid these two functions (even the man pages of atof says so!). They do not provide any mechanism for error checking if the string is not a valid integer or if the input is out of range of the type. You can read the source code for the CS1010 library to see how it uses fgets , strtol and related functions to parse numbers and strings from the standard inputs.","title":"Avoid atol or atof"},{"location":"about.html","text":"About CS1010 Module Description This module introduces the fundamental concepts of problem solving by computing and programming using an imperative programming language. It is the first and foremost introductory course to computing. It is also the first part of a three-part series on introductory programming and problem solving by computing, which also includes CS2030 and CS2040. Topics covered include problem solving by computing, writing pseudo-codes, basic problem formulation and problem solving, program development, coding, testing and debugging, fundamental programming constructs (variables, types, expressions, assignments, functions, control structures, etc.), fundamental data structures: arrays, strings and structures, simple file processing, and basic recursion. This module is appropriate for SoC students. Who/Where/When Instructor : Ooi Wei Tsang Lecture Venue : Online ( Zoom link ) Lecture Time : Every Monday, 12noon - 2pm Q&A Hour via Zoom : Wei Tsang: Every Tuesday, 4pm - 5pm, at AS6 #05-14 or ( Zoom link ) Important Dates Midterm Assessment : Monday, 27 September, 2021 (12noon - 2pm) Practical Exam 1 : Saturday, 2 October, 2021 (9am - 12noon) Practical Exam 2 : Saturday, 6 November, 2021 (9am - 12noon) Final Assessment : Tuesday, 25 November, 2021 (5pm - 7pm) All assessments above are conducted online. Assessment Weightage Programming Assignments : 30% Final Assessment : 25% Midterm Assessment : 10% Practical Exam 1 : 10% Practical Exam 2 : 15% Online Quizzes : 10%","title":"About CS1010"},{"location":"about.html#about-cs1010","text":"","title":"About CS1010"},{"location":"about.html#module-description","text":"This module introduces the fundamental concepts of problem solving by computing and programming using an imperative programming language. It is the first and foremost introductory course to computing. It is also the first part of a three-part series on introductory programming and problem solving by computing, which also includes CS2030 and CS2040. Topics covered include problem solving by computing, writing pseudo-codes, basic problem formulation and problem solving, program development, coding, testing and debugging, fundamental programming constructs (variables, types, expressions, assignments, functions, control structures, etc.), fundamental data structures: arrays, strings and structures, simple file processing, and basic recursion. This module is appropriate for SoC students.","title":"Module Description"},{"location":"about.html#whowherewhen","text":"Instructor : Ooi Wei Tsang Lecture Venue : Online ( Zoom link ) Lecture Time : Every Monday, 12noon - 2pm Q&A Hour via Zoom : Wei Tsang: Every Tuesday, 4pm - 5pm, at AS6 #05-14 or ( Zoom link )","title":"Who/Where/When"},{"location":"about.html#important-dates","text":"Midterm Assessment : Monday, 27 September, 2021 (12noon - 2pm) Practical Exam 1 : Saturday, 2 October, 2021 (9am - 12noon) Practical Exam 2 : Saturday, 6 November, 2021 (9am - 12noon) Final Assessment : Tuesday, 25 November, 2021 (5pm - 7pm) All assessments above are conducted online.","title":"Important Dates"},{"location":"about.html#assessment-weightage","text":"Programming Assignments : 30% Final Assessment : 25% Midterm Assessment : 10% Practical Exam 1 : 10% Practical Exam 2 : 15% Online Quizzes : 10%","title":"Assessment Weightage"},{"location":"accounts.html","text":"CS1010 Accounts We will be using a variety of services for CS1010. To take CS1010, please make sure you have the following accounts: SoC UNIX Account You can get one here: https://mysoc.nus.edu.sg/~newacct/ This account allows you to access SoC UNIX resources, including the main computing host running Solaris, sunfire , and computer clusters running Ubuntu / CentOS. We will be using the compute clusters for CS1010. Make sure that \"General Unix Servers\" and \"The SoC Compute Cluster\" are enabled in MySoC here: https://mysoc.nus.edu.sg/~myacct/services.cgi GitHub Account CS1010 uses GitHub Classroom for programming assignment submissions and grading. You should register for a GitHub account if you do not have one. This account will likely stay with you for the rest of your computing career. So choose your username wisely. Piazza Account CS1010 uses Piazza for Q&A and discussion. You should have received an email to register for Piazza.","title":"Accounts"},{"location":"accounts.html#cs1010-accounts","text":"We will be using a variety of services for CS1010. To take CS1010, please make sure you have the following accounts:","title":"CS1010 Accounts"},{"location":"accounts.html#soc-unix-account","text":"You can get one here: https://mysoc.nus.edu.sg/~newacct/ This account allows you to access SoC UNIX resources, including the main computing host running Solaris, sunfire , and computer clusters running Ubuntu / CentOS. We will be using the compute clusters for CS1010. Make sure that \"General Unix Servers\" and \"The SoC Compute Cluster\" are enabled in MySoC here: https://mysoc.nus.edu.sg/~myacct/services.cgi","title":"SoC UNIX Account"},{"location":"accounts.html#github-account","text":"CS1010 uses GitHub Classroom for programming assignment submissions and grading. You should register for a GitHub account if you do not have one. This account will likely stay with you for the rest of your computing career. So choose your username wisely.","title":"GitHub Account"},{"location":"accounts.html#piazza-account","text":"CS1010 uses Piazza for Q&A and discussion. You should have received an email to register for Piazza.","title":"Piazza Account"},{"location":"as01.html","text":"Assignment 1 Deadline 7 September 2021 (Tuesday), 23:59 pm. Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 0 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. Learning Outcomes Be comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, and conditional if / else statements. Be comfortable breaking down a problem into smaller sub-problems that can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function. Setup First, accept the assignment on GitHub Then, log in to one of the hosts of CS1010 programming environment and run 1 ~cs1010/get-as01 You should see the folder as01-<github username> in your home directory with the assignment skeleton inside. Inside that directory, you should see the following files: pyramid.c , digits.c , suffix.c , and taxi.c are the most important files. They are the skeleton C code that you should edit to solve the assignment and the only files that you should change. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 0 so you should already be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. compiler_flags.txt and .clang-tidy are two files used to configure clang and clang-tidy respectively. You do not need to edit this. Solving The Assignments Edit the files pyramid.c , digits.c , suffix.c , and taxi.c to solve the corresponding question as described below. To compile and run the given tests with the sample inputs and outputs, run on the command line, 1 make This command will compile the C files. If there is no compilation error, it will run the test scripts. To compile (and only compile) your code for a specific problem, pass in the name as an argument. Example: 1 make digits To test (and only test) your program for a specific problem, run the test.sh script: 1 ./test.sh digits You can read more about how you can become a power user of make in CS1010 . This list of common clang warnings and error messages might be helpful. Clean Compilation This is a reminder that, for your lab assignments and practical exams, any submission that cannot compile will receive 0. Further, each warning will lead to a -1 mark deduction. So, please make sure that your code does not generate any error or warning. You can ensure this by running make before submission. Submission When you are ready, run the following command to submit: 1 ~cs1010/submit-as01 The four files pyramid.c , digits.c , suffix.c , and taxi.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Manipulating Files on GitHub Do not manipulate (e.g., edit) the files on GitHub or close the pull requests on GitHub. Doing so would interfere with the scripts and the grading/testing process of CS1010. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial lab group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Dolores Abernathy (Group E01) Grading This assignment contributes towards 3% of your final grade. The total marks for this assignment are 30 marks. For Programming Assignment 1, the sole criterion for grading is correctness -- this includes the correctness of syntax, practices, approach, and logic, and whether you correctly follow our instructions. Note that even if your solution produces the correct output every time, it may not get full marks if the approach is wrong. Question 1: Pyramid (5 marks) A right rectangular pyramid is a 3D shape with a rectangle as a base and four isosceles triangular sides that meet at its apex. We can specify such a pyramid with three parameters, the width \\(w\\) of the base, the length \\(l\\) of the base, and the height \\(h\\) of the apex (perpendicular distance between the apex and the base). Our task is to calculate the surface area of a pyramid, by decomposing this calculation into three smaller functions. To complete this task, in pyramid.c , Write a function hypotenuse_of to compute the hypotenuse of a right-angled triangle, given the length of the legs (the sides adjacent to the right angle). Write a function area_of_rectangle that computes the area of a rectangle given the width and height of the rectangle. Write a function area_of_triangle that computes the area of a triangle using Heron's formula (see Exercise 1), given the length of the three sides. Finally, complete the program pyramid.c so that it reads, from the standard input, three positive integers representing the width, length, and height of the pyramid (in that order) and prints, to the standard output, its surface area. Solve this by using composing the three functions above. You may add additional functions if needed. Pay attention to the types ( long or double ) used in the inputs, calculations, and outputs. Keep the variable as integer type ( long ) as long as possible. Sample Run 1 2 3 4 5 6 ooiwt@pe111:~/as01-ooiwt$ ./pyramid 6 8 12 222.8492 ooiwt@pe111:~/as01-ooiwt$ ./pyramid 10 20 30 1124.5040 Question 2: Digits (5 marks) Write a program digits.c that reads in a non-negative integer, and prints the sum of the individual digits in this integer. For instance, if the input is 1933091 , then the sum is 1 + 9 + 3 + 3 + 0 + 9 + 1 = 26. You must not use a loop to solve this. Instead write a recursive function sum_of_digits . This function takes in an integer and returns the sum of the individual digit of that integer, and it should call itself to solve this question, for a smaller integer. A solution that uses a loop in any way will receive 0 marks for this question. Sample Run 1 2 3 4 5 6 ooiwt@pe111:~/as01-ooiwt$ ./digits 1933091 26 ooiwt@pe111:~/as01-ooiwt$ ./digits 10 1 Question 3: Ordinal Suffix (5 marks) In English, an ordinal number is written with numerals, followed by its letter suffixes. For instance: 1st, 2nd, 3rd, 4th, 11th, 31st, etc. The rule is that a number that ends with digit 1 should have a suffix \"st\" (except if it ends with 11), a number that ends with 2 should have a suffix \"nd\" (except if it ends with 12), and a number that ends with 3 should have a suffix \"rd\" (except if it ends with 13). All other numbers should end with \"th\". Write a program suffix that reads in an integer number from the standard input and prints out the number with its ordinal suffix. Your program should include a void function print_with_suffix(long n) that takes in the input and prints out the number followed by its suffix. 1 2 3 4 5 6 7 8 9 10 11 12 ooiwt@pe112:~/as01-ooiwt$ ./suffix 2 2nd ooiwt@pe112:~/as01-ooiwt$ ./suffix 13 13th ooiwt@pe112:~/as01-ooiwt$ ./suffix 412 412th ooiwt@pe112:~/as01-ooiwt$ ./suffix 3 3rd Question 4: Taxi Fare (15 marks) The taxi fare structure in Singapore must be one of the most complicated in the world! Check out: http://www.taxisingapore.com/taxi-fare/ . For this exercise, we will just use the following simplified fare structure: Basic Fare The first 1 km or less (Flag Down) $3.70 Every 400 m thereafter or less, up to 10 km $0.22 Every 350 m thereafter or less, after 10 km $0.22 Surcharge Monday to Friday 6:00 to 9:29 25% of metered fare Daily 18:00 to 23:59 25% of metered fare Daily 0:00 (midnight) to 5:59 50% of metered fare Note that the surcharge is applicable based on the boarding time. For instance, if the trip started at 17:50 and ended at 18:10, then no surcharge is incurred. Write a program taxi.c that computes the taxi fare. The program, called taxi , takes in four integers as inputs: The first is the day of the week. It can only be the value 1 to 7 , 1 being Monday, 7 being Sunday. The second and the third is the starting time of the trip: the second input indicates the hours since midnight of the stated day, the third input indicates the minutes since the beginning of the stated hours. The fourth and final input is the distance of the trip, in meters. Your program should print a single floating point number, which is the cost of the fare in dollars. Examine the following examples for more details: Example 1 1 2 3 ooiwt@pe111:~/as01-ooiwt$ ./taxi 1 17 59 1000 3.7000 Start: Mon 17:59 Distance: 1,000 m The metered fare is $3.70 since the distance traveled is 1km. The boarding time is before 18:00 so there is no surcharge. The total fare is $3.70. Example 2 1 2 3 ooiwt@pe111:~/as01-ooiwt$ ./taxi 1 17 57 2000 4.3600 Start: Mon 17:57 Distance: 2,000 m The metered fare for the first 1,000 m (1km) is $3.70. The next 1,000 m is charged $0.22 for every 400 m (or less) traveled. The passenger is charged an additional 3 x $0.22, giving the total metered fare of $4.36. The boarding time is before 18:00 so there is no surcharge. Example 3 1 2 3 ooiwt@pe111:~/as01-ooiwt$ ./taxi 1 5 50 15000 18.0900 Start: Mon 05:50 Distance: 15,000 m The metered fare for the first 1,000 m (1km) is $3.70. The next 9,000 m is charged $0.22 for every 400 m traveled. The passenger is charged an additional 23 x $0.22 = $5.06. The remaining 5,000 m is charged $0.22 for every 350 m (or less) traveled). The passenger is charged an additional 15 x $0.22 = $3.30. The total metered fare is $12.06. The boarding time is before 6:00 so there is a 50% surcharge. The total fare is $18.09. Instructions Break down this problem into multiple subproblems, each can be solved by a function. Write one function to answer each question below : given the day of the week, is it a weekday? given the time of boarding, does it fall under the morning peak hour (6:00 - 9:29)? given the time of boarding, does it fall under the evening peak hour (18:00 - 23:59)? given the time of boarding, does it fall under the midnight peak hour (0:00 - 5:59)? Further break the calculation of fare down into two parts: the basic metered fare and the surcharge. Each of these can be a function. Think about the four inputs to the taxi program. Which one is needed to compute the metered fare? Which ones are used to compute the surcharge? Pass in the appropriate arguments to the function that computes the metered fare and the function that computes the surcharge.","title":"1. Pyramid, Digits, Suffix, Taxi"},{"location":"as01.html#assignment-1","text":"","title":"Assignment 1"},{"location":"as01.html#deadline","text":"7 September 2021 (Tuesday), 23:59 pm.","title":"Deadline"},{"location":"as01.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 0 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton.","title":"Prerequisite"},{"location":"as01.html#learning-outcomes","text":"Be comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, and conditional if / else statements. Be comfortable breaking down a problem into smaller sub-problems that can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function.","title":"Learning Outcomes"},{"location":"as01.html#setup","text":"First, accept the assignment on GitHub Then, log in to one of the hosts of CS1010 programming environment and run 1 ~cs1010/get-as01 You should see the folder as01-<github username> in your home directory with the assignment skeleton inside. Inside that directory, you should see the following files: pyramid.c , digits.c , suffix.c , and taxi.c are the most important files. They are the skeleton C code that you should edit to solve the assignment and the only files that you should change. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 0 so you should already be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. compiler_flags.txt and .clang-tidy are two files used to configure clang and clang-tidy respectively. You do not need to edit this.","title":"Setup"},{"location":"as01.html#solving-the-assignments","text":"Edit the files pyramid.c , digits.c , suffix.c , and taxi.c to solve the corresponding question as described below. To compile and run the given tests with the sample inputs and outputs, run on the command line, 1 make This command will compile the C files. If there is no compilation error, it will run the test scripts. To compile (and only compile) your code for a specific problem, pass in the name as an argument. Example: 1 make digits To test (and only test) your program for a specific problem, run the test.sh script: 1 ./test.sh digits You can read more about how you can become a power user of make in CS1010 . This list of common clang warnings and error messages might be helpful. Clean Compilation This is a reminder that, for your lab assignments and practical exams, any submission that cannot compile will receive 0. Further, each warning will lead to a -1 mark deduction. So, please make sure that your code does not generate any error or warning. You can ensure this by running make before submission.","title":"Solving The Assignments"},{"location":"as01.html#submission","text":"When you are ready, run the following command to submit: 1 ~cs1010/submit-as01 The four files pyramid.c , digits.c , suffix.c , and taxi.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Manipulating Files on GitHub Do not manipulate (e.g., edit) the files on GitHub or close the pull requests on GitHub. Doing so would interfere with the scripts and the grading/testing process of CS1010.","title":"Submission"},{"location":"as01.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial lab group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Dolores Abernathy (Group E01)","title":"Identifying Yourself"},{"location":"as01.html#grading","text":"This assignment contributes towards 3% of your final grade. The total marks for this assignment are 30 marks. For Programming Assignment 1, the sole criterion for grading is correctness -- this includes the correctness of syntax, practices, approach, and logic, and whether you correctly follow our instructions. Note that even if your solution produces the correct output every time, it may not get full marks if the approach is wrong.","title":"Grading"},{"location":"as01.html#question-1-pyramid-5-marks","text":"A right rectangular pyramid is a 3D shape with a rectangle as a base and four isosceles triangular sides that meet at its apex. We can specify such a pyramid with three parameters, the width \\(w\\) of the base, the length \\(l\\) of the base, and the height \\(h\\) of the apex (perpendicular distance between the apex and the base). Our task is to calculate the surface area of a pyramid, by decomposing this calculation into three smaller functions. To complete this task, in pyramid.c , Write a function hypotenuse_of to compute the hypotenuse of a right-angled triangle, given the length of the legs (the sides adjacent to the right angle). Write a function area_of_rectangle that computes the area of a rectangle given the width and height of the rectangle. Write a function area_of_triangle that computes the area of a triangle using Heron's formula (see Exercise 1), given the length of the three sides. Finally, complete the program pyramid.c so that it reads, from the standard input, three positive integers representing the width, length, and height of the pyramid (in that order) and prints, to the standard output, its surface area. Solve this by using composing the three functions above. You may add additional functions if needed. Pay attention to the types ( long or double ) used in the inputs, calculations, and outputs. Keep the variable as integer type ( long ) as long as possible.","title":"Question 1: Pyramid (5 marks)"},{"location":"as01.html#sample-run","text":"1 2 3 4 5 6 ooiwt@pe111:~/as01-ooiwt$ ./pyramid 6 8 12 222.8492 ooiwt@pe111:~/as01-ooiwt$ ./pyramid 10 20 30 1124.5040","title":"Sample Run"},{"location":"as01.html#question-2-digits-5-marks","text":"Write a program digits.c that reads in a non-negative integer, and prints the sum of the individual digits in this integer. For instance, if the input is 1933091 , then the sum is 1 + 9 + 3 + 3 + 0 + 9 + 1 = 26. You must not use a loop to solve this. Instead write a recursive function sum_of_digits . This function takes in an integer and returns the sum of the individual digit of that integer, and it should call itself to solve this question, for a smaller integer. A solution that uses a loop in any way will receive 0 marks for this question.","title":"Question 2: Digits (5 marks)"},{"location":"as01.html#sample-run_1","text":"1 2 3 4 5 6 ooiwt@pe111:~/as01-ooiwt$ ./digits 1933091 26 ooiwt@pe111:~/as01-ooiwt$ ./digits 10 1","title":"Sample Run"},{"location":"as01.html#question-3-ordinal-suffix-5-marks","text":"In English, an ordinal number is written with numerals, followed by its letter suffixes. For instance: 1st, 2nd, 3rd, 4th, 11th, 31st, etc. The rule is that a number that ends with digit 1 should have a suffix \"st\" (except if it ends with 11), a number that ends with 2 should have a suffix \"nd\" (except if it ends with 12), and a number that ends with 3 should have a suffix \"rd\" (except if it ends with 13). All other numbers should end with \"th\". Write a program suffix that reads in an integer number from the standard input and prints out the number with its ordinal suffix. Your program should include a void function print_with_suffix(long n) that takes in the input and prints out the number followed by its suffix. 1 2 3 4 5 6 7 8 9 10 11 12 ooiwt@pe112:~/as01-ooiwt$ ./suffix 2 2nd ooiwt@pe112:~/as01-ooiwt$ ./suffix 13 13th ooiwt@pe112:~/as01-ooiwt$ ./suffix 412 412th ooiwt@pe112:~/as01-ooiwt$ ./suffix 3 3rd","title":"Question 3: Ordinal Suffix (5 marks)"},{"location":"as01.html#question-4-taxi-fare-15-marks","text":"The taxi fare structure in Singapore must be one of the most complicated in the world! Check out: http://www.taxisingapore.com/taxi-fare/ . For this exercise, we will just use the following simplified fare structure: Basic Fare The first 1 km or less (Flag Down) $3.70 Every 400 m thereafter or less, up to 10 km $0.22 Every 350 m thereafter or less, after 10 km $0.22 Surcharge Monday to Friday 6:00 to 9:29 25% of metered fare Daily 18:00 to 23:59 25% of metered fare Daily 0:00 (midnight) to 5:59 50% of metered fare Note that the surcharge is applicable based on the boarding time. For instance, if the trip started at 17:50 and ended at 18:10, then no surcharge is incurred. Write a program taxi.c that computes the taxi fare. The program, called taxi , takes in four integers as inputs: The first is the day of the week. It can only be the value 1 to 7 , 1 being Monday, 7 being Sunday. The second and the third is the starting time of the trip: the second input indicates the hours since midnight of the stated day, the third input indicates the minutes since the beginning of the stated hours. The fourth and final input is the distance of the trip, in meters. Your program should print a single floating point number, which is the cost of the fare in dollars. Examine the following examples for more details:","title":"Question 4: Taxi Fare (15 marks)"},{"location":"as01.html#example-1","text":"1 2 3 ooiwt@pe111:~/as01-ooiwt$ ./taxi 1 17 59 1000 3.7000 Start: Mon 17:59 Distance: 1,000 m The metered fare is $3.70 since the distance traveled is 1km. The boarding time is before 18:00 so there is no surcharge. The total fare is $3.70.","title":"Example 1"},{"location":"as01.html#example-2","text":"1 2 3 ooiwt@pe111:~/as01-ooiwt$ ./taxi 1 17 57 2000 4.3600 Start: Mon 17:57 Distance: 2,000 m The metered fare for the first 1,000 m (1km) is $3.70. The next 1,000 m is charged $0.22 for every 400 m (or less) traveled. The passenger is charged an additional 3 x $0.22, giving the total metered fare of $4.36. The boarding time is before 18:00 so there is no surcharge.","title":"Example 2"},{"location":"as01.html#example-3","text":"1 2 3 ooiwt@pe111:~/as01-ooiwt$ ./taxi 1 5 50 15000 18.0900 Start: Mon 05:50 Distance: 15,000 m The metered fare for the first 1,000 m (1km) is $3.70. The next 9,000 m is charged $0.22 for every 400 m traveled. The passenger is charged an additional 23 x $0.22 = $5.06. The remaining 5,000 m is charged $0.22 for every 350 m (or less) traveled). The passenger is charged an additional 15 x $0.22 = $3.30. The total metered fare is $12.06. The boarding time is before 6:00 so there is a 50% surcharge. The total fare is $18.09.","title":"Example 3"},{"location":"as01.html#instructions","text":"Break down this problem into multiple subproblems, each can be solved by a function. Write one function to answer each question below : given the day of the week, is it a weekday? given the time of boarding, does it fall under the morning peak hour (6:00 - 9:29)? given the time of boarding, does it fall under the evening peak hour (18:00 - 23:59)? given the time of boarding, does it fall under the midnight peak hour (0:00 - 5:59)? Further break the calculation of fare down into two parts: the basic metered fare and the surcharge. Each of these can be a function. Think about the four inputs to the taxi program. Which one is needed to compute the metered fare? Which ones are used to compute the surcharge? Pass in the appropriate arguments to the function that computes the metered fare and the function that computes the surcharge.","title":"Instructions"},{"location":"as02.html","text":"Assignment 2: Collatz, Rectangle, Prime, Pattern Deadline 14 September 2020 (Tuesday), 23:59 pm. Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 0 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. You are comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, and conditional if / else statements. You are comfortable breaking down a problem into smaller sub-problems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function. Learning Objectives Be comfortable writing C programs that involve loops with while/for/do- while statements. Be able to write C programs that are neat and readable, adhering to a common prescribed coding convention. Setup First, accept the assignment on GitHub Then, log in to one of the hosts of CS1010 programming environment and run 1 ~cs1010/get-as02 You should see the folder as02-<github username> in your home directory with the assignment skeleton inside. Inside that directory, you should see the following files: collatz.c , rectangle.c , prime.c , and pattern.c are the most important files. They are the skeleton C code that you should edit to solve the assignment and the only files that you should change. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 0 so you should already be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. compile_flags.txt : This file specifies the flags for compilation and is used by both make and clang-tidy . NEW Questions.md containing the description of the questions. This is a plain text file that you can view with vim , less , or other tools. Solving The Assignments Edit the files collatz.c , rectangle.c , prime.c , and pattern.c to solve the corresponding question as described below. To compile and run tests with the sample inputs and outputs: 1 make This command will compile all your C files with the appropriate settings and if there is no error, run the test scripts. If you pass the test cases, it will run clang-tidy to check if your code follows good code practices. The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. NEW To compile individial program, type 1 make <program> For instance, the command 1 make echo compiles echo.c into echo without testing or running clang-tidy on it. NEW To test individial program, run 1 ./test.sh <program> For instance, the command 1 ./test.sh echo tests echo without compiling or running clang-tidy on echo.c . Submission When you are ready, run the following command to submit: 1 ~cs1010/submit-as02 The four files collatz.c , rectangle.c , prime.c , and pattern.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Manipulating Files on GitHub Do not manipulate (e.g., edit) the files on GitHub or close the pull requests on GitHub. Doing so would interfere with the scripts and the grading/testing process of CS1010. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Carol Danvers (Group G02) Grading This assignment contributes towards 3% of your final grade. The total marks for this assignment are 30 marks. For Programming Assignment 2, 1 mark is allocated to style. This is an almost free mark -- as long as the code is neat and readable, and adhere to CS1010 coding convention, you will get this 1 mark. 1 mark is allocated to efficiency for prime and pattern . While we do not require advanced fast algorithm to check for primarity, your code should not waste time by doing redundant work. You can use the programs ~cs1010/prime and ~cs1010/pattern as a reference. As a guideline, your code should run in the same order of magnitudes in terms of time, as these two reference programs. In particular, prime should not take more than two minutes to pass all the provided test cases in inputs . The rest of the marks are allocated to correctness -- this includes the correctness of syntax, practices, approach, and logic, and whether you correctly follow our instructions. Note that even if your solution produces the correct output every time, it may not get full marks if the approach is wrong. Questions To acclimatize you to the PE1 condition, the questions for this assignment is included in the skeleton instead, in a file named Questions.md . You should learn how to use vim to open both the .c file and the questions.md side-by-side (see https://nus-cs1010.github.io/2122-s1/vim.html#splitting-vims-viewport )","title":"2. Collatz, Rectangle, Prime, Pattern"},{"location":"as02.html#assignment-2-collatz-rectangle-prime-pattern","text":"","title":"Assignment 2: Collatz, Rectangle, Prime, Pattern"},{"location":"as02.html#deadline","text":"14 September 2020 (Tuesday), 23:59 pm.","title":"Deadline"},{"location":"as02.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 0 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. You are comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, and conditional if / else statements. You are comfortable breaking down a problem into smaller sub-problems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function.","title":"Prerequisite"},{"location":"as02.html#learning-objectives","text":"Be comfortable writing C programs that involve loops with while/for/do- while statements. Be able to write C programs that are neat and readable, adhering to a common prescribed coding convention.","title":"Learning Objectives"},{"location":"as02.html#setup","text":"First, accept the assignment on GitHub Then, log in to one of the hosts of CS1010 programming environment and run 1 ~cs1010/get-as02 You should see the folder as02-<github username> in your home directory with the assignment skeleton inside. Inside that directory, you should see the following files: collatz.c , rectangle.c , prime.c , and pattern.c are the most important files. They are the skeleton C code that you should edit to solve the assignment and the only files that you should change. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 0 so you should already be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. compile_flags.txt : This file specifies the flags for compilation and is used by both make and clang-tidy . NEW Questions.md containing the description of the questions. This is a plain text file that you can view with vim , less , or other tools.","title":"Setup"},{"location":"as02.html#solving-the-assignments","text":"Edit the files collatz.c , rectangle.c , prime.c , and pattern.c to solve the corresponding question as described below. To compile and run tests with the sample inputs and outputs: 1 make This command will compile all your C files with the appropriate settings and if there is no error, run the test scripts. If you pass the test cases, it will run clang-tidy to check if your code follows good code practices. The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. NEW To compile individial program, type 1 make <program> For instance, the command 1 make echo compiles echo.c into echo without testing or running clang-tidy on it. NEW To test individial program, run 1 ./test.sh <program> For instance, the command 1 ./test.sh echo tests echo without compiling or running clang-tidy on echo.c .","title":"Solving The Assignments"},{"location":"as02.html#submission","text":"When you are ready, run the following command to submit: 1 ~cs1010/submit-as02 The four files collatz.c , rectangle.c , prime.c , and pattern.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Manipulating Files on GitHub Do not manipulate (e.g., edit) the files on GitHub or close the pull requests on GitHub. Doing so would interfere with the scripts and the grading/testing process of CS1010.","title":"Submission"},{"location":"as02.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Carol Danvers (Group G02)","title":"Identifying Yourself"},{"location":"as02.html#grading","text":"This assignment contributes towards 3% of your final grade. The total marks for this assignment are 30 marks. For Programming Assignment 2, 1 mark is allocated to style. This is an almost free mark -- as long as the code is neat and readable, and adhere to CS1010 coding convention, you will get this 1 mark. 1 mark is allocated to efficiency for prime and pattern . While we do not require advanced fast algorithm to check for primarity, your code should not waste time by doing redundant work. You can use the programs ~cs1010/prime and ~cs1010/pattern as a reference. As a guideline, your code should run in the same order of magnitudes in terms of time, as these two reference programs. In particular, prime should not take more than two minutes to pass all the provided test cases in inputs . The rest of the marks are allocated to correctness -- this includes the correctness of syntax, practices, approach, and logic, and whether you correctly follow our instructions. Note that even if your solution produces the correct output every time, it may not get full marks if the approach is wrong.","title":"Grading"},{"location":"as02.html#questions","text":"To acclimatize you to the PE1 condition, the questions for this assignment is included in the skeleton instead, in a file named Questions.md . You should learn how to use vim to open both the .c file and the questions.md side-by-side (see https://nus-cs1010.github.io/2122-s1/vim.html#splitting-vims-viewport )","title":"Questions"},{"location":"as03.html","text":"Assignment 3: Days, ID, Max, Padovan Deadline 28 September 2020 (Tuesday), 23:59 pm. Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 0 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. You are comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, conditional if / else statements, and loops. You are comfortable breaking down a problem into smaller sub-problems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function. Learning Objectives Be comfortable writing C programs that use fixed-size arrays. Be able to write C programs that are neat and readable, adhering to a common prescribed coding convention. Setup First, accept the assignment on GitHub . Then, log in to one of the hosts of CS1010 programming environment and run 1 ~cs1010/get-as03 You should see the folder as03-<github username> in your home directory with the assignment skeleton inside. Inside that directory, you should see the following files: days.c , id.c , max.c , and padovan.c are the most important files. They are the skeleton C code that you should edit to solve the assignment and the only files that you should change. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 0 so you should already be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. compile_flags.txt : This file specifies the flags for compilation and is used by both make and clang-tidy . NEW Questions.md containing the description of the questions. This is a plain text file that you can view with vim , less , or other tools. Solving The Assignments Edit the files days.c , id.c , max.c , and padovan.c to solve the corresponding question as described below. To compile and run tests with the sample inputs and outputs: 1 make This command will compile all your C files with the appropriate settings and if there is no error, run the test scripts. If you pass the test cases, it will run clang-tidy to check if your code follows good code practices. The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. To compile individial program, type 1 make <program> For instance, the command 1 make echo compiles echo.c into echo without testing or running clang-tidy on it. To test individial program, run 1 ./test.sh <program> For instance, the command 1 ./test.sh echo tests echo without compiling or running clang-tidy on echo.c . Submission When you are ready, run the following command to submit: 1 ~cs1010/submit-as03 The four files days.c , id.c , max.c , and padovan.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Manipulating Files on GitHub Do not manipulate (e.g., edit) the files on GitHub or close the pull requests on GitHub. Doing so would interfere with the scripts and the grading/testing process of CS1010. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Jack Frost (Group G02) Grading This assignment contributes towards 3% of your final grade. The total marks for this assignment are 30 marks. For Programming Assignment 3, 1 mark is allocated to style. This is an almost free mark -- as long as the code is neat and readable, and adhere to CS1010 coding convention, you will get this 1 mark. 3 mark is allocated to efficiency for padovan . Avoid repetitively calculating the same sequence of numbers over and over to earn this 3 marks. The rest of the marks are allocated to correctness -- this includes the correctness of syntax, practices, approach, and logic, and whether you correctly follow our instructions. Note that even if your solution produces the correct output every time, it may not get full marks if the approach is wrong. Questions To acclimatize you to the PE1 condition, the questions for this assignment is included in the skeleton instead, in a file named Questions.md . You should learn how to use vim to open both the .c file and the Questions.md side-by-side (see https://nus-cs1010.github.io/2122-s1/vim.html#splitting-vims-viewport )","title":"3. Days, ID, Max, Padovan"},{"location":"as03.html#assignment-3-days-id-max-padovan","text":"","title":"Assignment 3: Days, ID, Max, Padovan"},{"location":"as03.html#deadline","text":"28 September 2020 (Tuesday), 23:59 pm.","title":"Deadline"},{"location":"as03.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 0 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. You are comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, conditional if / else statements, and loops. You are comfortable breaking down a problem into smaller sub-problems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function.","title":"Prerequisite"},{"location":"as03.html#learning-objectives","text":"Be comfortable writing C programs that use fixed-size arrays. Be able to write C programs that are neat and readable, adhering to a common prescribed coding convention.","title":"Learning Objectives"},{"location":"as03.html#setup","text":"First, accept the assignment on GitHub . Then, log in to one of the hosts of CS1010 programming environment and run 1 ~cs1010/get-as03 You should see the folder as03-<github username> in your home directory with the assignment skeleton inside. Inside that directory, you should see the following files: days.c , id.c , max.c , and padovan.c are the most important files. They are the skeleton C code that you should edit to solve the assignment and the only files that you should change. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 0 so you should already be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. compile_flags.txt : This file specifies the flags for compilation and is used by both make and clang-tidy . NEW Questions.md containing the description of the questions. This is a plain text file that you can view with vim , less , or other tools.","title":"Setup"},{"location":"as03.html#solving-the-assignments","text":"Edit the files days.c , id.c , max.c , and padovan.c to solve the corresponding question as described below. To compile and run tests with the sample inputs and outputs: 1 make This command will compile all your C files with the appropriate settings and if there is no error, run the test scripts. If you pass the test cases, it will run clang-tidy to check if your code follows good code practices. The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. To compile individial program, type 1 make <program> For instance, the command 1 make echo compiles echo.c into echo without testing or running clang-tidy on it. To test individial program, run 1 ./test.sh <program> For instance, the command 1 ./test.sh echo tests echo without compiling or running clang-tidy on echo.c .","title":"Solving The Assignments"},{"location":"as03.html#submission","text":"When you are ready, run the following command to submit: 1 ~cs1010/submit-as03 The four files days.c , id.c , max.c , and padovan.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Manipulating Files on GitHub Do not manipulate (e.g., edit) the files on GitHub or close the pull requests on GitHub. Doing so would interfere with the scripts and the grading/testing process of CS1010.","title":"Submission"},{"location":"as03.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Jack Frost (Group G02)","title":"Identifying Yourself"},{"location":"as03.html#grading","text":"This assignment contributes towards 3% of your final grade. The total marks for this assignment are 30 marks. For Programming Assignment 3, 1 mark is allocated to style. This is an almost free mark -- as long as the code is neat and readable, and adhere to CS1010 coding convention, you will get this 1 mark. 3 mark is allocated to efficiency for padovan . Avoid repetitively calculating the same sequence of numbers over and over to earn this 3 marks. The rest of the marks are allocated to correctness -- this includes the correctness of syntax, practices, approach, and logic, and whether you correctly follow our instructions. Note that even if your solution produces the correct output every time, it may not get full marks if the approach is wrong.","title":"Grading"},{"location":"as03.html#questions","text":"To acclimatize you to the PE1 condition, the questions for this assignment is included in the skeleton instead, in a file named Questions.md . You should learn how to use vim to open both the .c file and the Questions.md side-by-side (see https://nus-cs1010.github.io/2122-s1/vim.html#splitting-vims-viewport )","title":"Questions"},{"location":"as04.html","text":"Assignment 4: Selection, Mastermind Deadline 6 October 2021 (Wednesday 23:59 pm) Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 0 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. You are comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, conditional if / else statements, and loops. You are comfortable breaking down a problem into smaller sub-problems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function. Learning Objectives Be comfortable writing C programs that use fixed-size arrays. Be able to write C programs that are neat and readable, adhering to a common prescribed coding convention. Setup First, accept the assignment on GitHub Then, log in to one of the hosts of CS1010 programming environment and run 1 ~cs1010/get-as04 You should see the folder as04-<github username> in your home directory with the assignment skeleton inside. Inside that directory, you should see the following files: selection.c and mastermind.c are the most important files. They are the skeleton C code that you should edit to solve the assignment and the only files that you should change. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 0 so you should already be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. compile_flags.txt : This file specifies the flags for compilation and is used by both make and clang-tidy . Questions.md containing the description of the questions. This is a plain text file that you can view with vim , less , or other tools. Solving The Assignments Edit the files selection.c and mastermind.c to solve the corresponding question as described below. To compile and run tests with the sample inputs and outputs: 1 make This command will compile all your C files with the appropriate settings and if there is no error, run the test scripts. If you pass the test cases, it will run clang-tidy to check if your code follows good code practices. The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. To compile individual program, type 1 make <program> For instance, the command 1 make echo compiles echo.c into echo without testing or running clang-tidy on it. To test individual program, run 1 ./test.sh <program> For instance, the command 1 ./test.sh echo tests echo without compiling or running clang-tidy on echo.c . Submission When you are ready, run the following command to submit: 1 ~cs1010/submit-as04 The four files selection.c and mastermind.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Manipulating Files on GitHub Do not manipulate (e.g., edit) the files on GitHub or close the pull requests on GitHub. Doing so would interfere with the scripts and the grading/testing process of CS1010. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Alex Porter (Group G02) Grading This assignment contributes towards 3% of your final grade. The total marks for this assignment are 30 marks. For Programming Assignment 3, 1 mark is allocated to style. This is an almost free mark -- as long as the code is neat and readable, and adhere to CS1010 coding convention, you will get this 1 mark. The rest of the marks are allocated to correctness -- this includes the correctness of syntax, practices, approach, and logic, and whether you correctly follow our instructions. Note that even if your solution produces the correct output every time, it may not get full marks if the approach is wrong. Questions To acclimatize you to the PE1 condition, the questions for this assignment is included in the skeleton instead, in a file named Questions.md . You should learn how to use vim to open both the .c file and the Questions.md side-by-side (see https://nus-cs1010.github.io/2122-s1/vim.html#splitting-vims-viewport )","title":"4. Selection, Mastermind"},{"location":"as04.html#assignment-4-selection-mastermind","text":"","title":"Assignment 4: Selection, Mastermind"},{"location":"as04.html#deadline","text":"6 October 2021 (Wednesday 23:59 pm)","title":"Deadline"},{"location":"as04.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 0 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. You are comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, conditional if / else statements, and loops. You are comfortable breaking down a problem into smaller sub-problems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function.","title":"Prerequisite"},{"location":"as04.html#learning-objectives","text":"Be comfortable writing C programs that use fixed-size arrays. Be able to write C programs that are neat and readable, adhering to a common prescribed coding convention.","title":"Learning Objectives"},{"location":"as04.html#setup","text":"First, accept the assignment on GitHub Then, log in to one of the hosts of CS1010 programming environment and run 1 ~cs1010/get-as04 You should see the folder as04-<github username> in your home directory with the assignment skeleton inside. Inside that directory, you should see the following files: selection.c and mastermind.c are the most important files. They are the skeleton C code that you should edit to solve the assignment and the only files that you should change. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 0 so you should already be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. compile_flags.txt : This file specifies the flags for compilation and is used by both make and clang-tidy . Questions.md containing the description of the questions. This is a plain text file that you can view with vim , less , or other tools.","title":"Setup"},{"location":"as04.html#solving-the-assignments","text":"Edit the files selection.c and mastermind.c to solve the corresponding question as described below. To compile and run tests with the sample inputs and outputs: 1 make This command will compile all your C files with the appropriate settings and if there is no error, run the test scripts. If you pass the test cases, it will run clang-tidy to check if your code follows good code practices. The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. To compile individual program, type 1 make <program> For instance, the command 1 make echo compiles echo.c into echo without testing or running clang-tidy on it. To test individual program, run 1 ./test.sh <program> For instance, the command 1 ./test.sh echo tests echo without compiling or running clang-tidy on echo.c .","title":"Solving The Assignments"},{"location":"as04.html#submission","text":"When you are ready, run the following command to submit: 1 ~cs1010/submit-as04 The four files selection.c and mastermind.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Manipulating Files on GitHub Do not manipulate (e.g., edit) the files on GitHub or close the pull requests on GitHub. Doing so would interfere with the scripts and the grading/testing process of CS1010.","title":"Submission"},{"location":"as04.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Alex Porter (Group G02)","title":"Identifying Yourself"},{"location":"as04.html#grading","text":"This assignment contributes towards 3% of your final grade. The total marks for this assignment are 30 marks. For Programming Assignment 3, 1 mark is allocated to style. This is an almost free mark -- as long as the code is neat and readable, and adhere to CS1010 coding convention, you will get this 1 mark. The rest of the marks are allocated to correctness -- this includes the correctness of syntax, practices, approach, and logic, and whether you correctly follow our instructions. Note that even if your solution produces the correct output every time, it may not get full marks if the approach is wrong.","title":"Grading"},{"location":"as04.html#questions","text":"To acclimatize you to the PE1 condition, the questions for this assignment is included in the skeleton instead, in a file named Questions.md . You should learn how to use vim to open both the .c file and the Questions.md side-by-side (see https://nus-cs1010.github.io/2122-s1/vim.html#splitting-vims-viewport )","title":"Questions"},{"location":"as05.html","text":"Assignment 5: Kendall, CountingSort, Add Deadline 13 October 2021 (Tuesday 23:59 pm) Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 0 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. You are comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, conditional if / else statements, loops, and fixed sized arrays . You are comfortable breaking down a problem into smaller sub-problems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function. Be able to write C programs that are neat and readable, adhering to a common prescribed coding convention. Learning Objectives Be comfortable writing C programs that use dynamically-size arrays and deciding when to use a fixed-size vs. a dynamically-sized array. Be able to write C comments that follows the Doxygen documentation format. Setup First, accept the assignment on GitHub . Then, log in to one of the hosts of CS1010 programming environment and run 1 ~cs1010/get-as05 You should see the folder as05-<github username> in your home directory with the assignment skeleton inside. Inside that directory, you should see the following files: kendall.c , countingsort.c , and add.c are the most important files. They are the skeleton C code that you should edit to solve the assignment and the only files that you should change. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 0 so you should already be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. compile_flags.txt : This file specifies the flags for compilation and is used by both make and clang-tidy . Questions.md containing the description of the questions. This is a plain text file that you can view with vim , less , or other tools. Solving The Assignments Edit the files kendall.c , countingsort.c , and add.c to solve the corresponding question as described below. To compile and run tests with the sample inputs and outputs: 1 make This command will compile all your C files with the appropriate settings and if there is no error, run the test scripts. If you pass the test cases, it will run clang-tidy to check if your code follows good code practices. The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. To compile individual program, type 1 make <program> For instance, the command 1 make echo compiles echo.c into echo without testing or running clang-tidy on it. To test individual program, run 1 ./test.sh <program> For instance, the command 1 ./test.sh echo tests echo without compiling or running clang-tidy on echo.c . Submission When you are ready, run the following command to submit: 1 ~cs1010/submit-as05 The files kendall.c , countingsort.c , and add.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Manipulating Files on GitHub Do not manipulate (e.g., edit) the files on GitHub or close the pull requests on GitHub. Doing so would interfere with the scripts and the grading/testing process of CS1010. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Paul Atreides (Group B01) Grading This assignment contributes towards 3% of your final grade. The total marks for this assignment are 30 marks. For Programming Assignment 5 1 mark is allocated to style. This is an almost free mark -- as long as the code is neat and readable, and adhere to CS1010 coding convention, you will get this 1 mark. 2 mark is allocated to documentation. Your code should following the good practices of breaking down your solution into small functions. Document each function following the Doxygen documentation format, as outlined here . Your code must have at least one non-trivial function (other than main() ) that are properly documented to receive this mark. The rest of the marks are allocated to correctness (and where applicable, efficiency) -- this includes the correctness of syntax, practices, approach, and logic, and whether you correctly follow our instructions. Note that even if your solution produces the correct output every time, it may not get full marks if the approach is wrong. Questions To acclimatize you to the PE1 condition, the questions for this assignment is included in the skeleton instead, in a file named Questions.md . You should learn how to use vim to open both the .c file and the Questions.md side-by-side (see https://nus-cs1010.github.io/2122-s1/vim.html#splitting-vims-viewport )","title":"5. Kendall, CountingSort, Add"},{"location":"as05.html#assignment-5-kendall-countingsort-add","text":"","title":"Assignment 5: Kendall, CountingSort, Add"},{"location":"as05.html#deadline","text":"13 October 2021 (Tuesday 23:59 pm)","title":"Deadline"},{"location":"as05.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 0 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. You are comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, conditional if / else statements, loops, and fixed sized arrays . You are comfortable breaking down a problem into smaller sub-problems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function. Be able to write C programs that are neat and readable, adhering to a common prescribed coding convention.","title":"Prerequisite"},{"location":"as05.html#learning-objectives","text":"Be comfortable writing C programs that use dynamically-size arrays and deciding when to use a fixed-size vs. a dynamically-sized array. Be able to write C comments that follows the Doxygen documentation format.","title":"Learning Objectives"},{"location":"as05.html#setup","text":"First, accept the assignment on GitHub . Then, log in to one of the hosts of CS1010 programming environment and run 1 ~cs1010/get-as05 You should see the folder as05-<github username> in your home directory with the assignment skeleton inside. Inside that directory, you should see the following files: kendall.c , countingsort.c , and add.c are the most important files. They are the skeleton C code that you should edit to solve the assignment and the only files that you should change. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 0 so you should already be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. compile_flags.txt : This file specifies the flags for compilation and is used by both make and clang-tidy . Questions.md containing the description of the questions. This is a plain text file that you can view with vim , less , or other tools.","title":"Setup"},{"location":"as05.html#solving-the-assignments","text":"Edit the files kendall.c , countingsort.c , and add.c to solve the corresponding question as described below. To compile and run tests with the sample inputs and outputs: 1 make This command will compile all your C files with the appropriate settings and if there is no error, run the test scripts. If you pass the test cases, it will run clang-tidy to check if your code follows good code practices. The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. To compile individual program, type 1 make <program> For instance, the command 1 make echo compiles echo.c into echo without testing or running clang-tidy on it. To test individual program, run 1 ./test.sh <program> For instance, the command 1 ./test.sh echo tests echo without compiling or running clang-tidy on echo.c .","title":"Solving The Assignments"},{"location":"as05.html#submission","text":"When you are ready, run the following command to submit: 1 ~cs1010/submit-as05 The files kendall.c , countingsort.c , and add.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Manipulating Files on GitHub Do not manipulate (e.g., edit) the files on GitHub or close the pull requests on GitHub. Doing so would interfere with the scripts and the grading/testing process of CS1010.","title":"Submission"},{"location":"as05.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Paul Atreides (Group B01)","title":"Identifying Yourself"},{"location":"as05.html#grading","text":"This assignment contributes towards 3% of your final grade. The total marks for this assignment are 30 marks. For Programming Assignment 5 1 mark is allocated to style. This is an almost free mark -- as long as the code is neat and readable, and adhere to CS1010 coding convention, you will get this 1 mark. 2 mark is allocated to documentation. Your code should following the good practices of breaking down your solution into small functions. Document each function following the Doxygen documentation format, as outlined here . Your code must have at least one non-trivial function (other than main() ) that are properly documented to receive this mark. The rest of the marks are allocated to correctness (and where applicable, efficiency) -- this includes the correctness of syntax, practices, approach, and logic, and whether you correctly follow our instructions. Note that even if your solution produces the correct output every time, it may not get full marks if the approach is wrong.","title":"Grading"},{"location":"as05.html#questions","text":"To acclimatize you to the PE1 condition, the questions for this assignment is included in the skeleton instead, in a file named Questions.md . You should learn how to use vim to open both the .c file and the Questions.md side-by-side (see https://nus-cs1010.github.io/2122-s1/vim.html#splitting-vims-viewport )","title":"Questions"},{"location":"as06.html","text":"Assignment 5: Contact, Social, Life Deadline 19 October 2021 (Tuesday 23:59 pm) Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 0 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. You are comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, conditional if / else statements, loops, fixed sized arrays, and dynamically size arrays . You are comfortable breaking down a problem into smaller sub-problems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function. Be able to write C programs that are neat and readable, adhering to a common prescribed coding convention. Learning Objectives Be comfortable writing C programs that use 2D arrays. Be able to write C comments that follows the Doxygen documentation format. Setup First, accept the assignment on GitHub Then, log in to one of the hosts of CS1010 programming environment and run 1 ~cs1010/get-as06 You should see the folder as06-<github username> in your home directory with the assignment skeleton inside. Inside that directory, you should see the following files: contact.c , social.c , and life.c are the most important files. They are the skeleton C code that you should edit to solve the assignment and the only files that you should change. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 0 so you should already be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. compile_flags.txt : This file specifies the flags for compilation and is used by both make and clang-tidy . Questions.md containing the description of the questions. This is a plain text file that you can view with vim , less , or other tools. Solving The Assignments Edit the files contact.c , social.c , and life.c to solve the corresponding question as described below. To compile and run tests with the sample inputs and outputs: 1 make This command will compile all your C files with the appropriate settings and if there is no error, run the test scripts. If you pass the test cases, it will run clang-tidy to check if your code follows good code practices. The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. To compile individual program, type 1 make <program> For instance, the command 1 make echo compiles echo.c into echo without testing or running clang-tidy on it. To test individual program, run 1 ./test.sh <program> For instance, the command 1 ./test.sh echo tests echo without compiling or running clang-tidy on echo.c . Testing for life is not automated for this assignment. See Questions.md on how to test life Submission When you are ready, run the following command to submit: 1 ~cs1010/submit-as06 The files contact.c , social.c , and life.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Manipulating Files on GitHub Do not manipulate (e.g., edit) the files on GitHub or close the pull requests on GitHub. Doing so would interfere with the scripts and the grading/testing process of CS1010. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Judith Grimes (Group B01) Grading This assignment contributes towards 4% of your final grade. The total marks for this assignment are 40 marks. For Programming Assignment 6 1 mark is allocated to style. This is an almost free mark -- as long as the code is neat and readable, and adhere to CS1010 coding convention, you will get this 1 mark. 2 mark is allocated to documentation. Your code should following the good practices of breaking down your solution into small functions. Document each function following the Doxygen documentation format, as outlined here . Your code must have at least one non-trivial function (other than main() ) that are properly documented to receive this mark. The rest of the marks are allocated to correctness (and where applicable, efficiency) -- this includes the correctness of syntax, practices, approach, and logic, and whether you correctly follow our instructions. Note that even if your solution produces the correct output every time, it may not get full marks if the approach is wrong. Questions To acclimatize you to the PE condition, the questions for this assignment is included in the skeleton instead, in a file named Questions.md . You should learn how to use vim to open both the .c file and the Questions.md side-by-side (see https://nus-cs1010.github.io/2122-s1/vim.html#splitting-vims-viewport )","title":"6. Contact, Social, Life,"},{"location":"as06.html#assignment-5-contact-social-life","text":"","title":"Assignment 5: Contact, Social, Life"},{"location":"as06.html#deadline","text":"19 October 2021 (Tuesday 23:59 pm)","title":"Deadline"},{"location":"as06.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 0 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. You are comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, conditional if / else statements, loops, fixed sized arrays, and dynamically size arrays . You are comfortable breaking down a problem into smaller sub-problems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function. Be able to write C programs that are neat and readable, adhering to a common prescribed coding convention.","title":"Prerequisite"},{"location":"as06.html#learning-objectives","text":"Be comfortable writing C programs that use 2D arrays. Be able to write C comments that follows the Doxygen documentation format.","title":"Learning Objectives"},{"location":"as06.html#setup","text":"First, accept the assignment on GitHub Then, log in to one of the hosts of CS1010 programming environment and run 1 ~cs1010/get-as06 You should see the folder as06-<github username> in your home directory with the assignment skeleton inside. Inside that directory, you should see the following files: contact.c , social.c , and life.c are the most important files. They are the skeleton C code that you should edit to solve the assignment and the only files that you should change. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 0 so you should already be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. compile_flags.txt : This file specifies the flags for compilation and is used by both make and clang-tidy . Questions.md containing the description of the questions. This is a plain text file that you can view with vim , less , or other tools.","title":"Setup"},{"location":"as06.html#solving-the-assignments","text":"Edit the files contact.c , social.c , and life.c to solve the corresponding question as described below. To compile and run tests with the sample inputs and outputs: 1 make This command will compile all your C files with the appropriate settings and if there is no error, run the test scripts. If you pass the test cases, it will run clang-tidy to check if your code follows good code practices. The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. To compile individual program, type 1 make <program> For instance, the command 1 make echo compiles echo.c into echo without testing or running clang-tidy on it. To test individual program, run 1 ./test.sh <program> For instance, the command 1 ./test.sh echo tests echo without compiling or running clang-tidy on echo.c . Testing for life is not automated for this assignment. See Questions.md on how to test life","title":"Solving The Assignments"},{"location":"as06.html#submission","text":"When you are ready, run the following command to submit: 1 ~cs1010/submit-as06 The files contact.c , social.c , and life.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Manipulating Files on GitHub Do not manipulate (e.g., edit) the files on GitHub or close the pull requests on GitHub. Doing so would interfere with the scripts and the grading/testing process of CS1010.","title":"Submission"},{"location":"as06.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Judith Grimes (Group B01)","title":"Identifying Yourself"},{"location":"as06.html#grading","text":"This assignment contributes towards 4% of your final grade. The total marks for this assignment are 40 marks. For Programming Assignment 6 1 mark is allocated to style. This is an almost free mark -- as long as the code is neat and readable, and adhere to CS1010 coding convention, you will get this 1 mark. 2 mark is allocated to documentation. Your code should following the good practices of breaking down your solution into small functions. Document each function following the Doxygen documentation format, as outlined here . Your code must have at least one non-trivial function (other than main() ) that are properly documented to receive this mark. The rest of the marks are allocated to correctness (and where applicable, efficiency) -- this includes the correctness of syntax, practices, approach, and logic, and whether you correctly follow our instructions. Note that even if your solution produces the correct output every time, it may not get full marks if the approach is wrong.","title":"Grading"},{"location":"as06.html#questions","text":"To acclimatize you to the PE condition, the questions for this assignment is included in the skeleton instead, in a file named Questions.md . You should learn how to use vim to open both the .c file and the Questions.md side-by-side (see https://nus-cs1010.github.io/2122-s1/vim.html#splitting-vims-viewport )","title":"Questions"},{"location":"assignment.html","text":"Guide to Programming Assignments Timeline There will be weekly take-home programming assignments, each consisting of 1 to 4 questions. These programming assignments collectively contribute to 30% of your final grade. The programming assignment is released on the CS1010 website every Thursday, with a deadline given. You must submit all questions for each particular programming assignment before the deadline. General Advice You are advised to (i) spend some time thinking before you begin coding, (ii) practice incremental coding and (iii) test your programs thoroughly. Remember to spend some time thinking about the algorithm for each question. Write out the pseudo-code or draw out the flowchart on your own before you start typing in your program. Incremental coding means do NOT type in the whole long program in a single session and then compile it. Instead, type your program in bits and pieces and compile it incrementally. Try to maintain a compilable program even while you are working on it. Submitting a compilable program that partially works is better than submitting an un-compilable one; this is especially important for your practical exams. You should test your program thoroughly with your own test data before submission. Please note that: You may assume that all input data are correct unless otherwise stated. Hence you do NOT need to do input data validation. This is to allow you to focus on getting the program right, instead of worrying about making your program fool-proof which involves a lot more work. Copying others' programs or relying on others to help you with these assignments will only offer a short-term reprieve. When Practical Exam (PE) time comes, your inadequacy will be exposed and the consequence would be dire. Late Submission All programming assignments must be submitted on time. If you need an extension, please ask for one and provide a justification for approval. Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not.) For late submission, there is a 1% penalty (of the total awarded marks for that particular assignment) for every 5-minute after the deadline, capped at 80%. For example, if an assignment is awarded 40 marks, and it is submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty). If it is submitted 10 hours after the deadline, the student will get 8 marks (as it has hit the cap of 80% penalty). Method of Submission Please follow the instructions provided in each programming assignment to submit the programs to GitHub. Programs submitted through other means, such as emails, will NOT be accepted. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Gamora (Group 10) Please follow the instructions provided in each programming assignment to submit the programs to GitHub. Programs submitted through other means, such as emails, will NOT be accepted. Grading Only the final submission of each assignment will be graded. For each assignment, we will provide you will a limited set of test data. During grading, we may grade your program with additional test data. Each programming assignment will be graded differently. Generally, marks are given for attempt, correctness, design, and style, and documentation. The weight of each one will be adjusted over the semester. A program that cannot compile (i.e., there is a compilation error) will receive 0 marks for correctness. In addition, there is an additional -1 mark for each warning that your program received. Always make sure that your program compiles cleanly without any warning. Feedback will be provided by the tutors on GitHub. Use of Piazza If you have doubts about the problem statements of an assignment, you may raise them on Piazza. But before that, please read through the problem statements carefully first, and check if the same questions have been asked and answered on the forum. Please exercise discretion when posting to Piazza. Before the deadline, you are NOT to post the solution to the assignment, complete or partial, on Piazza (or any publicly accessible online site). Disallowed Syntax Some programming assignments may explicitly disallow the use of certain syntax. Generally, using syntax or statements which are not yet covered either in class or in the assignment statement is strongly discouraged. We also discourage the use of certain syntax for this module, (e.g., ++ ) you should not use them. The assignments are designed such that you should not need to do so (even though doing so may result in your program being shorter or more efficient). If the objective of the assignment is undermined, the penalty for using such forbidden syntax will be heavy. If in doubt, please ask for clarification. You can find the list of banned and discouraged C features in the article \" C in CS1010 .\" Plagiarism You are NOT to copy from others or allow others to copy your programs. We take plagiarism seriously. See our policies page for details. This means that you should also guard your solution carefully, not posting them to publicly accessible places, or change the permissions of the files on the CS1010 PE hosts so that it is accessible by others. In most cases, you can run make This guideline is adapted from Aaron Tan's CS1010 guideline.","title":"Overview"},{"location":"assignment.html#guide-to-programming-assignments","text":"","title":"Guide to Programming Assignments"},{"location":"assignment.html#timeline","text":"There will be weekly take-home programming assignments, each consisting of 1 to 4 questions. These programming assignments collectively contribute to 30% of your final grade. The programming assignment is released on the CS1010 website every Thursday, with a deadline given. You must submit all questions for each particular programming assignment before the deadline.","title":"Timeline"},{"location":"assignment.html#general-advice","text":"You are advised to (i) spend some time thinking before you begin coding, (ii) practice incremental coding and (iii) test your programs thoroughly. Remember to spend some time thinking about the algorithm for each question. Write out the pseudo-code or draw out the flowchart on your own before you start typing in your program. Incremental coding means do NOT type in the whole long program in a single session and then compile it. Instead, type your program in bits and pieces and compile it incrementally. Try to maintain a compilable program even while you are working on it. Submitting a compilable program that partially works is better than submitting an un-compilable one; this is especially important for your practical exams. You should test your program thoroughly with your own test data before submission. Please note that: You may assume that all input data are correct unless otherwise stated. Hence you do NOT need to do input data validation. This is to allow you to focus on getting the program right, instead of worrying about making your program fool-proof which involves a lot more work. Copying others' programs or relying on others to help you with these assignments will only offer a short-term reprieve. When Practical Exam (PE) time comes, your inadequacy will be exposed and the consequence would be dire.","title":"General Advice"},{"location":"assignment.html#late-submission","text":"All programming assignments must be submitted on time. If you need an extension, please ask for one and provide a justification for approval. Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not.) For late submission, there is a 1% penalty (of the total awarded marks for that particular assignment) for every 5-minute after the deadline, capped at 80%. For example, if an assignment is awarded 40 marks, and it is submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty). If it is submitted 10 hours after the deadline, the student will get 8 marks (as it has hit the cap of 80% penalty).","title":"Late Submission"},{"location":"assignment.html#method-of-submission","text":"Please follow the instructions provided in each programming assignment to submit the programs to GitHub. Programs submitted through other means, such as emails, will NOT be accepted.","title":"Method of Submission"},{"location":"assignment.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Gamora (Group 10) Please follow the instructions provided in each programming assignment to submit the programs to GitHub. Programs submitted through other means, such as emails, will NOT be accepted.","title":"Identifying Yourself"},{"location":"assignment.html#grading","text":"Only the final submission of each assignment will be graded. For each assignment, we will provide you will a limited set of test data. During grading, we may grade your program with additional test data. Each programming assignment will be graded differently. Generally, marks are given for attempt, correctness, design, and style, and documentation. The weight of each one will be adjusted over the semester. A program that cannot compile (i.e., there is a compilation error) will receive 0 marks for correctness. In addition, there is an additional -1 mark for each warning that your program received. Always make sure that your program compiles cleanly without any warning. Feedback will be provided by the tutors on GitHub.","title":"Grading"},{"location":"assignment.html#use-of-piazza","text":"If you have doubts about the problem statements of an assignment, you may raise them on Piazza. But before that, please read through the problem statements carefully first, and check if the same questions have been asked and answered on the forum. Please exercise discretion when posting to Piazza. Before the deadline, you are NOT to post the solution to the assignment, complete or partial, on Piazza (or any publicly accessible online site).","title":"Use of Piazza"},{"location":"assignment.html#disallowed-syntax","text":"Some programming assignments may explicitly disallow the use of certain syntax. Generally, using syntax or statements which are not yet covered either in class or in the assignment statement is strongly discouraged. We also discourage the use of certain syntax for this module, (e.g., ++ ) you should not use them. The assignments are designed such that you should not need to do so (even though doing so may result in your program being shorter or more efficient). If the objective of the assignment is undermined, the penalty for using such forbidden syntax will be heavy. If in doubt, please ask for clarification. You can find the list of banned and discouraged C features in the article \" C in CS1010 .\"","title":"Disallowed Syntax"},{"location":"assignment.html#plagiarism","text":"You are NOT to copy from others or allow others to copy your programs. We take plagiarism seriously. See our policies page for details. This means that you should also guard your solution carefully, not posting them to publicly accessible places, or change the permissions of the files on the CS1010 PE hosts so that it is accessible by others. In most cases, you can run make This guideline is adapted from Aaron Tan's CS1010 guideline.","title":"Plagiarism"},{"location":"c-in-cs1010.html","text":"C in CS1010 C is a simple and flexible language, providing programmers with many different ways to achieve the same thing. Some of these features that C provides, however, could be bug-prone. Wei Tsang has written enough buggy programs himself and seen enough buggy programs from students. He feels that some of these features from C are not useful for beginners (or even seasoned programmers). Furthermore, some features in C simply encourages bad programming habits that are widely frowned upon. Some would lead to insecure programs. As such, in CS1010, we ban and discourage the use of certain operators, functions, constructs, and features in C. This article summarizes this list. This is a work in progress article. As we learn more about C, we will amend this list. Banned in CS1010 The banned items should not be used in CS1010. Students should use alternatives. The teaching staff reserves the right to apply a penalty while grading the assignments and practical exams if these banned features are used. 1. The ++ and -- operators. Why? These operators lead to potential undefined behavior. E.g., i = i++; The potential confusion is caused by the difference between i++ and ++i . What should be used instead? Use i += 1 or i -= 1 instead of i++ or i-- 2. Skipping of curly braces for single statement conditional or loop body Why? Could lead to dangling else confusion Easy to forget to put back the {} pair if the body is modified beyond a single statements What should be used instead? Always use {} even if the conditional or loop body contains only a single statement. 3. Nested conditional operator ?: Why? Can get difficult to read, understand, and modify. Example: 1 a = (x > y) ? ((y > z) ? y : z) : ((x > z) ? x : z); What should be used Use nested if-else loop 4. Global variables Why? It makes the code hard to reason about and trace, as you have no idea who will modify these variables. For instance, if x is not a global variable, we can safely assert that x is still 1 after calling f() . If x is a global variable, we can no longer assert anything about x . 1 2 3 x = 1 ; f (); // { x == 1 } What should be used instead Declare the variables as local, automatic variables, and pass them around. 5. The type int and short Why? C standard guarantees that both short and int are at least 16 bits, which limits its guaranteed range to only -32,768 to 32,767. This is too small for many purposes. We are not concerned about memory usage in CS1010. If we do want to have precise control over memory, we should be anyway using the types from stdint.h . What should be used instead long , which is guaranteed to be at least 32 bits. Exception If a function from C library calls for the use of int and offers no long alternative, then we have to use int . 6. The type float Why? Not enough precision and will cause floating-point errors. What should be used instead double Exception If a function from C library calls for the use of float and offers no double alternative, then we have to use float . 7. Using integer values for true / false Why? Confusing and error-prone What should be used instead Use the bool type, and the values true and false . 8. goto Why? makes the logical flow of the code hard to follow and trace What should be used instead combinations of conditionals and loops Discouraged in CS1010 These are things that are not strictly banned, but their usage is discouraged. Students should use them only if they know very well what they are doing. Use at own perils. 1. printf and scanf Functions Why? Using the wrong format modifier for printf could lead to strange results Using the wrong format modifier for scanf could lead to memory corruption Need to look up what is the right format modifier to use Need to preallocate memory for scanf of strings scanf is not secure scanf is not a pure function. Prefers students to learn about the concept of pure functions first. etc. etc. What should be used instead The CS1010 I/O library 2. switch Statements Why? Bug prone (missing break would cause the case to fall through) Only works on ordinal types. What should be used instead if - else statements 3. break and continue Statements Why? Using break and continue complicates the flow of a loop, marks it harder to reason about the correctness of the loop, and is, therefore, bug-prone. What should be used instead Simple loops with a single entry and a single exit point. Use flag variables to indicate special conditions to exit or continue with the loop. 4. Skipping parenthesis Why? Parenthesis makes it clear to the reader the order of evaluation of arithmetic operations / logical operations. We should add parenthesis to make sure the intention of the code is clear. Why should be used instead Parenthesis","title":"C in CS1010"},{"location":"c-in-cs1010.html#c-in-cs1010","text":"C is a simple and flexible language, providing programmers with many different ways to achieve the same thing. Some of these features that C provides, however, could be bug-prone. Wei Tsang has written enough buggy programs himself and seen enough buggy programs from students. He feels that some of these features from C are not useful for beginners (or even seasoned programmers). Furthermore, some features in C simply encourages bad programming habits that are widely frowned upon. Some would lead to insecure programs. As such, in CS1010, we ban and discourage the use of certain operators, functions, constructs, and features in C. This article summarizes this list. This is a work in progress article. As we learn more about C, we will amend this list.","title":"C in CS1010"},{"location":"c-in-cs1010.html#banned-in-cs1010","text":"The banned items should not be used in CS1010. Students should use alternatives. The teaching staff reserves the right to apply a penalty while grading the assignments and practical exams if these banned features are used.","title":"Banned in CS1010"},{"location":"c-in-cs1010.html#1-the-and-operators","text":"","title":"1. The ++ and -- operators."},{"location":"c-in-cs1010.html#why","text":"These operators lead to potential undefined behavior. E.g., i = i++; The potential confusion is caused by the difference between i++ and ++i .","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead","text":"Use i += 1 or i -= 1 instead of i++ or i--","title":"What should be used instead?"},{"location":"c-in-cs1010.html#2-skipping-of-curly-braces-for-single-statement-conditional-or-loop-body","text":"","title":"2. Skipping of curly braces for single statement conditional or loop body"},{"location":"c-in-cs1010.html#why_1","text":"Could lead to dangling else confusion Easy to forget to put back the {} pair if the body is modified beyond a single statements","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_1","text":"Always use {} even if the conditional or loop body contains only a single statement.","title":"What should be used instead?"},{"location":"c-in-cs1010.html#3-nested-conditional-operator","text":"","title":"3. Nested conditional operator ?:"},{"location":"c-in-cs1010.html#why_2","text":"Can get difficult to read, understand, and modify. Example: 1 a = (x > y) ? ((y > z) ? y : z) : ((x > z) ? x : z);","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used","text":"Use nested if-else loop","title":"What should be used"},{"location":"c-in-cs1010.html#4-global-variables","text":"","title":"4. Global variables"},{"location":"c-in-cs1010.html#why_3","text":"It makes the code hard to reason about and trace, as you have no idea who will modify these variables. For instance, if x is not a global variable, we can safely assert that x is still 1 after calling f() . If x is a global variable, we can no longer assert anything about x . 1 2 3 x = 1 ; f (); // { x == 1 }","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_2","text":"Declare the variables as local, automatic variables, and pass them around.","title":"What should be used instead"},{"location":"c-in-cs1010.html#5-the-type-int-and-short","text":"","title":"5. The type int and short"},{"location":"c-in-cs1010.html#why_4","text":"C standard guarantees that both short and int are at least 16 bits, which limits its guaranteed range to only -32,768 to 32,767. This is too small for many purposes. We are not concerned about memory usage in CS1010. If we do want to have precise control over memory, we should be anyway using the types from stdint.h .","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_3","text":"long , which is guaranteed to be at least 32 bits.","title":"What should be used instead"},{"location":"c-in-cs1010.html#exception","text":"If a function from C library calls for the use of int and offers no long alternative, then we have to use int .","title":"Exception"},{"location":"c-in-cs1010.html#6-the-type-float","text":"","title":"6. The type float"},{"location":"c-in-cs1010.html#why_5","text":"Not enough precision and will cause floating-point errors.","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_4","text":"double","title":"What should be used instead"},{"location":"c-in-cs1010.html#exception_1","text":"If a function from C library calls for the use of float and offers no double alternative, then we have to use float .","title":"Exception"},{"location":"c-in-cs1010.html#7-using-integer-values-for-true-false","text":"","title":"7. Using integer values for true / false"},{"location":"c-in-cs1010.html#why_6","text":"Confusing and error-prone","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_5","text":"Use the bool type, and the values true and false .","title":"What should be used instead"},{"location":"c-in-cs1010.html#8-goto","text":"","title":"8. goto"},{"location":"c-in-cs1010.html#why_7","text":"makes the logical flow of the code hard to follow and trace","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_6","text":"combinations of conditionals and loops","title":"What should be used instead"},{"location":"c-in-cs1010.html#discouraged-in-cs1010","text":"These are things that are not strictly banned, but their usage is discouraged. Students should use them only if they know very well what they are doing. Use at own perils.","title":"Discouraged in CS1010"},{"location":"c-in-cs1010.html#1-printf-and-scanf-functions","text":"","title":"1. printf and scanf Functions"},{"location":"c-in-cs1010.html#why_8","text":"Using the wrong format modifier for printf could lead to strange results Using the wrong format modifier for scanf could lead to memory corruption Need to look up what is the right format modifier to use Need to preallocate memory for scanf of strings scanf is not secure scanf is not a pure function. Prefers students to learn about the concept of pure functions first. etc. etc.","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_7","text":"The CS1010 I/O library","title":"What should be used instead"},{"location":"c-in-cs1010.html#2-switch-statements","text":"","title":"2. switch Statements"},{"location":"c-in-cs1010.html#why_9","text":"Bug prone (missing break would cause the case to fall through) Only works on ordinal types.","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_8","text":"if - else statements","title":"What should be used instead"},{"location":"c-in-cs1010.html#3-break-and-continue-statements","text":"","title":"3. break and continue Statements"},{"location":"c-in-cs1010.html#why_10","text":"Using break and continue complicates the flow of a loop, marks it harder to reason about the correctness of the loop, and is, therefore, bug-prone.","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_9","text":"Simple loops with a single entry and a single exit point. Use flag variables to indicate special conditions to exit or continue with the loop.","title":"What should be used instead"},{"location":"c-in-cs1010.html#4-skipping-parenthesis","text":"","title":"4. Skipping parenthesis"},{"location":"c-in-cs1010.html#why_11","text":"Parenthesis makes it clear to the reader the order of evaluation of arithmetic operations / logical operations. We should add parenthesis to make sure the intention of the code is clear.","title":"Why?"},{"location":"c-in-cs1010.html#why-should-be-used-instead","text":"Parenthesis","title":"Why should be used instead"},{"location":"clang.html","text":"CS1010 Compilation Guide 1. Compile a standalone C program Suppose we have a standalone C program teh.c that does not use any external libraries. We can compile the program using the command 1 ooiwt@pe118:~$ clang teh.c This command should create an executable called a.out in the current directory, which you can then run with: 1 ooiwt@pe118:~$ ./a.out If you are looking for a test teh.c to try this out, there is one at ~cs1010/teh.c , which you can copy over. 2. Renaming executable file The name a.out is an abbreviation for assembler output , a name that many compilers kept as the default output name since the 60s. We should, however, give our executable more descriptive name, by using the -o flag. ( o is the mnemonic for output). 1 ooiwt@pe118:~$ clang teh.c -o teh or 1 ooiwt@pe118:~$ clang -o teh teh.c The command above would create an executable called teh . Beware of the order If you are not careful and run the following command instead: 1 ooiwt@pe118:~$ clang -o teh.c teh clang would overwrite your code teh.c -- all your hard work will be gone!! 3. Warning for possible bugs. The clang checks for syntax errors in your C files -- i.e., things that violate the C syntax rules. The compiler, however, is smart enough to identify possible bugs -- errors that will cause your program to behave incorrectly, even if the syntax follows C's rules. You can ask clang to warn you about this, using the -W flag ( W is the mnemonic for warning -- note the capital W). The manual for clang lists different types of warnings that clang can warn you about. For instance, we can ask clang to warn us by enabling -Wall warnings. The command to do so is: 1 ooiwt@pe118:~$ clang -Wall teh.c -o teh For beginners, it is highly recommended that you always compile with at least -Wall , -Wextra , and the -Wpedantic flag. clang warning flags -Wall in clang does not catually enable all warnings. -Weverything enables every warning but it could be overwhelming for beginners. In CS1010 assignments, we will provide a Makefile so that you can use make to automate the compilation process. Appropriate warning flags will be enabled for you. 4. Generating additional information for debugging. In order to use the debugger lldb to trace through and debug your program, clang needs to generate additional information and store them in the executable file. We can instruct clang to generate them with the flag -g ( g for generate). 1 ooiwt@pe118:~$ clang -Wall -g teh.c -o teh It is recommended that you always compile with -g flags during the development phase. If you need to measure the performance (e.g., how fast it runs) of your program or when you are releasing the program to the public, you can remove the -g flag and compile with the optimization flags (e.g., -O ) instead. 5. Linking with the standard library. To link with a standard library, we use the -l flag to specify the name of the library to link. For instance, to link with the C standard math library (abbreviated as m ), you issue the command: 1 ooiwt@pe118:~$ clang -Wall -g teh.c -o teh -lm 6. Linking with 3rd party library By default, clang looks for headers and libraries in the systems directories ( /usr/include , /usr/lib , etc) and the current working directory. If you use a third-party library, you usually need to tell clang where to look for the corresponding headers and libraries. You can use the -I flag and the -L flag for these purposes. For instance, if you have a library installed under your home called citadel , and the file citadel.h can be found under ~/citadel/include and the file libcitadel.a can be found under ~/citadel/lib , to tell clang where to find these files, you can compile with: 1 ooiwt@pe118:~$ clang -Wall -g -I ~/citadel/include -L ~/citadel/lib teh.c -o teh -lm -lcitadel For instance, to link with the CS1010 I/O library on the PE nodes, you can run 1 ooiwt@pe118:~$ clang -Wall -g -I ~cs1010/include -L ~cs1010/lib teh.c -lcs1010","title":"CLang"},{"location":"clang.html#cs1010-compilation-guide","text":"","title":"CS1010 Compilation Guide"},{"location":"clang.html#1-compile-a-standalone-c-program","text":"Suppose we have a standalone C program teh.c that does not use any external libraries. We can compile the program using the command 1 ooiwt@pe118:~$ clang teh.c This command should create an executable called a.out in the current directory, which you can then run with: 1 ooiwt@pe118:~$ ./a.out If you are looking for a test teh.c to try this out, there is one at ~cs1010/teh.c , which you can copy over.","title":"1. Compile a standalone C program"},{"location":"clang.html#2-renaming-executable-file","text":"The name a.out is an abbreviation for assembler output , a name that many compilers kept as the default output name since the 60s. We should, however, give our executable more descriptive name, by using the -o flag. ( o is the mnemonic for output). 1 ooiwt@pe118:~$ clang teh.c -o teh or 1 ooiwt@pe118:~$ clang -o teh teh.c The command above would create an executable called teh . Beware of the order If you are not careful and run the following command instead: 1 ooiwt@pe118:~$ clang -o teh.c teh clang would overwrite your code teh.c -- all your hard work will be gone!!","title":"2. Renaming executable file"},{"location":"clang.html#3-warning-for-possible-bugs","text":"The clang checks for syntax errors in your C files -- i.e., things that violate the C syntax rules. The compiler, however, is smart enough to identify possible bugs -- errors that will cause your program to behave incorrectly, even if the syntax follows C's rules. You can ask clang to warn you about this, using the -W flag ( W is the mnemonic for warning -- note the capital W). The manual for clang lists different types of warnings that clang can warn you about. For instance, we can ask clang to warn us by enabling -Wall warnings. The command to do so is: 1 ooiwt@pe118:~$ clang -Wall teh.c -o teh For beginners, it is highly recommended that you always compile with at least -Wall , -Wextra , and the -Wpedantic flag. clang warning flags -Wall in clang does not catually enable all warnings. -Weverything enables every warning but it could be overwhelming for beginners. In CS1010 assignments, we will provide a Makefile so that you can use make to automate the compilation process. Appropriate warning flags will be enabled for you.","title":"3. Warning for possible bugs."},{"location":"clang.html#4-generating-additional-information-for-debugging","text":"In order to use the debugger lldb to trace through and debug your program, clang needs to generate additional information and store them in the executable file. We can instruct clang to generate them with the flag -g ( g for generate). 1 ooiwt@pe118:~$ clang -Wall -g teh.c -o teh It is recommended that you always compile with -g flags during the development phase. If you need to measure the performance (e.g., how fast it runs) of your program or when you are releasing the program to the public, you can remove the -g flag and compile with the optimization flags (e.g., -O ) instead.","title":"4. Generating additional information for debugging."},{"location":"clang.html#5-linking-with-the-standard-library","text":"To link with a standard library, we use the -l flag to specify the name of the library to link. For instance, to link with the C standard math library (abbreviated as m ), you issue the command: 1 ooiwt@pe118:~$ clang -Wall -g teh.c -o teh -lm","title":"5. Linking with the standard library."},{"location":"clang.html#6-linking-with-3rd-party-library","text":"By default, clang looks for headers and libraries in the systems directories ( /usr/include , /usr/lib , etc) and the current working directory. If you use a third-party library, you usually need to tell clang where to look for the corresponding headers and libraries. You can use the -I flag and the -L flag for these purposes. For instance, if you have a library installed under your home called citadel , and the file citadel.h can be found under ~/citadel/include and the file libcitadel.a can be found under ~/citadel/lib , to tell clang where to find these files, you can compile with: 1 ooiwt@pe118:~$ clang -Wall -g -I ~/citadel/include -L ~/citadel/lib teh.c -o teh -lm -lcitadel For instance, to link with the CS1010 I/O library on the PE nodes, you can run 1 ooiwt@pe118:~$ clang -Wall -g -I ~cs1010/include -L ~cs1010/lib teh.c -lcs1010","title":"6. Linking with 3rd party library"},{"location":"documentation.html","text":"Code Documentation Code documentation is as important as the code itself. It helps readers of your code, including your future self, to understand the purpose of a piece of code what assumptions are being made, and the reasoning behind why certain things are done. C Syntax for Comments In C, you can write comments in two ways: Either prefix a one-line comment with two slashes // , or Write multiple-line comments between /* and */ For example: 1 // assume the number of elements > 1 1 2 3 4 5 /* This function reads in the radius of a sphere and returns the volume of the sphere. We assume the radius is normalized between 0.0 and 1.0. */ The Doxygen Format In CS1010, we will adopt the Doxygen format for C comments. Doxygen is a tool that automatically generates HTML documents from comments in C code and is widely used in the industry. We write a Doxygen comment with an additional * after /* : 1 2 3 /** */ The comments can be free-form text. However, to help with creating a more structured document, we can add what Doxygen calls special \"commands\". I view these commands as keys to certain information. Useful commands are: @author : The name the author This is used to identify the author and placed at the top of the .c. file This is what you have been using since Exercise 0. @file : The name of a file This is used to identify the name of the file and be placed at the top of the .c. file. This is usually written for you already. @pre : The precondition of a function If your function makes certain assumptions about the inputs, explain it using this command. This is used to document assertions at the beginning of your function (e.g., a string is not empty, a pointer is not NULL, etc) @post : The postcondition of a function This command is used to document assertions that are true just before you return from your function. @param[<direction>] <name> : Describe a parameter of a function. <name> is the name of the parameter (can be a variable, array, pointers, struct, etc). <direction> indicates if you are passing data in or out of the function. From Unit 1 to 16, we only pass data into the function. For such parameters, we document it with @param[in] . In Unit 17, we will learn about passing by reference. If a parameter is passed by reference to be modified inside the function, we will document it as @param[out] . For a parameter that is meant to serve both purposes (pass a value into the function, be modified, and passed the new modified value out), we use @param[in,out] . @return : Describe the return value of a function The comments should be placed before a file, a function, or a variable that you want the comment to apply to. Example 1: CS1010 I/O Library 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * @file: cs1010.c * @author: Ooi Wei Tsang * * This file contains the implementation of the CS1010 I/O library to * simplify the reading and writing of integer, real numbers, and text * from the standard input and output respectively. */ /** * Read k white-space-separated words from the standard input in an array. * The notion of \"word\" is the same to cs1010_read_word(). The caller is * responsible for freeing the memory allocated for the array by calling * free(). * * @param[in] k The number of words to read. * @return Returns NULL if there is a memory allocation error, otherwise, * return an array of char* containing the words. */ char ** cs1010_read_word_array ( size_t k ) { : } Example 2: Collatz 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Find the number between 1 and n with the maximum number of * steps to reach 1, breaking ties by finding the larger among * these numbers. * * @param[in,out] max_num_steps The maximum number ot steps * @param[out] max_n The number with the maximum number of steps * * @pre max_num_steps <= 0 */ void solve ( long n , long * max_n , long * max_num_steps ) { for ( long i = 1 ; i <= n ; i += 1 ) { long num_of_steps = count_num_of_steps ( i ); if ( num_of_steps >= * max_num_steps ) { * max_n = i ; * max_num_steps = num_of_steps ; } } } Note: a better design of the function above is not to rely on the caller to set max_num_steps to 0, but set it at the beginning of the function ourselves. Example 3: Taxi 1 2 3 4 5 6 7 8 9 10 11 12 13 /** * Checks if a given day is a weekday or not. * * @param[in] day This indicates which day it is. 1 is Monday; * 7 is Sunday. * @return Returns true if day is a weekday, false otherwise. * * @pre 1 <= day <= 7 */ bool is_weekday ( long day ) { return ( day >= 1 && day <= 5 ); }","title":"C Documentation"},{"location":"documentation.html#code-documentation","text":"Code documentation is as important as the code itself. It helps readers of your code, including your future self, to understand the purpose of a piece of code what assumptions are being made, and the reasoning behind why certain things are done.","title":"Code Documentation"},{"location":"documentation.html#c-syntax-for-comments","text":"In C, you can write comments in two ways: Either prefix a one-line comment with two slashes // , or Write multiple-line comments between /* and */ For example: 1 // assume the number of elements > 1 1 2 3 4 5 /* This function reads in the radius of a sphere and returns the volume of the sphere. We assume the radius is normalized between 0.0 and 1.0. */","title":"C Syntax for Comments"},{"location":"documentation.html#the-doxygen-format","text":"In CS1010, we will adopt the Doxygen format for C comments. Doxygen is a tool that automatically generates HTML documents from comments in C code and is widely used in the industry. We write a Doxygen comment with an additional * after /* : 1 2 3 /** */ The comments can be free-form text. However, to help with creating a more structured document, we can add what Doxygen calls special \"commands\". I view these commands as keys to certain information. Useful commands are:","title":"The Doxygen Format"},{"location":"documentation.html#author-the-name-the-author","text":"This is used to identify the author and placed at the top of the .c. file This is what you have been using since Exercise 0.","title":"@author: The name the author"},{"location":"documentation.html#file-the-name-of-a-file","text":"This is used to identify the name of the file and be placed at the top of the .c. file. This is usually written for you already.","title":"@file: The name of a file"},{"location":"documentation.html#pre-the-precondition-of-a-function","text":"If your function makes certain assumptions about the inputs, explain it using this command. This is used to document assertions at the beginning of your function (e.g., a string is not empty, a pointer is not NULL, etc)","title":"@pre: The precondition of a function"},{"location":"documentation.html#post-the-postcondition-of-a-function","text":"This command is used to document assertions that are true just before you return from your function.","title":"@post: The postcondition of a function"},{"location":"documentation.html#paramdirection-name-describe-a-parameter-of-a-function","text":"<name> is the name of the parameter (can be a variable, array, pointers, struct, etc). <direction> indicates if you are passing data in or out of the function. From Unit 1 to 16, we only pass data into the function. For such parameters, we document it with @param[in] . In Unit 17, we will learn about passing by reference. If a parameter is passed by reference to be modified inside the function, we will document it as @param[out] . For a parameter that is meant to serve both purposes (pass a value into the function, be modified, and passed the new modified value out), we use @param[in,out] .","title":"@param[&lt;direction&gt;] &lt;name&gt;: Describe a parameter of a function."},{"location":"documentation.html#return-describe-the-return-value-of-a-function","text":"The comments should be placed before a file, a function, or a variable that you want the comment to apply to.","title":"@return: Describe the return value of a function"},{"location":"documentation.html#example-1-cs1010-io-library","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /** * @file: cs1010.c * @author: Ooi Wei Tsang * * This file contains the implementation of the CS1010 I/O library to * simplify the reading and writing of integer, real numbers, and text * from the standard input and output respectively. */ /** * Read k white-space-separated words from the standard input in an array. * The notion of \"word\" is the same to cs1010_read_word(). The caller is * responsible for freeing the memory allocated for the array by calling * free(). * * @param[in] k The number of words to read. * @return Returns NULL if there is a memory allocation error, otherwise, * return an array of char* containing the words. */ char ** cs1010_read_word_array ( size_t k ) { : }","title":"Example 1: CS1010 I/O Library"},{"location":"documentation.html#example-2-collatz","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /** * Find the number between 1 and n with the maximum number of * steps to reach 1, breaking ties by finding the larger among * these numbers. * * @param[in,out] max_num_steps The maximum number ot steps * @param[out] max_n The number with the maximum number of steps * * @pre max_num_steps <= 0 */ void solve ( long n , long * max_n , long * max_num_steps ) { for ( long i = 1 ; i <= n ; i += 1 ) { long num_of_steps = count_num_of_steps ( i ); if ( num_of_steps >= * max_num_steps ) { * max_n = i ; * max_num_steps = num_of_steps ; } } } Note: a better design of the function above is not to rely on the caller to set max_num_steps to 0, but set it at the beginning of the function ourselves.","title":"Example 2: Collatz"},{"location":"documentation.html#example-3-taxi","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 /** * Checks if a given day is a weekday or not. * * @param[in] day This indicates which day it is. 1 is Monday; * 7 is Sunday. * @return Returns true if day is a weekday, false otherwise. * * @pre 1 <= day <= 7 */ bool is_weekday ( long day ) { return ( day >= 1 && day <= 5 ); }","title":"Example 3: Taxi"},{"location":"environments.html","text":"The CS1010 Programming Environment C is a common programming language and you can find different implementations of C compiler on many platforms. Wikipedia lists more than 40 different C compilers . These different compilers support different processor architecture, operating systems, may behave slightly differently, and may support different features of C standards. It is therefore important for CS1010 to stick to a single platform and single compiler. Our platform of choice is Ubuntu 18.04 (or later) using the clang compiler ( version 6.0 or later ). The school has provided a list of computing servers for you to use. You can access them remotely via ssh , or secure shell. The hosts are named pe111 , pe112 , ... , pe120 . ( pe stands for \"programming environment\"). We will refer to these servers generally as the PE hosts. pe115 and pe116 For this semester, the two servers pe115 and pe116 are not available. You can choose which of the 8 hosts to use. You share the same home directory across all the hosts (this home directory, however, is different from that of stu ). For simplicity, the following guide uses pe111 in all examples. Do keep in mind that you can use other hosts for CS1010 to spread out the load. While it is possible for you to complete the programming assignments on your own computers, the practical exams are done in a controlled environment using servers similar to the PE hosts. It is therefore advisable for you to familiarize yourself with accessing the PE servers via ssh and edit your program with either vim . Basic Requirements You need to have an SoC UNIX account. If you do not have one, you can apply for one online . Once you have an account, you need to activate your access to the PE hosts , which is part of the SoC computer clusters. You need an ssh client. macOS and Linux users should already have it installed by default. Windows 10 users should install the Windows Subsystem for Linux and use Linux. For older versions of Windows, such as those used in the SoC's programming labs, you can check out XShell 6 (free for home/school use), or PuTTY . These are GUI-based programs so the command lines instructions below do not apply. The Command to SSH Run: 1 ssh <username>@pe111.comp.nus.edu.sg Replace <username> with your SoC UNIX username, for instance, I would do: 1 ssh ooiwt@pe111.comp.nus.edu.sg After the command above, following the instructions on the screen. The first time you ever connect to pe111.comp.nus.edu.sg , you will be warned that you are connecting to a previously unknown host. Say yes , and you will be prompted with your SoC UNIX password. Accessing The PE Hosts from Outside SoC The PE hosts can only be accessed from within the School of Computing networks. If you want to access it from outside, you need to connect through SoC VPN. First, you need to set up a Virtual Private Network (VPN) (See instruction here ). The staff at helpdesk@comp.nus.edu.sg or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed. SoC VPN vs NUS VPN Note that SoC VPN is different from NUS VPN. Connecting to NUS VPN only allows you access to the NUS internal network, but not the SoC internal network. Windows 10 Users: FortiClient from Windows Store Students have reported that running FortiClient downloaded from the Windows Store does not allow one to ssh from WSL to SoC hosts as expected. Therefore, for Windows 10 users, please download and install FortiClient VPN directly from FortiClient's website . Setting up SSH Keys Once you are comfortable with UNIX, you can set up a pair of public/private keys for authentication. You can use 1 ssh-keygen -t rsa to generate a pair of keys on your local computer. Keep the private key id_rsa on your local machine in the hidden ~/.ssh directory, and copy the public key id_rsa.pub to your home directory on PE pe111 . On pe111 , run 1 cat id_rsa.pub >> ~/.ssh/authorized_keys Make sure that the permission for .ssh both on the local machine and on PE are set to 700 and the files id_rsa on the local machine and authorized_keys on the remote machine are set to 600 . Once set up, you need not enter your password every time you run ssh or scp . Stability of Network Connection Note that a stable network connection is required to use the PE hosts for a long period of time without interruption. If you encounter frequent disconnections while working at home or on campus while connected wirelessly, please make sure that your WiFi signal is strong and there is no interference from other sources. Troubleshooting Suppose you try to connect to pe111 using: 1 ssh pe111.comp.nus.edu.sg and you get the following error: ssh: Could not resolve hostname pe111.comp.nus.edu.sg ssh cannot recognize the name pe111 , it is likely that you are not connected to the SoC VPN, or downloaded the wrong version of FortiClient VPN . Connection closed by 192.168.48.xxx port 22 You have connected to the PE host, but you are kicked out because you have no permission to use the host. Make sure you have activated your access to \"SoC computer clusters\" here: https://mysoc.nus.edu.sg/~myacct/services.cgi Permission denied, please try again You did not enter the correct password or username. Please use the username and password of your SoC UNIX account which you have created here: https://mysoc.nus.edu.sg/~newacct/ . Check that you have entered your username correctly. It is case sensitive . If you have lost your password, go here: https://mysoc.nus.edu.sg/~myacct/resetpass.cgi Could not chdir to home directory /home/o/ooiwt: Permission denied This error means that you have successfully connect to the PE hosts, but you have no access to your own home directory. This should not happen. Please send an email with the above error message to helpdesk@comp.nus.edu.sg , include the PE hosts that you connected to with this error and your username. The system administrator can reset the permission of your home directory for you.","title":"Programming Environments"},{"location":"environments.html#the-cs1010-programming-environment","text":"C is a common programming language and you can find different implementations of C compiler on many platforms. Wikipedia lists more than 40 different C compilers . These different compilers support different processor architecture, operating systems, may behave slightly differently, and may support different features of C standards. It is therefore important for CS1010 to stick to a single platform and single compiler. Our platform of choice is Ubuntu 18.04 (or later) using the clang compiler ( version 6.0 or later ). The school has provided a list of computing servers for you to use. You can access them remotely via ssh , or secure shell. The hosts are named pe111 , pe112 , ... , pe120 . ( pe stands for \"programming environment\"). We will refer to these servers generally as the PE hosts. pe115 and pe116 For this semester, the two servers pe115 and pe116 are not available. You can choose which of the 8 hosts to use. You share the same home directory across all the hosts (this home directory, however, is different from that of stu ). For simplicity, the following guide uses pe111 in all examples. Do keep in mind that you can use other hosts for CS1010 to spread out the load. While it is possible for you to complete the programming assignments on your own computers, the practical exams are done in a controlled environment using servers similar to the PE hosts. It is therefore advisable for you to familiarize yourself with accessing the PE servers via ssh and edit your program with either vim .","title":"The CS1010 Programming Environment"},{"location":"environments.html#basic-requirements","text":"You need to have an SoC UNIX account. If you do not have one, you can apply for one online . Once you have an account, you need to activate your access to the PE hosts , which is part of the SoC computer clusters. You need an ssh client. macOS and Linux users should already have it installed by default. Windows 10 users should install the Windows Subsystem for Linux and use Linux. For older versions of Windows, such as those used in the SoC's programming labs, you can check out XShell 6 (free for home/school use), or PuTTY . These are GUI-based programs so the command lines instructions below do not apply.","title":"Basic Requirements"},{"location":"environments.html#the-command-to-ssh","text":"Run: 1 ssh <username>@pe111.comp.nus.edu.sg Replace <username> with your SoC UNIX username, for instance, I would do: 1 ssh ooiwt@pe111.comp.nus.edu.sg After the command above, following the instructions on the screen. The first time you ever connect to pe111.comp.nus.edu.sg , you will be warned that you are connecting to a previously unknown host. Say yes , and you will be prompted with your SoC UNIX password.","title":"The Command to SSH"},{"location":"environments.html#accessing-the-pe-hosts-from-outside-soc","text":"The PE hosts can only be accessed from within the School of Computing networks. If you want to access it from outside, you need to connect through SoC VPN. First, you need to set up a Virtual Private Network (VPN) (See instruction here ). The staff at helpdesk@comp.nus.edu.sg or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed. SoC VPN vs NUS VPN Note that SoC VPN is different from NUS VPN. Connecting to NUS VPN only allows you access to the NUS internal network, but not the SoC internal network. Windows 10 Users: FortiClient from Windows Store Students have reported that running FortiClient downloaded from the Windows Store does not allow one to ssh from WSL to SoC hosts as expected. Therefore, for Windows 10 users, please download and install FortiClient VPN directly from FortiClient's website .","title":"Accessing The PE Hosts from Outside SoC"},{"location":"environments.html#setting-up-ssh-keys","text":"Once you are comfortable with UNIX, you can set up a pair of public/private keys for authentication. You can use 1 ssh-keygen -t rsa to generate a pair of keys on your local computer. Keep the private key id_rsa on your local machine in the hidden ~/.ssh directory, and copy the public key id_rsa.pub to your home directory on PE pe111 . On pe111 , run 1 cat id_rsa.pub >> ~/.ssh/authorized_keys Make sure that the permission for .ssh both on the local machine and on PE are set to 700 and the files id_rsa on the local machine and authorized_keys on the remote machine are set to 600 . Once set up, you need not enter your password every time you run ssh or scp .","title":"Setting up SSH Keys"},{"location":"environments.html#stability-of-network-connection","text":"Note that a stable network connection is required to use the PE hosts for a long period of time without interruption. If you encounter frequent disconnections while working at home or on campus while connected wirelessly, please make sure that your WiFi signal is strong and there is no interference from other sources.","title":"Stability of Network Connection"},{"location":"environments.html#troubleshooting","text":"Suppose you try to connect to pe111 using: 1 ssh pe111.comp.nus.edu.sg and you get the following error: ssh: Could not resolve hostname pe111.comp.nus.edu.sg ssh cannot recognize the name pe111 , it is likely that you are not connected to the SoC VPN, or downloaded the wrong version of FortiClient VPN . Connection closed by 192.168.48.xxx port 22 You have connected to the PE host, but you are kicked out because you have no permission to use the host. Make sure you have activated your access to \"SoC computer clusters\" here: https://mysoc.nus.edu.sg/~myacct/services.cgi Permission denied, please try again You did not enter the correct password or username. Please use the username and password of your SoC UNIX account which you have created here: https://mysoc.nus.edu.sg/~newacct/ . Check that you have entered your username correctly. It is case sensitive . If you have lost your password, go here: https://mysoc.nus.edu.sg/~myacct/resetpass.cgi Could not chdir to home directory /home/o/ooiwt: Permission denied This error means that you have successfully connect to the PE hosts, but you have no access to your own home directory. This should not happen. Please send an email with the above error message to helpdesk@comp.nus.edu.sg , include the PE hosts that you connected to with this error and your username. The system administrator can reset the permission of your home directory for you.","title":"Troubleshooting"},{"location":"ex00.html","text":"Exercise 0: Echo, Divide, Ones, BMI, Quadratic This is your first programming exercise. An exercise is something that you do on your own. You can submit them but they will not be graded. Test cases are provided for the exercises so that you can test and check on your own if your code is correct. This is in contrast to an assignment, where you need to submit for grading and credits. Deadline This is an ungraded exercise. There is no deadline, but we encourage you to complete it before next Monday's lecture so that you do not fall behind. Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . Learning Outcomes Be comfortable writing simple C programs that involve arithmetic operations, long and double types, and standard I/O. One-Time Setup Before going into your first programming exercise, you need to do a one-time setup of your account on PE. Follow the instructions here . Accepting and Retrieving Assignments Click on this link to accept the exercise. Log in to one of the hosts of CS1010 programming environment (PE) Run the following on the command line on one of the PE hosts: 1 ~cs1010/get-ex00 You should see a new subdirectory ex00-<username> in your current working directory, where username is your GitHub username. We will call this directory your exercise directory or assignment directory . Inside that directory, you should see a bunch of files: echo.c , divide.c , bmi.c , ones.c and quadratic.c are the most important files. They are the skeleton C code that you should edit to solve the exercise. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the convention problem-name . test-id .in for input test data, and problem-name . test-id .out for output test data. So, you will see echo.1.in , divide.1.out , etc. The expected output for echo.1.in is in echo.1.out . You can look at the content of these files if you wish (which UNIX command should you use to do this?). You can edit these files to change the test input and output. Makefile : The configuration for the tool make that we use to automate the compilation and testing of the programs. You do not have to understand how to write a Makefile for CS1010. If you are interested to learn how to write a Makefile , talk to either Wei Tsang or Google. test.sh : A bash script for testing your code. You do not have to edit this file nor call it directly. It is invoked by make . If you are interested to learn how to write bash script, talk to either Wei Tsang or Google. compiler_flags.txt and .clang-tidy are two files used to configure clang and clang-tidy respectively. You do not need to edit this. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Elsa of Arendelle (Group B10) Solving The Assignments Edit the files echo.c , divide.c , bmi.c , ones.c and quadratic.c to solve the corresponding question as described below. To compile and run the given tests with the sample inputs and outputs, run on the command line, 1 make This command will compile the C files. If there is no compilation error, it will run the test scripts. make is smart enough that if you did not change the C file, it will not recompile the files again. You can read more about how you can become a power user of make in CS1010 . This list of common clang warnings and error messages might be helpful. Clean Compilation This is a reminder that, for your lab assignments and practical exams, any submission that cannot compile will receive 0. Further, each compilation warning will lead to a -1 mark deduction. So, please make it a habit to ensure that you can compile cleanly, starting with this ungraded exercise. Examining Individual Input/Output Files If your code prints the wrong output for some of the test inputs, familiarity with UNIX CLI would be helpful. Suppose that your code for problem echo fails on test case 3. To see the input of this test case, run: 1 cat inputs/echo.3.in To see the expected output: 1 cat outputs/echo.3.out To see what output your program gives, 1 ./echo < inputs/echo.3.in To test the program for a particular question (say, echo ), instead of all programs, 1 ./test.sh echo Submission When you are ready, run the following command while you are in the exercise directory: 1 ~cs1010/submit-ex00 The files echo.c , bmi.c , divide.c , ones.c , and quadratic.c will be uploaded to GitHub. You can submit multiple times. You are not allowed to interact with your CS1010 GitHub repositories using git commands or edit your files directly on GitHub's website. Doing so would interfere with the automation that we use for grading and would result in penalties (for graded assignments). Grading This assignment is not graded. Question 1: Echo Write a program echo (source file echo.c ) that reads in an integer and prints that integer to the standard output. Sample run: 1 2 3 4 5 6 ooiwt@pe111:~/ex00-ooiwt$ ./echo 123 123 ooiwt@pe111:~/ex00-ooiwt$ ./echo -1 -1 The text ooiwt@pe111:~/ex00-ooiwt$ is the command prompt. Yours will look different, of course. echo is the executable you created. The next line, 123 , is the input you provide. Press enter after the input. 123 is the output printed by echo . Question 2: Divide Write a program divide (source file divide.c ) that reads in two integers, \\(x\\) and \\(y\\) , and print the value of \\(x\\) divided by \\(y\\) . You can assume that \\(y\\) is never 0. Sample run: 1 2 3 4 5 6 ooiwt@pe111:~/ex00-ooiwt$ ./divide 10 2 5.0000 ooiwt@pe111:~/ex00-ooiwt$ ./divide 1 2 0.5000 Question Credit: Hu Jialun (cohort 20/21) Question 3: Ones Write a program ones (source file ones.c ) that reads in a positive integer \\(n\\) that is at least 10. Print two lines to the standard output: the first line contains the last digit of \\(n\\) . The next line contains all the other digits of \\(n\\) excluding the last one. Sample run: 1 2 3 4 5 6 7 8 ooiwt@pe111:~/ex00-ooiwt$ ./ones 10 0 1 ooiwt@pe111:~/ex00-ooiwt$ ./ones 95324 4 9532 Question 4: BMI Your body mass index (BMI) can be calculated by your body mass divided by the square of the body height. BMI is expressed in units of \\(kg/m^2\\) . Write a program bmi (source file bmi.c ) that reads in two real numbers \\(h\\) and \\(w\\) from the standard input. \\(h\\) is the height of a person in centimeters (cm) , and weight is the weight of the person in kilograms (kg). Your program must include a function called compute_bmi that takes in two parameters, the weight in kilograms (kg), and height in meters (m) , and return the corresponding BMI of the given weight and height. Question Credit: Hu Jialun (cohort 20/21) Sample run: 1 2 3 4 5 6 ooiwt@pe111:~/ex00-ooiwt$ ./bmi 100.0 50 50.0000 ooiwt@pe111:~/ex00-ooiwt$ ./bmi 182.9 70.125 20.9626 Question 5: Quadratic Write a program quadratic (source file quadratic.c ) that reads in three integers, \\(a\\) , \\(b\\) , and \\(c\\) , that represent the quadratic equation \\(ax^2 + bx + c = 0\\) , and prints its two roots. Assume that \\(a \\not = 0\\) and \\(b^2 > 4ac\\) . Recall that the roots are: \\[ \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} \\] Print the root \\(\\frac{-b + \\sqrt{b^2 - 4ac}}{2a}\\) first on one line, followed by the other root \\(\\frac{-b - \\sqrt{b^2 - 4ac}}{2a}\\) on the next line. Sample run: 1 2 3 4 5 6 7 8 ooiwt@pe111:~/ex00-ooiwt$ ./quadratic 1 -2 1 1.0000 1.0000 ooiwt@pe111:~/ex00-ooiwt$ ./quadratic 2 -7 3 3.0000 0.5000","title":"0. Echo, Divide, Ones, BMI, Quadratic"},{"location":"ex00.html#exercise-0-echo-divide-ones-bmi-quadratic","text":"This is your first programming exercise. An exercise is something that you do on your own. You can submit them but they will not be graded. Test cases are provided for the exercises so that you can test and check on your own if your code is correct. This is in contrast to an assignment, where you need to submit for grading and credits.","title":"Exercise 0: Echo, Divide, Ones, BMI, Quadratic"},{"location":"ex00.html#deadline","text":"This is an ungraded exercise. There is no deadline, but we encourage you to complete it before next Monday's lecture so that you do not fall behind.","title":"Deadline"},{"location":"ex00.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim .","title":"Prerequisite"},{"location":"ex00.html#learning-outcomes","text":"Be comfortable writing simple C programs that involve arithmetic operations, long and double types, and standard I/O.","title":"Learning Outcomes"},{"location":"ex00.html#one-time-setup","text":"Before going into your first programming exercise, you need to do a one-time setup of your account on PE. Follow the instructions here .","title":"One-Time Setup"},{"location":"ex00.html#accepting-and-retrieving-assignments","text":"Click on this link to accept the exercise. Log in to one of the hosts of CS1010 programming environment (PE) Run the following on the command line on one of the PE hosts: 1 ~cs1010/get-ex00 You should see a new subdirectory ex00-<username> in your current working directory, where username is your GitHub username. We will call this directory your exercise directory or assignment directory . Inside that directory, you should see a bunch of files: echo.c , divide.c , bmi.c , ones.c and quadratic.c are the most important files. They are the skeleton C code that you should edit to solve the exercise. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the convention problem-name . test-id .in for input test data, and problem-name . test-id .out for output test data. So, you will see echo.1.in , divide.1.out , etc. The expected output for echo.1.in is in echo.1.out . You can look at the content of these files if you wish (which UNIX command should you use to do this?). You can edit these files to change the test input and output. Makefile : The configuration for the tool make that we use to automate the compilation and testing of the programs. You do not have to understand how to write a Makefile for CS1010. If you are interested to learn how to write a Makefile , talk to either Wei Tsang or Google. test.sh : A bash script for testing your code. You do not have to edit this file nor call it directly. It is invoked by make . If you are interested to learn how to write bash script, talk to either Wei Tsang or Google. compiler_flags.txt and .clang-tidy are two files used to configure clang and clang-tidy respectively. You do not need to edit this.","title":"Accepting and Retrieving Assignments"},{"location":"ex00.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Elsa of Arendelle (Group B10)","title":"Identifying Yourself"},{"location":"ex00.html#solving-the-assignments","text":"Edit the files echo.c , divide.c , bmi.c , ones.c and quadratic.c to solve the corresponding question as described below. To compile and run the given tests with the sample inputs and outputs, run on the command line, 1 make This command will compile the C files. If there is no compilation error, it will run the test scripts. make is smart enough that if you did not change the C file, it will not recompile the files again. You can read more about how you can become a power user of make in CS1010 . This list of common clang warnings and error messages might be helpful. Clean Compilation This is a reminder that, for your lab assignments and practical exams, any submission that cannot compile will receive 0. Further, each compilation warning will lead to a -1 mark deduction. So, please make it a habit to ensure that you can compile cleanly, starting with this ungraded exercise.","title":"Solving The Assignments"},{"location":"ex00.html#examining-individual-inputoutput-files","text":"If your code prints the wrong output for some of the test inputs, familiarity with UNIX CLI would be helpful. Suppose that your code for problem echo fails on test case 3. To see the input of this test case, run: 1 cat inputs/echo.3.in To see the expected output: 1 cat outputs/echo.3.out To see what output your program gives, 1 ./echo < inputs/echo.3.in To test the program for a particular question (say, echo ), instead of all programs, 1 ./test.sh echo","title":"Examining Individual Input/Output Files"},{"location":"ex00.html#submission","text":"When you are ready, run the following command while you are in the exercise directory: 1 ~cs1010/submit-ex00 The files echo.c , bmi.c , divide.c , ones.c , and quadratic.c will be uploaded to GitHub. You can submit multiple times. You are not allowed to interact with your CS1010 GitHub repositories using git commands or edit your files directly on GitHub's website. Doing so would interfere with the automation that we use for grading and would result in penalties (for graded assignments).","title":"Submission"},{"location":"ex00.html#grading","text":"This assignment is not graded.","title":"Grading"},{"location":"ex00.html#question-1-echo","text":"Write a program echo (source file echo.c ) that reads in an integer and prints that integer to the standard output.","title":"Question 1: Echo"},{"location":"ex00.html#sample-run","text":"1 2 3 4 5 6 ooiwt@pe111:~/ex00-ooiwt$ ./echo 123 123 ooiwt@pe111:~/ex00-ooiwt$ ./echo -1 -1 The text ooiwt@pe111:~/ex00-ooiwt$ is the command prompt. Yours will look different, of course. echo is the executable you created. The next line, 123 , is the input you provide. Press enter after the input. 123 is the output printed by echo .","title":"Sample run:"},{"location":"ex00.html#question-2-divide","text":"Write a program divide (source file divide.c ) that reads in two integers, \\(x\\) and \\(y\\) , and print the value of \\(x\\) divided by \\(y\\) . You can assume that \\(y\\) is never 0.","title":"Question 2: Divide"},{"location":"ex00.html#sample-run_1","text":"1 2 3 4 5 6 ooiwt@pe111:~/ex00-ooiwt$ ./divide 10 2 5.0000 ooiwt@pe111:~/ex00-ooiwt$ ./divide 1 2 0.5000 Question Credit: Hu Jialun (cohort 20/21)","title":"Sample run:"},{"location":"ex00.html#question-3-ones","text":"Write a program ones (source file ones.c ) that reads in a positive integer \\(n\\) that is at least 10. Print two lines to the standard output: the first line contains the last digit of \\(n\\) . The next line contains all the other digits of \\(n\\) excluding the last one.","title":"Question 3: Ones"},{"location":"ex00.html#sample-run_2","text":"1 2 3 4 5 6 7 8 ooiwt@pe111:~/ex00-ooiwt$ ./ones 10 0 1 ooiwt@pe111:~/ex00-ooiwt$ ./ones 95324 4 9532","title":"Sample run:"},{"location":"ex00.html#question-4-bmi","text":"Your body mass index (BMI) can be calculated by your body mass divided by the square of the body height. BMI is expressed in units of \\(kg/m^2\\) . Write a program bmi (source file bmi.c ) that reads in two real numbers \\(h\\) and \\(w\\) from the standard input. \\(h\\) is the height of a person in centimeters (cm) , and weight is the weight of the person in kilograms (kg). Your program must include a function called compute_bmi that takes in two parameters, the weight in kilograms (kg), and height in meters (m) , and return the corresponding BMI of the given weight and height. Question Credit: Hu Jialun (cohort 20/21)","title":"Question 4: BMI"},{"location":"ex00.html#sample-run_3","text":"1 2 3 4 5 6 ooiwt@pe111:~/ex00-ooiwt$ ./bmi 100.0 50 50.0000 ooiwt@pe111:~/ex00-ooiwt$ ./bmi 182.9 70.125 20.9626","title":"Sample run:"},{"location":"ex00.html#question-5-quadratic","text":"Write a program quadratic (source file quadratic.c ) that reads in three integers, \\(a\\) , \\(b\\) , and \\(c\\) , that represent the quadratic equation \\(ax^2 + bx + c = 0\\) , and prints its two roots. Assume that \\(a \\not = 0\\) and \\(b^2 > 4ac\\) . Recall that the roots are: \\[ \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} \\] Print the root \\(\\frac{-b + \\sqrt{b^2 - 4ac}}{2a}\\) first on one line, followed by the other root \\(\\frac{-b - \\sqrt{b^2 - 4ac}}{2a}\\) on the next line.","title":"Question 5: Quadratic"},{"location":"ex00.html#sample-run_4","text":"1 2 3 4 5 6 7 8 ooiwt@pe111:~/ex00-ooiwt$ ./quadratic 1 -2 1 1.0000 1.0000 ooiwt@pe111:~/ex00-ooiwt$ ./quadratic 2 -7 3 3.0000 0.5000","title":"Sample run:"},{"location":"ex01.html","text":"Exercise 1: Odd, Sum, Triangle, Burger Deadline This is an ungraded exercise. There is no deadline, but we encourage you to complete it before Thursday's lab so that you do not fall behind. Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You are familiar with basic C syntax and arithmetic operations, and have completed at least 3 of 5 questions from Exercise 0 . Learning Outcomes Be comfortable writing simple C programs that involve conditional statements and logical expressions. Accepting and Retrieving Assignments Click on this link to accept the exercise. Log in to one of the hosts of CS1010 programming environment (PE) Run the following on the command line on one of the PE hosts: 1 ~cs1010/get-ex01 You should see a new subdirectory ex01-<username> in your current working directory, where username is your GitHub username. We will call this directory your exercise directory or assignment directory . Inside that directory, you should see a bunch of files: odd.c , sum.c , triangle.c , and burger.c are the most important files. They are the skeleton C code that you should edit to solve the exercise. inputs and outputs are subdirectories that contain test inputs and test outputs. Makefile : The configuration for the tool make that we use to automate the compilation and testing of the programs. You do not have to understand how to write a Makefile for CS1010. If you are interested to learn how to write a Makefile , talk to either Wei Tsang or Google. test.sh : A bash script for testing your code. You do not have to edit this file. If you are interested to learn how to write bash script, talk to either Wei Tsang or Google. compiler_flags.txt and .clang-tidy are two files used to configure clang and clang-tidy respectively. You do not need to edit this. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author King T'Challa (Group A10) Solving The Assignments Edit the files odd.c , sum.c , triangle.c , burger.c to solve the corresponding question as described below. To compile and run the given tests with the sample inputs and outputs, run on the command line, 1 make This command will compile the C files. If there is no compilation error, it will run the test scripts. make is smart enough that if you did not change the C file, it will not recompile the files again. You can read more about how you can become a power user of make in CS1010 . This list of common clang warnings and error messages might be helpful. Clean Compilation This is a reminder that, for your lab assignments and practical exams, any submission that cannot compile will receive 0. Further, each compilation warning will lead to a -1 mark deduction. So, please make it a habit to ensure that you can compile cleanly, starting with this ungraded exercise. Examining Individual Input/Output Files If your code prints the wrong output for some of the test inputs, familiarity with UNIX CLI would be helpful. Suppose that your code for problem echo fails on test case 3. To see the input of this test case, run: 1 cat inputs/echo.3.in To see the expected output: 1 cat outputs/echo.3.out To see what output your program gives, 1 ./echo < inputs/echo.3.in To test the program for a particular question (say, echo ), instead of all programs, 1 ./test.sh echo Submission When you are ready, run the following command while you are in the exercise directory: 1 ~cs1010/submit-ex01 The files odd.c , sum.c , triangle.c , and burger.c will be uploaded to GitHub. You can submit multiple times. You are not allowed to interact with your CS1010 GitHub repositories using git commands or edit your files directly on GitHub's website. Doing so would interfere with the automation that we use for grading and would result in penalties (for graded assignments). Grading This assignment is not graded. Question 1: Odd Write a program odd (source file odd.c ) that reads in an integer \\(n\\) and prints that smallest odd number that is larger than \\(n\\) to the standard output. Sample run: 1 2 3 4 5 6 ooiwt@pe112:~/ex01-ooiwt$ ./odd 1234 1235 ooiwt@pe112:~/ex01-ooiwt$ ./echo -1 1 Note: There is a less straightforward way to solve this question without using conditional statements. See if you can solve it this way! (Credit: Hu Jialun (cohort 20/21)) Question 2: Sum Write a program sum (source file sum.c ) that reads in two integers, \\(x\\) and \\(y\\) , ignore any negative numbers, and prints the sum of the remaining (non-negative) numbers. If both numbers are negatives, the sum is 0. Sample run: 1 2 3 4 5 6 7 8 9 10 11 12 ooiwt@pe111:~/ex01-ooiwt$ ./sum 123456 -100 123456 ooiwt@pe111:~/ex01-ooiwt$ ./sum -1 -2 0 ooiwt@pe111:~/ex01-ooiwt$ ./sum 1 2 3 Question 3: Triangle Triangle is a three-sided shape and is a very common shape everywhere. In a triangle, the sum of the length of any two sides is always longer than of the third side. The area of the triangle with sides \\(a\\) , \\(b\\) , \\(c\\) , can be computed with Heron's formula: \\[\\sqrt{s(s-a)(s-b)(s-c)}\\] where \\(s\\) is half of the perimeter: \\[s = \\frac{a + b + c}{2}\\] Write a program triangle, that reads from standard input three positive integers representing the three sides of a triangle Print, to the standard output, Possible if it is possible to create such triangle, followed by the area of the triangle; Impossible if it is impossible to create such a triangle. For instance, suppose that you are given the three sides of a triangle 3 4 5 . Then you will have to print: 1 2 Possible 6.0000 One more example, suppose that you are given the three sides 4 4 10 . Then you will have to print: 1 Impossible Sample run: 1 2 3 4 5 6 7 ooiwt@pe111:~/ex01-ooiwt$ ./triangle 3 4 5 Possible 6.0000 ooiwt@pe111:~/ex01-ooiwt$ ./triangle 4 4 10 Impossible Question Credit: Albert Sutiono (cohort 20/21) Question 4: Burger Who doesn't love burger? With approximately 50 billion burger eaten each year in AMERICA alone, it has become one of the most iconic and popular food in the world. We will follow the story of Andy, a CS1010 student who loves burger. Andy has a burger chain that he started since 2020. He is, however, a bit careless when ordering the stock of ingredients for each month. He does not really plan on how many burgers he is planning to sell, but instead buy the ingredients by feeling. To help him, it will be useful to know how many burgers his restaurant can make during the month. Fortunately, he notes all the ingredients that he bought e.g. how many patties, how many tomatoes, how many cheese, etc. Let's help Andy with your skills in C programming. In this question, you are to calculate the maximum number of proper burgers that can be made in respect to each ingredients count. A proper burger needs 3 buns (more like a Big Mac), 2 patties, 1 cheese, 15 sesame seeds, and 5 pickles. The input to your program will be the number of buns, patties, cheese, sesame seeds, and pickles respectively. For instance, suppose that the input is 20 20 20 20 20 . Then you will have to print: 1 1 burger Explanation: Ingredients Count Proper Burger Buns 20 6 Patties 20 10 Cheese 20 20 Sesame Seeds 20 1 Pickles 20 4 Here, as the least possible number of proper burger is 1, the correct answer of the number of proper burgers (with respect to all ingredients) is 1. One more example, suppose that the input is 15 6 3 45 13 . Then you will have to print: 1 2 burgers Explanation: Ingredients Count Proper Burger Buns 15 5 Patties 6 3 Cheese 3 3 Sesame Seeds 45 3 Pickles 13 2 Here, as the least possible number of proper burger is 2, the correct answer of the number of proper burgers (with respect to all ingredients) is 2. Write a program burger , that reads from standard input: Five positive integers, which correspond to buns, patties, cheese, sesame seeds, and pickles respectively. Print, to the standard output, on one line, the integer that corresponds to the number of proper burgers that can be made, followed by the correct plural form word burger (for one burger) or burgers (otherwise) Sample Run 1 2 3 4 5 6 albertsutz@pe119:~/ex01-albertsutz$ ./burger 20 20 20 20 20 1 burger albertsutz@pe119:~/ex01-albertsutz$ ./burger 15 6 3 45 13 2 burgers Question Credit: Albert Sutiono (cohort 20/21)","title":"1. Odd, Sum, Triangle, Burger"},{"location":"ex01.html#exercise-1-odd-sum-triangle-burger","text":"","title":"Exercise 1: Odd, Sum, Triangle, Burger"},{"location":"ex01.html#deadline","text":"This is an ungraded exercise. There is no deadline, but we encourage you to complete it before Thursday's lab so that you do not fall behind.","title":"Deadline"},{"location":"ex01.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You are familiar with basic C syntax and arithmetic operations, and have completed at least 3 of 5 questions from Exercise 0 .","title":"Prerequisite"},{"location":"ex01.html#learning-outcomes","text":"Be comfortable writing simple C programs that involve conditional statements and logical expressions.","title":"Learning Outcomes"},{"location":"ex01.html#accepting-and-retrieving-assignments","text":"Click on this link to accept the exercise. Log in to one of the hosts of CS1010 programming environment (PE) Run the following on the command line on one of the PE hosts: 1 ~cs1010/get-ex01 You should see a new subdirectory ex01-<username> in your current working directory, where username is your GitHub username. We will call this directory your exercise directory or assignment directory . Inside that directory, you should see a bunch of files: odd.c , sum.c , triangle.c , and burger.c are the most important files. They are the skeleton C code that you should edit to solve the exercise. inputs and outputs are subdirectories that contain test inputs and test outputs. Makefile : The configuration for the tool make that we use to automate the compilation and testing of the programs. You do not have to understand how to write a Makefile for CS1010. If you are interested to learn how to write a Makefile , talk to either Wei Tsang or Google. test.sh : A bash script for testing your code. You do not have to edit this file. If you are interested to learn how to write bash script, talk to either Wei Tsang or Google. compiler_flags.txt and .clang-tidy are two files used to configure clang and clang-tidy respectively. You do not need to edit this.","title":"Accepting and Retrieving Assignments"},{"location":"ex01.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author King T'Challa (Group A10)","title":"Identifying Yourself"},{"location":"ex01.html#solving-the-assignments","text":"Edit the files odd.c , sum.c , triangle.c , burger.c to solve the corresponding question as described below. To compile and run the given tests with the sample inputs and outputs, run on the command line, 1 make This command will compile the C files. If there is no compilation error, it will run the test scripts. make is smart enough that if you did not change the C file, it will not recompile the files again. You can read more about how you can become a power user of make in CS1010 . This list of common clang warnings and error messages might be helpful. Clean Compilation This is a reminder that, for your lab assignments and practical exams, any submission that cannot compile will receive 0. Further, each compilation warning will lead to a -1 mark deduction. So, please make it a habit to ensure that you can compile cleanly, starting with this ungraded exercise.","title":"Solving The Assignments"},{"location":"ex01.html#examining-individual-inputoutput-files","text":"If your code prints the wrong output for some of the test inputs, familiarity with UNIX CLI would be helpful. Suppose that your code for problem echo fails on test case 3. To see the input of this test case, run: 1 cat inputs/echo.3.in To see the expected output: 1 cat outputs/echo.3.out To see what output your program gives, 1 ./echo < inputs/echo.3.in To test the program for a particular question (say, echo ), instead of all programs, 1 ./test.sh echo","title":"Examining Individual Input/Output Files"},{"location":"ex01.html#submission","text":"When you are ready, run the following command while you are in the exercise directory: 1 ~cs1010/submit-ex01 The files odd.c , sum.c , triangle.c , and burger.c will be uploaded to GitHub. You can submit multiple times. You are not allowed to interact with your CS1010 GitHub repositories using git commands or edit your files directly on GitHub's website. Doing so would interfere with the automation that we use for grading and would result in penalties (for graded assignments).","title":"Submission"},{"location":"ex01.html#grading","text":"This assignment is not graded.","title":"Grading"},{"location":"ex01.html#question-1-odd","text":"Write a program odd (source file odd.c ) that reads in an integer \\(n\\) and prints that smallest odd number that is larger than \\(n\\) to the standard output.","title":"Question 1: Odd"},{"location":"ex01.html#sample-run","text":"1 2 3 4 5 6 ooiwt@pe112:~/ex01-ooiwt$ ./odd 1234 1235 ooiwt@pe112:~/ex01-ooiwt$ ./echo -1 1 Note: There is a less straightforward way to solve this question without using conditional statements. See if you can solve it this way! (Credit: Hu Jialun (cohort 20/21))","title":"Sample run:"},{"location":"ex01.html#question-2-sum","text":"Write a program sum (source file sum.c ) that reads in two integers, \\(x\\) and \\(y\\) , ignore any negative numbers, and prints the sum of the remaining (non-negative) numbers. If both numbers are negatives, the sum is 0.","title":"Question 2: Sum"},{"location":"ex01.html#sample-run_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 ooiwt@pe111:~/ex01-ooiwt$ ./sum 123456 -100 123456 ooiwt@pe111:~/ex01-ooiwt$ ./sum -1 -2 0 ooiwt@pe111:~/ex01-ooiwt$ ./sum 1 2 3","title":"Sample run:"},{"location":"ex01.html#question-3-triangle","text":"Triangle is a three-sided shape and is a very common shape everywhere. In a triangle, the sum of the length of any two sides is always longer than of the third side. The area of the triangle with sides \\(a\\) , \\(b\\) , \\(c\\) , can be computed with Heron's formula: \\[\\sqrt{s(s-a)(s-b)(s-c)}\\] where \\(s\\) is half of the perimeter: \\[s = \\frac{a + b + c}{2}\\] Write a program triangle, that reads from standard input three positive integers representing the three sides of a triangle Print, to the standard output, Possible if it is possible to create such triangle, followed by the area of the triangle; Impossible if it is impossible to create such a triangle. For instance, suppose that you are given the three sides of a triangle 3 4 5 . Then you will have to print: 1 2 Possible 6.0000 One more example, suppose that you are given the three sides 4 4 10 . Then you will have to print: 1 Impossible","title":"Question 3: Triangle"},{"location":"ex01.html#sample-run_2","text":"1 2 3 4 5 6 7 ooiwt@pe111:~/ex01-ooiwt$ ./triangle 3 4 5 Possible 6.0000 ooiwt@pe111:~/ex01-ooiwt$ ./triangle 4 4 10 Impossible Question Credit: Albert Sutiono (cohort 20/21)","title":"Sample run:"},{"location":"ex01.html#question-4-burger","text":"Who doesn't love burger? With approximately 50 billion burger eaten each year in AMERICA alone, it has become one of the most iconic and popular food in the world. We will follow the story of Andy, a CS1010 student who loves burger. Andy has a burger chain that he started since 2020. He is, however, a bit careless when ordering the stock of ingredients for each month. He does not really plan on how many burgers he is planning to sell, but instead buy the ingredients by feeling. To help him, it will be useful to know how many burgers his restaurant can make during the month. Fortunately, he notes all the ingredients that he bought e.g. how many patties, how many tomatoes, how many cheese, etc. Let's help Andy with your skills in C programming. In this question, you are to calculate the maximum number of proper burgers that can be made in respect to each ingredients count. A proper burger needs 3 buns (more like a Big Mac), 2 patties, 1 cheese, 15 sesame seeds, and 5 pickles. The input to your program will be the number of buns, patties, cheese, sesame seeds, and pickles respectively. For instance, suppose that the input is 20 20 20 20 20 . Then you will have to print: 1 1 burger Explanation: Ingredients Count Proper Burger Buns 20 6 Patties 20 10 Cheese 20 20 Sesame Seeds 20 1 Pickles 20 4 Here, as the least possible number of proper burger is 1, the correct answer of the number of proper burgers (with respect to all ingredients) is 1. One more example, suppose that the input is 15 6 3 45 13 . Then you will have to print: 1 2 burgers Explanation: Ingredients Count Proper Burger Buns 15 5 Patties 6 3 Cheese 3 3 Sesame Seeds 45 3 Pickles 13 2 Here, as the least possible number of proper burger is 2, the correct answer of the number of proper burgers (with respect to all ingredients) is 2. Write a program burger , that reads from standard input: Five positive integers, which correspond to buns, patties, cheese, sesame seeds, and pickles respectively. Print, to the standard output, on one line, the integer that corresponds to the number of proper burgers that can be made, followed by the correct plural form word burger (for one burger) or burgers (otherwise)","title":"Question 4: Burger"},{"location":"ex01.html#sample-run_3","text":"1 2 3 4 5 6 albertsutz@pe119:~/ex01-albertsutz$ ./burger 20 20 20 20 20 1 burger albertsutz@pe119:~/ex01-albertsutz$ ./burger 15 6 3 45 13 2 burgers Question Credit: Albert Sutiono (cohort 20/21)","title":"Sample Run"},{"location":"ex02.html","text":"Exercise 2: Date, GCD, Leap, Multiple Deadline This is an ungraded exercise. There is no deadline, but we encourage you to complete it before Thursday's lab so that you do not fall behind. Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You are familiar with basic C syntax and arithmetic operations, and have completed at least 3 of 5 questions from Exercise 0 . Learning Outcomes Be comfortable writing simple C programs that involve conditional statements and logical expressions. Accepting and Retrieving Assignments Click on this link to accept the exercise. Log in to one of the hosts of CS1010 programming environment (PE) Run the following on the command line on one of the PE hosts: 1 ~cs1010/get-ex02 You should see a new subdirectory ex02-<username> in your current working directory, where username is your GitHub username. We will call this directory your exercise directory or assignment directory . Inside that directory, you should see a bunch of files: date.c , gcd.c , leap.c , and multiple.c are the most important files. They are the skeleton C code that you should edit to solve the exercise. inputs and outputs are subdirectories that contain test inputs and test outputs. Makefile : The configuration for the tool make that we use to automate the compilation and testing of the programs. You do not have to understand how to write a Makefile for CS1010. If you are interested to learn how to write a Makefile , talk to either Wei Tsang or Google. test.sh : A bash script for testing your code. You do not have to edit this file. If you are interested to learn how to write bash script, talk to either Wei Tsang or Google. compiler_flags.txt and .clang-tidy are two files used to configure clang and clang-tidy respectively. You do not need to edit this. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Kamala Khan (Group A10) Solving The Assignments Edit the files date.c , gcd.c , leap.c , multiple.c to solve the corresponding question as described below. To compile and run the given tests with the sample inputs and outputs, run on the command line, 1 make This command will compile the C files. If there is no compilation error, it will run the test scripts. make is smart enough that if you did not change the C file, it will not recompile the files again. You can read more about how you can become a power user of make in CS1010 . This list of common clang warnings and error messages might be helpful. Clean Compilation This is a reminder that, for your lab assignments and practical exams, any submission that cannot compile will receive 0. Further, each compilation warning will lead to a -1 mark deduction. So, please make it a habit to ensure that you can compile cleanly, starting with this ungraded exercise. Examining Individual Input/Output Files If your code prints the wrong output for some of the test inputs, familiarity with UNIX CLI would be helpful. Suppose that your code for problem echo fails on test case 3. To see the input of this test case, run: 1 cat inputs/echo.3.in To see the expected output: 1 cat outputs/echo.3.out To see what output your program gives, 1 ./echo < inputs/echo.3.in To test the program for a particular question (say, echo ), instead of all programs, 1 ./test.sh echo Submission When you are ready, run the following command while you are in the exercise directory: 1 ~cs1010/submit-ex02 The files date.c , gcd.c , leap.c , and multiple.c will be uploaded to GitHub. You can submit multiple times. You are not allowed to interact with your CS1010 GitHub repositories using git commands or edit your files directly on GitHub's website. Doing so would interfere with the automation that we use for grading and would result in penalties (for graded assignments). Grading This assignment is not graded. Question 1: Date A date consists of two integers, a month (1 - 12) and a day (1 - 31). Given three dates (of the same year), we want to find out if the given dates are sorted in increasing order. Write a program date (source file date.c ) that reads in three pairs of integers from the standard input, in the order of \\(m_1\\) , \\(d_1\\) , \\(m_2\\) , \\(d_2\\) , \\(m_3\\) , and \\(d_3\\) . Print yes to the standard output the date ( \\(m_1, d_1\\) ) is strictly before ( \\(m_2, d_2\\) ), and the date ( \\(m_2, d_2\\) ) is strictly before ( \\(m_3, d_3\\) ). Think: Can you break this problem down into a simpler subproblem? Sample run: 1 2 3 4 5 6 7 8 9 10 ooiwt@pe112:~/ex02-ooiwt$ ./date 1 1 12 31 6 6 no ooiwt@pe112:~/ex02-ooiwt$ ./date 5 5 6 1 7 3 yes Question 2: GCD The GCD, or greatest common divisor, of two integers, is the largest positive integer that divides each of the integer. For example, GCD of 8 and 12 is 4. The famous Greek mathematician, Euclid, introduce the following recursive method to compute the GCD of two integers \\(x\\) and \\(y\\) (we assume \\(x \\ge y\\) without loss of generality): If the two integers are the same ( \\(x\\) is the same as \\(y\\) ) then the GCD of these two integers is just \\(x\\) . Otherwise, the GCD of \\(x\\) and \\(y\\) is the same as the GCD of \\(x - y\\) and \\(y\\) . For example, the GCD of 8 and 12, is the same as the GCD of 8 and 4 (since 12 - 8 is 4), which is the same as the GCD of 4 and 4. So the answer is 4. Write a program gcd (source file gcd.c ) that reads in two positive integers, \\(x\\) and \\(y\\) , and prints their GCD. Your program must solve this problem recursively, without using any loops. Sample run: 1 2 3 4 5 6 ooiwt@pe112:~/ex02-ooiwt$ ./gcd 48 32 16 ooiwt@pe112:~/ex02-ooiwt$ ./gcd 1 1 1 Question 3: Leap Year A leap year is a calendar year containing an extra day to synchronize the calendar to seasons and astronomical events. In the Gregorian calendar, years that are multiples of four (except for years divisible by 100 but not by 400) are leap years. Complete the program leap.c so that it reads in an integer representing a year from the standard input and prints out \" is a leap year\" if the input is a leap year. Otherwise, print \" is not a leap year\" to the standard output. Your program should include a bool function is_leap_year that takes in the input year and returns true if the input is a leap year and returns false otherwise. Sample run: 1 2 3 4 5 6 7 8 9 10 11 12 ooiwt@pe112:~/ex02-ooiwt$ ./leap 1995 1995 is not a leap year ooiwt@pe112:~/ex02-ooiwt$ ./leap 1996 1996 is a leap year ooiwt@pe112:~/ex02-ooiwt$ ./leap 1900 1900 is not a leap year ooiwt@pe112:~/ex02-ooiwt$ ./leap 2000 2000 is a leap year Question 4: Multiple Given two integers, we want to check if one is a multiple of the other. By definition, 0 is the multiple of any number. Write a program multiple that reads two integers from the standard input, and print true to the standard output if one integer is the multiple of the other. Print false otherwise. 1 2 3 4 5 6 7 8 9 ooiwt@pe112:~/ex02-ooiwt$ ./multiple 3 8 false ooiwt@pe112:~/ex02-ooiwt$ ./multiple 8 2 true ooiwt@pe112:~/ex02-ooiwt$ ./multiple 0 190 true Question Credit: Hu Jialun (Cohort 20/21)","title":"2. Date, GCD, Leap, Multiple"},{"location":"ex02.html#exercise-2-date-gcd-leap-multiple","text":"","title":"Exercise 2: Date, GCD, Leap, Multiple"},{"location":"ex02.html#deadline","text":"This is an ungraded exercise. There is no deadline, but we encourage you to complete it before Thursday's lab so that you do not fall behind.","title":"Deadline"},{"location":"ex02.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You are familiar with basic C syntax and arithmetic operations, and have completed at least 3 of 5 questions from Exercise 0 .","title":"Prerequisite"},{"location":"ex02.html#learning-outcomes","text":"Be comfortable writing simple C programs that involve conditional statements and logical expressions.","title":"Learning Outcomes"},{"location":"ex02.html#accepting-and-retrieving-assignments","text":"Click on this link to accept the exercise. Log in to one of the hosts of CS1010 programming environment (PE) Run the following on the command line on one of the PE hosts: 1 ~cs1010/get-ex02 You should see a new subdirectory ex02-<username> in your current working directory, where username is your GitHub username. We will call this directory your exercise directory or assignment directory . Inside that directory, you should see a bunch of files: date.c , gcd.c , leap.c , and multiple.c are the most important files. They are the skeleton C code that you should edit to solve the exercise. inputs and outputs are subdirectories that contain test inputs and test outputs. Makefile : The configuration for the tool make that we use to automate the compilation and testing of the programs. You do not have to understand how to write a Makefile for CS1010. If you are interested to learn how to write a Makefile , talk to either Wei Tsang or Google. test.sh : A bash script for testing your code. You do not have to edit this file. If you are interested to learn how to write bash script, talk to either Wei Tsang or Google. compiler_flags.txt and .clang-tidy are two files used to configure clang and clang-tidy respectively. You do not need to edit this.","title":"Accepting and Retrieving Assignments"},{"location":"ex02.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Kamala Khan (Group A10)","title":"Identifying Yourself"},{"location":"ex02.html#solving-the-assignments","text":"Edit the files date.c , gcd.c , leap.c , multiple.c to solve the corresponding question as described below. To compile and run the given tests with the sample inputs and outputs, run on the command line, 1 make This command will compile the C files. If there is no compilation error, it will run the test scripts. make is smart enough that if you did not change the C file, it will not recompile the files again. You can read more about how you can become a power user of make in CS1010 . This list of common clang warnings and error messages might be helpful. Clean Compilation This is a reminder that, for your lab assignments and practical exams, any submission that cannot compile will receive 0. Further, each compilation warning will lead to a -1 mark deduction. So, please make it a habit to ensure that you can compile cleanly, starting with this ungraded exercise.","title":"Solving The Assignments"},{"location":"ex02.html#examining-individual-inputoutput-files","text":"If your code prints the wrong output for some of the test inputs, familiarity with UNIX CLI would be helpful. Suppose that your code for problem echo fails on test case 3. To see the input of this test case, run: 1 cat inputs/echo.3.in To see the expected output: 1 cat outputs/echo.3.out To see what output your program gives, 1 ./echo < inputs/echo.3.in To test the program for a particular question (say, echo ), instead of all programs, 1 ./test.sh echo","title":"Examining Individual Input/Output Files"},{"location":"ex02.html#submission","text":"When you are ready, run the following command while you are in the exercise directory: 1 ~cs1010/submit-ex02 The files date.c , gcd.c , leap.c , and multiple.c will be uploaded to GitHub. You can submit multiple times. You are not allowed to interact with your CS1010 GitHub repositories using git commands or edit your files directly on GitHub's website. Doing so would interfere with the automation that we use for grading and would result in penalties (for graded assignments).","title":"Submission"},{"location":"ex02.html#grading","text":"This assignment is not graded.","title":"Grading"},{"location":"ex02.html#question-1-date","text":"A date consists of two integers, a month (1 - 12) and a day (1 - 31). Given three dates (of the same year), we want to find out if the given dates are sorted in increasing order. Write a program date (source file date.c ) that reads in three pairs of integers from the standard input, in the order of \\(m_1\\) , \\(d_1\\) , \\(m_2\\) , \\(d_2\\) , \\(m_3\\) , and \\(d_3\\) . Print yes to the standard output the date ( \\(m_1, d_1\\) ) is strictly before ( \\(m_2, d_2\\) ), and the date ( \\(m_2, d_2\\) ) is strictly before ( \\(m_3, d_3\\) ). Think: Can you break this problem down into a simpler subproblem?","title":"Question 1: Date"},{"location":"ex02.html#sample-run","text":"1 2 3 4 5 6 7 8 9 10 ooiwt@pe112:~/ex02-ooiwt$ ./date 1 1 12 31 6 6 no ooiwt@pe112:~/ex02-ooiwt$ ./date 5 5 6 1 7 3 yes","title":"Sample run:"},{"location":"ex02.html#question-2-gcd","text":"The GCD, or greatest common divisor, of two integers, is the largest positive integer that divides each of the integer. For example, GCD of 8 and 12 is 4. The famous Greek mathematician, Euclid, introduce the following recursive method to compute the GCD of two integers \\(x\\) and \\(y\\) (we assume \\(x \\ge y\\) without loss of generality): If the two integers are the same ( \\(x\\) is the same as \\(y\\) ) then the GCD of these two integers is just \\(x\\) . Otherwise, the GCD of \\(x\\) and \\(y\\) is the same as the GCD of \\(x - y\\) and \\(y\\) . For example, the GCD of 8 and 12, is the same as the GCD of 8 and 4 (since 12 - 8 is 4), which is the same as the GCD of 4 and 4. So the answer is 4. Write a program gcd (source file gcd.c ) that reads in two positive integers, \\(x\\) and \\(y\\) , and prints their GCD. Your program must solve this problem recursively, without using any loops.","title":"Question 2: GCD"},{"location":"ex02.html#sample-run_1","text":"1 2 3 4 5 6 ooiwt@pe112:~/ex02-ooiwt$ ./gcd 48 32 16 ooiwt@pe112:~/ex02-ooiwt$ ./gcd 1 1 1","title":"Sample run:"},{"location":"ex02.html#question-3-leap-year","text":"A leap year is a calendar year containing an extra day to synchronize the calendar to seasons and astronomical events. In the Gregorian calendar, years that are multiples of four (except for years divisible by 100 but not by 400) are leap years. Complete the program leap.c so that it reads in an integer representing a year from the standard input and prints out \" is a leap year\" if the input is a leap year. Otherwise, print \" is not a leap year\" to the standard output. Your program should include a bool function is_leap_year that takes in the input year and returns true if the input is a leap year and returns false otherwise.","title":"Question 3: Leap Year"},{"location":"ex02.html#sample-run_2","text":"1 2 3 4 5 6 7 8 9 10 11 12 ooiwt@pe112:~/ex02-ooiwt$ ./leap 1995 1995 is not a leap year ooiwt@pe112:~/ex02-ooiwt$ ./leap 1996 1996 is a leap year ooiwt@pe112:~/ex02-ooiwt$ ./leap 1900 1900 is not a leap year ooiwt@pe112:~/ex02-ooiwt$ ./leap 2000 2000 is a leap year","title":"Sample run:"},{"location":"ex02.html#question-4-multiple","text":"Given two integers, we want to check if one is a multiple of the other. By definition, 0 is the multiple of any number. Write a program multiple that reads two integers from the standard input, and print true to the standard output if one integer is the multiple of the other. Print false otherwise. 1 2 3 4 5 6 7 8 9 ooiwt@pe112:~/ex02-ooiwt$ ./multiple 3 8 false ooiwt@pe112:~/ex02-ooiwt$ ./multiple 8 2 true ooiwt@pe112:~/ex02-ooiwt$ ./multiple 0 190 true Question Credit: Hu Jialun (Cohort 20/21)","title":"Question 4: Multiple"},{"location":"ex03-comments.html","text":"Exercise 3: Three, Factor, Parity, Nine, HDB Guide Question 1: Three Write a program called three that reads in two integers \\(x\\) and \\(y\\) from the standard input, and prints to the standard outputs, all multiples of three between \\(x\\) and \\(y\\) (inclusive). Guide to Question 1: The question is not very clear about the meaning of \"between \\(x\\) and \\(y\\) \". Here, we assume this means from \\(x\\) to \\(y\\) . More careful students would set a variable start to the smaller of \\(x\\) and \\(y\\) , and end to be the larger of \\(x\\) and \\(y\\) . Then scan through from start to end instead. The rest of the logic follows below. Solution A: The idea here is we want to scan through the numbers from \\(x\\) to \\(y\\) , inclusive, and print out that number if it is a multiple of three. Let's first think about the questions to build a loop. Q: What is it we want to do repeatedly? A: We want to print a number \\(n\\) if it is a multiple of three. Q: What is the initial state? A: The number \\(n\\) is \\(x\\) Q: When do we stop? A: The number \\(n\\) is more than \\(y\\) Q: What do we update in each loop? A: Increment \\(n\\) by 1 We can now translate this into a for loop 1 2 3 4 5 6 7 void print_threes ( long x , long y ) { for ( long n = x ; n <= y ; n += 1 ) { if ( n % 3 == 0 ) { cs1010_println_long ( n ); } } } or a while loop: 1 2 3 4 5 6 7 8 9 void print_threes ( long x , long y ) { long n = x ; while ( n <= y ) { if ( n % 3 == 0 ) { cs1010_println_long ( n ); } n += 1 ; } } We can even do this with a do-while loop. If there is always at least one number to check, we will always enter the loop at least once. 1 2 3 4 5 6 7 8 9 10 void print_threes ( long x , long y ) { long n = x ; do { if ( n % 3 == 0 ) { cs1010_println_long ( n ); } n += 1 ; } while ( n <= y ); } Solution B: This is not the only solution. Let's look at another. Suppose we answer the questions differently: Q: What is it we want to do repeatedly? A: We want to print a number \\(n\\) Q: What is the initial state? A: The number \\(n\\) is the smallest multiple of three bigger or equals to \\(x\\) Q: When do we stop? A: The number \\(n\\) is more than \\(y\\) Q: What do we update in each loop? A: Increment \\(n\\) by 3 Then we can end up with very different code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 long next_mulitple_of_three ( long x ) { if ( x % 3 == 0 ) { return x ; } if ( x > 0 ) { return x + ( 3 - ( x % 3 )); } return x + ( - x % 3 ); } void print_threes ( long x , long y ) { x = next_mulitple_of_three ( x ); for ( long n = x ; n <= y ; n += 3 ) { cs1010_println_long ( n ); } } Question 2: Factor Given a number \\(n\\) , we want to find out how many factors \\(n\\) has, excluding the trivial factor 1 and \\(n\\) . Write a program factor that reads, from the standard input, a positive integer \\(n\\) , and prints, to the standard output, the factors of \\(n\\) between 2 and \\(n-1\\) , inclusive. Guide to Question 2: The idea here is we want to scan through the numbers from \\(2\\) to \\(n-1\\) , inclusive, and count how many factors are there. It should be clear that we need to introduce a new variable to keep track of the number of factors. Let's call this variable num_of_factors . Q: What is it we want to do repeatedly? A: We want to increment num_of_factors if the current number \\(i\\) is a factor of \\(n\\) . Q: What is the initial state? A: \\(i\\) is 2 and num_of_factors is 0. Q: When do we stop? A: When \\(i\\) is bigger than \\(n-1\\) . Q: What do we update in each loop? A: Increment \\(i\\) by 1. We can now translate this into a for loop 1 2 3 4 5 6 7 8 9 long count_factors ( long n ) { long num_of_factors = 0 ; for ( long i = 2 ; i <= n - 1 ; n += 1 ) { if ( n % i == 0 ) { num_of_factors += 1 ; } } return num_of_factors ; } or a while loop: 1 2 3 4 5 6 7 8 9 10 11 long count_factors ( long n ) { long i = 2 ; long num_of_factors = 0 ; while ( i <= n - 1 ) { if ( n % i == 0 ) { num_of_factors += 1 ; } i += 1 ; } return num_of_factors ; } We can also do this with a do-while loop, but since a do-while loop loops at least once, we need to make sure to handle the special case where there is nothing to loop through (i.e., when \\(n\\) is 2). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 long count_factors ( long n ) { if ( n == 2 ) { return 0 ; } long i = 2 ; long num_of_factors = 0 ; do { if ( n % i == 0 ) { num_of_factors += 1 ; } i += 1 ; } while ( i <= n - 1 ); return num_of_factors ; } An observant student might observe that 3 is prime and so when \\(n\\) is 3, there are no factors either. So we could equivalently say: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 long count_factors ( long n ) { if ( n <= 3 ) { return 0 ; } long i = 2 ; long num_of_factors = 0 ; do { if ( n % i == 0 ) { num_of_factors += 1 ; } i += 1 ; } while ( i <= n - 1 ); return num_of_factors ; } Question 3: Parity Write a program parity , that reads from standard input a positive integer \\(n\\) print, to the standard output, 2 lines, 1 2 odd: X even: Y where X represents the number of odd digits and Y represents the number of even digits. Guide to Question 3 Here, we need to loop through every digit in \\(n\\) . Just like your other exercises, you can use % 10 to retrieve the last digit and / 10 to retrieve the remaining digits. It should also be clear that you need two additional variables, to keep track of the number of odd digits and even digits. Q: What is it we want to do repeatedly? A: We want to check the last digit. Increment the odd counter if it is odd; the even counter if it is even. Q: What is the initial state? A: Both counters are set to 0. Q: When do we stop? A: When there is no more digit. Q: What do we update in each loop? A: We remove the last digit from \\(n\\) . Since the initialization involves multiple statements, it is more natural to do it with a while loop. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void print_odd_even ( long n ) { long num_evens = 0 ; long num_odds = 0 ; while ( n != 0 ) { if (( n % 10 ) % 2 == 0 ) { num_evens += 1 ; } else { num_odds += 1 ; } n /= 10 ; } cs1010_print_string ( \"odd: \" ); cs1010_println_long ( num_odds ); cs1010_print_string ( \"even: \" ); cs1010_println_long ( num_evens ); } You may notice that, since \\(n\\) is positive and is guaranteed to have at least one digit, we are guaranteed to enter the loop at least once. So, we can also do this with a do-while loop. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void print_odd_even ( long n ) { long num_evens = 0 ; long num_odds = 0 ; do { if (( n % 10 ) % 2 == 0 ) { num_evens += 1 ; } else { num_odds += 1 ; } n /= 10 ; } while ( n != 0 ); cs1010_print_string ( \"odd: \" ); cs1010_println_long ( num_odds ); cs1010_print_string ( \"even: \" ); cs1010_println_long ( num_evens ); } Food for thought: if we allow 0 as a valid input, which version is correct? Question 4: Nine Write a program that looks for the least significant occurrence of digit 9 in a given number. Your program, nine , should read a positive number from the standard input and print out the position of the least significant occurrence of 9. The rightmost digit has the position of 1, the second last has the position of 2, etc. If the number 9 does not appear in the given number, print 0. Guide to Question 4 This question has a slightly more complex stopping condition. The idea is that we wish to scan through the digits, looking for a 9. We need to keep track of the position, so we need an additional variable position . Q: What is it we want to do repeatedly? A: We want to check the last digit if it is a 9 . Q: What is the initial state? A: position is set to 1. Q: When do we stop? A: When there is no more digit or when we find a 9 . Q: What do we update in each loop? A: We increment position by 1, and remove one digit from the number. Method A The first method requires us to keep a boolean variable to keep track of whether we have found a 9. We need to augment the initialization so that we also set this variable (let's call it found9 ) to false . Q: What is the initial state? A: position is set to 0, found9 is set to false Here is the while version: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 long find_last_significant_9 ( long n ) { long position = 1 ; bool found9 = false ; while ( n != 0 && ! found9 ) { if ( n % 10 == 9 ) { found9 = true ; } position += 1 ; n /= 10 ; } if ( ! found9 ) { return 0 ; } return position - 1 ; } What we do after we exit the loop is a bit tricky. On Line 11, we can assert that { found9 == true || n == 0 } (applying De Morgan's Law to the loop condition). So, either one of this is true: found9 is true , or found9 is false and n == 0 . We have to handle the two cases separately. If found9 is false, then we need to return 0 as per the requirement. If found9 is true, then we need to remove one less than the position (since we increment it on Line 8 after we found a 9. Method B The second method is simpler. Take a look: 1 2 3 4 5 6 7 8 9 10 11 long find_last_significant_9 ( long n ) { long position = 1 ; while ( n != 0 ) { if ( n % 10 == 9 ) { return position ; } position += 1 ; n /= 10 ; } return 0 ; } As soon as we found a 9, we can return from the function on Line 5. If we exit from the while loop without returning, then we are guaranteed that we have not found a 9. Note that the assertion immediately after the while loop is { n == 0 }, which is much simpler. So, we can simply return 0 on Line 10. Question 5: HDB ASCII Art refers to the art of drawing with only common letters, numbers, and symbols on our keyboard. My daughter has discovered that, if we draw rows of # symbols together, it approximately looks like an HDB flat! Write a program hdb that takes in two positive integers \\(w\\) and \\(h\\) , and draw \\(h\\) rows of # symbols, each row containing \\(w\\) # , with no spaces before, in between, and after. Guide to Question 5 This question requires two loops: one to draw each individual floor, the other to draw the whole block. The loop itself, however, is simple. I think we can skip answering the four loop questions for this problem: Solution A 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void print_floor ( long w ) { long i ; for ( i = 0 ; i < w - 1 ; i += 1 ) { cs1010_print_string ( \"#\" ); } cs1010_println_string ( \"#\" ); } void print_hdb ( long w , long h ) { long i ; for ( i = 0 ; i < h ; i += 1 ) { print_floor ( w ); } } Solution B Some students have asked about nested loops. You can solve this problem with one loop nested within another. We have not shown you this in class before, but it is not more complicated than nesting a conditional within a loop. A nested loop is more prone to bugs since we need to keep track of two loop variables in the same scope and we are doing two things within the same function. It is easier to get mixed up. See if you can catch what is wrong with the code below: 1 2 3 4 5 6 7 8 9 10 // Incorrect void print_hdb ( long w , long h ) { long i ; for ( i = 0 ; i < h ; i += 1 ) { for ( i = 0 ; i < w - 1 ; i += 1 ) { cs1010_print_string ( \"#\" ); } cs1010_println_string ( \"#\" ); } } 1 2 3 4 5 6 7 8 9 10 11 // Incorrect void print_hdb ( long w , long h ) { // buggy long i ; long j ; for ( i = 0 ; i < h ; i += 1 ) { for ( j = 0 ; j < w - 1 ; j += 1 ) { cs1010_print_string ( \"#\" ); } } cs1010_println_string ( \"#\" ); }","title":"Exercise 3: Three, Factor, Parity, Nine, HDB"},{"location":"ex03-comments.html#exercise-3-three-factor-parity-nine-hdb","text":"","title":"Exercise 3: Three, Factor, Parity, Nine, HDB"},{"location":"ex03-comments.html#guide","text":"","title":"Guide"},{"location":"ex03-comments.html#question-1-three","text":"Write a program called three that reads in two integers \\(x\\) and \\(y\\) from the standard input, and prints to the standard outputs, all multiples of three between \\(x\\) and \\(y\\) (inclusive).","title":"Question 1: Three"},{"location":"ex03-comments.html#guide-to-question-1","text":"The question is not very clear about the meaning of \"between \\(x\\) and \\(y\\) \". Here, we assume this means from \\(x\\) to \\(y\\) . More careful students would set a variable start to the smaller of \\(x\\) and \\(y\\) , and end to be the larger of \\(x\\) and \\(y\\) . Then scan through from start to end instead. The rest of the logic follows below.","title":"Guide to Question 1:"},{"location":"ex03-comments.html#solution-a","text":"The idea here is we want to scan through the numbers from \\(x\\) to \\(y\\) , inclusive, and print out that number if it is a multiple of three. Let's first think about the questions to build a loop. Q: What is it we want to do repeatedly? A: We want to print a number \\(n\\) if it is a multiple of three. Q: What is the initial state? A: The number \\(n\\) is \\(x\\) Q: When do we stop? A: The number \\(n\\) is more than \\(y\\) Q: What do we update in each loop? A: Increment \\(n\\) by 1 We can now translate this into a for loop 1 2 3 4 5 6 7 void print_threes ( long x , long y ) { for ( long n = x ; n <= y ; n += 1 ) { if ( n % 3 == 0 ) { cs1010_println_long ( n ); } } } or a while loop: 1 2 3 4 5 6 7 8 9 void print_threes ( long x , long y ) { long n = x ; while ( n <= y ) { if ( n % 3 == 0 ) { cs1010_println_long ( n ); } n += 1 ; } } We can even do this with a do-while loop. If there is always at least one number to check, we will always enter the loop at least once. 1 2 3 4 5 6 7 8 9 10 void print_threes ( long x , long y ) { long n = x ; do { if ( n % 3 == 0 ) { cs1010_println_long ( n ); } n += 1 ; } while ( n <= y ); }","title":"Solution A:"},{"location":"ex03-comments.html#solution-b","text":"This is not the only solution. Let's look at another. Suppose we answer the questions differently: Q: What is it we want to do repeatedly? A: We want to print a number \\(n\\) Q: What is the initial state? A: The number \\(n\\) is the smallest multiple of three bigger or equals to \\(x\\) Q: When do we stop? A: The number \\(n\\) is more than \\(y\\) Q: What do we update in each loop? A: Increment \\(n\\) by 3 Then we can end up with very different code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 long next_mulitple_of_three ( long x ) { if ( x % 3 == 0 ) { return x ; } if ( x > 0 ) { return x + ( 3 - ( x % 3 )); } return x + ( - x % 3 ); } void print_threes ( long x , long y ) { x = next_mulitple_of_three ( x ); for ( long n = x ; n <= y ; n += 3 ) { cs1010_println_long ( n ); } }","title":"Solution B:"},{"location":"ex03-comments.html#question-2-factor","text":"Given a number \\(n\\) , we want to find out how many factors \\(n\\) has, excluding the trivial factor 1 and \\(n\\) . Write a program factor that reads, from the standard input, a positive integer \\(n\\) , and prints, to the standard output, the factors of \\(n\\) between 2 and \\(n-1\\) , inclusive.","title":"Question 2: Factor"},{"location":"ex03-comments.html#guide-to-question-2","text":"The idea here is we want to scan through the numbers from \\(2\\) to \\(n-1\\) , inclusive, and count how many factors are there. It should be clear that we need to introduce a new variable to keep track of the number of factors. Let's call this variable num_of_factors . Q: What is it we want to do repeatedly? A: We want to increment num_of_factors if the current number \\(i\\) is a factor of \\(n\\) . Q: What is the initial state? A: \\(i\\) is 2 and num_of_factors is 0. Q: When do we stop? A: When \\(i\\) is bigger than \\(n-1\\) . Q: What do we update in each loop? A: Increment \\(i\\) by 1. We can now translate this into a for loop 1 2 3 4 5 6 7 8 9 long count_factors ( long n ) { long num_of_factors = 0 ; for ( long i = 2 ; i <= n - 1 ; n += 1 ) { if ( n % i == 0 ) { num_of_factors += 1 ; } } return num_of_factors ; } or a while loop: 1 2 3 4 5 6 7 8 9 10 11 long count_factors ( long n ) { long i = 2 ; long num_of_factors = 0 ; while ( i <= n - 1 ) { if ( n % i == 0 ) { num_of_factors += 1 ; } i += 1 ; } return num_of_factors ; } We can also do this with a do-while loop, but since a do-while loop loops at least once, we need to make sure to handle the special case where there is nothing to loop through (i.e., when \\(n\\) is 2). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 long count_factors ( long n ) { if ( n == 2 ) { return 0 ; } long i = 2 ; long num_of_factors = 0 ; do { if ( n % i == 0 ) { num_of_factors += 1 ; } i += 1 ; } while ( i <= n - 1 ); return num_of_factors ; } An observant student might observe that 3 is prime and so when \\(n\\) is 3, there are no factors either. So we could equivalently say: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 long count_factors ( long n ) { if ( n <= 3 ) { return 0 ; } long i = 2 ; long num_of_factors = 0 ; do { if ( n % i == 0 ) { num_of_factors += 1 ; } i += 1 ; } while ( i <= n - 1 ); return num_of_factors ; }","title":"Guide to Question 2:"},{"location":"ex03-comments.html#question-3-parity","text":"Write a program parity , that reads from standard input a positive integer \\(n\\) print, to the standard output, 2 lines, 1 2 odd: X even: Y where X represents the number of odd digits and Y represents the number of even digits.","title":"Question 3: Parity"},{"location":"ex03-comments.html#guide-to-question-3","text":"Here, we need to loop through every digit in \\(n\\) . Just like your other exercises, you can use % 10 to retrieve the last digit and / 10 to retrieve the remaining digits. It should also be clear that you need two additional variables, to keep track of the number of odd digits and even digits. Q: What is it we want to do repeatedly? A: We want to check the last digit. Increment the odd counter if it is odd; the even counter if it is even. Q: What is the initial state? A: Both counters are set to 0. Q: When do we stop? A: When there is no more digit. Q: What do we update in each loop? A: We remove the last digit from \\(n\\) . Since the initialization involves multiple statements, it is more natural to do it with a while loop. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void print_odd_even ( long n ) { long num_evens = 0 ; long num_odds = 0 ; while ( n != 0 ) { if (( n % 10 ) % 2 == 0 ) { num_evens += 1 ; } else { num_odds += 1 ; } n /= 10 ; } cs1010_print_string ( \"odd: \" ); cs1010_println_long ( num_odds ); cs1010_print_string ( \"even: \" ); cs1010_println_long ( num_evens ); } You may notice that, since \\(n\\) is positive and is guaranteed to have at least one digit, we are guaranteed to enter the loop at least once. So, we can also do this with a do-while loop. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void print_odd_even ( long n ) { long num_evens = 0 ; long num_odds = 0 ; do { if (( n % 10 ) % 2 == 0 ) { num_evens += 1 ; } else { num_odds += 1 ; } n /= 10 ; } while ( n != 0 ); cs1010_print_string ( \"odd: \" ); cs1010_println_long ( num_odds ); cs1010_print_string ( \"even: \" ); cs1010_println_long ( num_evens ); } Food for thought: if we allow 0 as a valid input, which version is correct?","title":"Guide to Question 3"},{"location":"ex03-comments.html#question-4-nine","text":"Write a program that looks for the least significant occurrence of digit 9 in a given number. Your program, nine , should read a positive number from the standard input and print out the position of the least significant occurrence of 9. The rightmost digit has the position of 1, the second last has the position of 2, etc. If the number 9 does not appear in the given number, print 0.","title":"Question 4: Nine"},{"location":"ex03-comments.html#guide-to-question-4","text":"This question has a slightly more complex stopping condition. The idea is that we wish to scan through the digits, looking for a 9. We need to keep track of the position, so we need an additional variable position . Q: What is it we want to do repeatedly? A: We want to check the last digit if it is a 9 . Q: What is the initial state? A: position is set to 1. Q: When do we stop? A: When there is no more digit or when we find a 9 . Q: What do we update in each loop? A: We increment position by 1, and remove one digit from the number.","title":"Guide to Question 4"},{"location":"ex03-comments.html#method-a","text":"The first method requires us to keep a boolean variable to keep track of whether we have found a 9. We need to augment the initialization so that we also set this variable (let's call it found9 ) to false . Q: What is the initial state? A: position is set to 0, found9 is set to false Here is the while version: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 long find_last_significant_9 ( long n ) { long position = 1 ; bool found9 = false ; while ( n != 0 && ! found9 ) { if ( n % 10 == 9 ) { found9 = true ; } position += 1 ; n /= 10 ; } if ( ! found9 ) { return 0 ; } return position - 1 ; } What we do after we exit the loop is a bit tricky. On Line 11, we can assert that { found9 == true || n == 0 } (applying De Morgan's Law to the loop condition). So, either one of this is true: found9 is true , or found9 is false and n == 0 . We have to handle the two cases separately. If found9 is false, then we need to return 0 as per the requirement. If found9 is true, then we need to remove one less than the position (since we increment it on Line 8 after we found a 9.","title":"Method A"},{"location":"ex03-comments.html#method-b","text":"The second method is simpler. Take a look: 1 2 3 4 5 6 7 8 9 10 11 long find_last_significant_9 ( long n ) { long position = 1 ; while ( n != 0 ) { if ( n % 10 == 9 ) { return position ; } position += 1 ; n /= 10 ; } return 0 ; } As soon as we found a 9, we can return from the function on Line 5. If we exit from the while loop without returning, then we are guaranteed that we have not found a 9. Note that the assertion immediately after the while loop is { n == 0 }, which is much simpler. So, we can simply return 0 on Line 10.","title":"Method B"},{"location":"ex03-comments.html#question-5-hdb","text":"ASCII Art refers to the art of drawing with only common letters, numbers, and symbols on our keyboard. My daughter has discovered that, if we draw rows of # symbols together, it approximately looks like an HDB flat! Write a program hdb that takes in two positive integers \\(w\\) and \\(h\\) , and draw \\(h\\) rows of # symbols, each row containing \\(w\\) # , with no spaces before, in between, and after.","title":"Question 5: HDB"},{"location":"ex03-comments.html#guide-to-question-5","text":"This question requires two loops: one to draw each individual floor, the other to draw the whole block. The loop itself, however, is simple. I think we can skip answering the four loop questions for this problem:","title":"Guide to Question 5"},{"location":"ex03-comments.html#solution-a_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 void print_floor ( long w ) { long i ; for ( i = 0 ; i < w - 1 ; i += 1 ) { cs1010_print_string ( \"#\" ); } cs1010_println_string ( \"#\" ); } void print_hdb ( long w , long h ) { long i ; for ( i = 0 ; i < h ; i += 1 ) { print_floor ( w ); } }","title":"Solution A"},{"location":"ex03-comments.html#solution-b_1","text":"Some students have asked about nested loops. You can solve this problem with one loop nested within another. We have not shown you this in class before, but it is not more complicated than nesting a conditional within a loop. A nested loop is more prone to bugs since we need to keep track of two loop variables in the same scope and we are doing two things within the same function. It is easier to get mixed up. See if you can catch what is wrong with the code below: 1 2 3 4 5 6 7 8 9 10 // Incorrect void print_hdb ( long w , long h ) { long i ; for ( i = 0 ; i < h ; i += 1 ) { for ( i = 0 ; i < w - 1 ; i += 1 ) { cs1010_print_string ( \"#\" ); } cs1010_println_string ( \"#\" ); } } 1 2 3 4 5 6 7 8 9 10 11 // Incorrect void print_hdb ( long w , long h ) { // buggy long i ; long j ; for ( i = 0 ; i < h ; i += 1 ) { for ( j = 0 ; j < w - 1 ; j += 1 ) { cs1010_print_string ( \"#\" ); } } cs1010_println_string ( \"#\" ); }","title":"Solution B"},{"location":"ex03.html","text":"Exercise 3: Three, Factor, Parity, Nine, HDB Deadline This is an ungraded exercise designed to expose you to different patterns of using loops. There is no deadline, but we encourage you to complete it before Thursday's lab so that you do not fall behind. Prerequisite You can access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You are familiar with basic C syntax and arithmetic operations and have completed at least 2 of 4 questions from Exercise 2 . Learning Outcomes Be comfortable writing simple C programs that involve loops, including loops with conditional body loops with conditional body and counting loops with early return nested loops loops that step through digits in a number Accepting and Retrieving Assignments Click on this link to accept the exercise. Log in to one of the hosts of CS1010 programming environment (PE) Run the following on the command line on one of the PE hosts: 1 ~cs1010/get-ex03 You should see a new subdirectory ex03-<username> in your current working directory, where username is your GitHub username. We will call this directory your exercise directory or assignment directory . Inside that directory, you should see a bunch of files: three.c , factor.c , parity.c , nine.c and hdb.c are the most important files. They are the skeleton C code that you should edit to solve the exercise. inputs and outputs are subdirectories that contain test inputs and test outputs. Makefile : The configuration for the tool make that we use to automate the compilation and testing of the programs. You do not have to understand how to write a Makefile for CS1010. If you are interested to learn how to write a Makefile , talk to either Wei Tsang or Google. test.sh : A bash script for testing your code. You do not have to edit this file. If you are interested to learn how to write bash script, talk to either Wei Tsang or Google. compiler_flags.txt and .clang-tidy are two files used to configure clang and clang-tidy respectively. You do not need to edit this. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Alita (Group A10) Solving The Assignments Edit the files three.c , factor.c , parity.c , nine.c , and hdb.c to solve the corresponding question as described below. To compile and run the given tests with the sample inputs and outputs, run on the command line, 1 make This command will compile the C files. If there is no compilation error, it will run the test scripts. make is smart enough that if you did not change the C file, it will not recompile the files. You can read more about how you can become a power user of make in CS1010 . This list of common clang warnings and error messages might be helpful. Clean Compilation This is a reminder that, for your lab assignments and practical exams, any submission that cannot compile will receive 0. Further, each compilation warning will lead to a -1 mark deduction. So, please make it a habit to ensure that you can compile cleanly, starting with ungraded exercises. Examining Individual Input/Output Files If your code prints the wrong output for some of the test inputs, familiarity with UNIX CLI would be helpful. Suppose that your code for problem echo fails on test case 3. To see the input of this test case, run: 1 cat inputs/echo.3.in To see the expected output: 1 cat outputs/echo.3.out To see what output your program gives, 1 ./echo < inputs/echo.3.in To test the program for a particular question (say, echo ), instead of all programs, 1 ./test.sh echo Submission When you are ready, run the following command while you are in the exercise directory: 1 ~cs1010/submit-ex03 The files three.c , factor.c , parity.c , nine.c and hdb.c will be uploaded to GitHub. You can submit multiple times. You are not allowed to interact with your CS1010 GitHub repositories using git commands or edit your files directly on GitHub's website. Doing so would interfere with the automation that we use for grading and would result in penalties (for graded assignments). Grading This exercise is not graded. Question 1: Three Write a program called three that reads in two integers \\(x\\) and \\(y\\) from the standard input, and prints to the standard outputs, all multiple of threes between \\(x\\) and \\(y\\) (inclusive). Sample Runs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ooiwt@pe112:~/ex03-ooiwt$ ./three 1 10 3 6 9 ooiwt@pe112:~/ex03-ooiwt$ ./three 4 5 ooiwt@pe112:~/ex03-ooiwt$ ./three 3 24 3 6 9 12 15 18 21 24 Question 2: Factor Given a number \\(n\\) , we want to find out how many factors \\(n\\) has, excluding the trivial factor 1 and \\(n\\) . Write a program factor that reads, from the standard input, a positive integer \\(n\\) , and prints, to the standard output, the factors of \\(n\\) between 2 and \\(n-1\\) , inclusive). Sample Runs 1 2 3 4 5 6 7 8 9 ooiwt@pe112:~/ex03-ooiwt$ ./factor 48 8 ooiwt@pe112:~/ex03-ooiwt$ ./factor 49 1 ooiwt@pe112:~/ex03-ooiwt$ ./factor 1 0 Question 3: Parity Write a program parity , that reads from standard input a positive integer \\(n\\) print, to the standard output, 2 lines, 1 2 odd: X even: Y where X represents the number of odd digits and Y represents the number of even digits. Note that there is exactly one space between the colon : and X or Y and there are no trailing spaces. You may create any function if you need to. The purpose of this question is for you to practice using loops. Hence, try to solve it without using any form of recursion for this question. Sample Runs 1 2 3 4 5 6 7 8 albertsutz@pe119:~/ex03-albertsutz$ ./parity 123456 odd: 3 even: 3 albertsutz@pe119:~/ex03-albertsutz$ ./parity 111333 odd: 6 even: 0 Question Credit: Albert Sutiono (cohort 20/21) Question 4: Nine Write a program that looks for the least significant occurrence of digit 9 in a given number. Your program, nine , should read a positive number from the standard input and print out the position of the least significant occurrence of 9. The rightmost digit has the position of 1, the second last has the position of 2, etc. If the number 9 does not appear in the given number, print 0. Sample Runs 1 2 3 4 5 6 7 8 9 ooiwt@pe119:~/ex03-ooiwt$ ./nine 900 3 ooiwt@pe119:~/ex03-ooiwt$ ./nine 9999999 1 ooiwt@pe119:~/ex03-ooiwt$ ./nine 123456780 0 Question 5: HDB ASCII Art refers to the art of drawing with only common letters, numbers, and symbols on our keyboard. My daughter has discovered that, if we draw rows of # symbols together, it approximately looks like an HDB flat! Write a program hdb that takes in two positive integers \\(w\\) and \\(h\\) , and draw \\(h\\) rows of # symbols, each row containing \\(w\\) # , with no spaces before, in between, and after. Sample Runs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 ooiwt@pe119:~/2122s1/ex03-ooiwt$ ./hdb 3 3 ### ### ### ooiwt@pe119:~/2122s1/ex03-ooiwt$ ./hdb 10 15 ########## ########## ########## ########## ########## ########## ########## ########## ########## ########## ########## ########## ########## ########## ########## ooiwt@pe119:~/2122s1/ex03-ooiwt$ ./hdb 24 10 ######################## ######################## ######################## ######################## ######################## ######################## ######################## ######################## ######################## ########################","title":"3. Three, Factor, Parity, Nine, HDB"},{"location":"ex03.html#exercise-3-three-factor-parity-nine-hdb","text":"","title":"Exercise 3: Three, Factor, Parity, Nine, HDB"},{"location":"ex03.html#deadline","text":"This is an ungraded exercise designed to expose you to different patterns of using loops. There is no deadline, but we encourage you to complete it before Thursday's lab so that you do not fall behind.","title":"Deadline"},{"location":"ex03.html#prerequisite","text":"You can access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You are familiar with basic C syntax and arithmetic operations and have completed at least 2 of 4 questions from Exercise 2 .","title":"Prerequisite"},{"location":"ex03.html#learning-outcomes","text":"Be comfortable writing simple C programs that involve loops, including loops with conditional body loops with conditional body and counting loops with early return nested loops loops that step through digits in a number","title":"Learning Outcomes"},{"location":"ex03.html#accepting-and-retrieving-assignments","text":"Click on this link to accept the exercise. Log in to one of the hosts of CS1010 programming environment (PE) Run the following on the command line on one of the PE hosts: 1 ~cs1010/get-ex03 You should see a new subdirectory ex03-<username> in your current working directory, where username is your GitHub username. We will call this directory your exercise directory or assignment directory . Inside that directory, you should see a bunch of files: three.c , factor.c , parity.c , nine.c and hdb.c are the most important files. They are the skeleton C code that you should edit to solve the exercise. inputs and outputs are subdirectories that contain test inputs and test outputs. Makefile : The configuration for the tool make that we use to automate the compilation and testing of the programs. You do not have to understand how to write a Makefile for CS1010. If you are interested to learn how to write a Makefile , talk to either Wei Tsang or Google. test.sh : A bash script for testing your code. You do not have to edit this file. If you are interested to learn how to write bash script, talk to either Wei Tsang or Google. compiler_flags.txt and .clang-tidy are two files used to configure clang and clang-tidy respectively. You do not need to edit this.","title":"Accepting and Retrieving Assignments"},{"location":"ex03.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Alita (Group A10)","title":"Identifying Yourself"},{"location":"ex03.html#solving-the-assignments","text":"Edit the files three.c , factor.c , parity.c , nine.c , and hdb.c to solve the corresponding question as described below. To compile and run the given tests with the sample inputs and outputs, run on the command line, 1 make This command will compile the C files. If there is no compilation error, it will run the test scripts. make is smart enough that if you did not change the C file, it will not recompile the files. You can read more about how you can become a power user of make in CS1010 . This list of common clang warnings and error messages might be helpful. Clean Compilation This is a reminder that, for your lab assignments and practical exams, any submission that cannot compile will receive 0. Further, each compilation warning will lead to a -1 mark deduction. So, please make it a habit to ensure that you can compile cleanly, starting with ungraded exercises.","title":"Solving The Assignments"},{"location":"ex03.html#examining-individual-inputoutput-files","text":"If your code prints the wrong output for some of the test inputs, familiarity with UNIX CLI would be helpful. Suppose that your code for problem echo fails on test case 3. To see the input of this test case, run: 1 cat inputs/echo.3.in To see the expected output: 1 cat outputs/echo.3.out To see what output your program gives, 1 ./echo < inputs/echo.3.in To test the program for a particular question (say, echo ), instead of all programs, 1 ./test.sh echo","title":"Examining Individual Input/Output Files"},{"location":"ex03.html#submission","text":"When you are ready, run the following command while you are in the exercise directory: 1 ~cs1010/submit-ex03 The files three.c , factor.c , parity.c , nine.c and hdb.c will be uploaded to GitHub. You can submit multiple times. You are not allowed to interact with your CS1010 GitHub repositories using git commands or edit your files directly on GitHub's website. Doing so would interfere with the automation that we use for grading and would result in penalties (for graded assignments).","title":"Submission"},{"location":"ex03.html#grading","text":"This exercise is not graded.","title":"Grading"},{"location":"ex03.html#question-1-three","text":"Write a program called three that reads in two integers \\(x\\) and \\(y\\) from the standard input, and prints to the standard outputs, all multiple of threes between \\(x\\) and \\(y\\) (inclusive).","title":"Question 1: Three"},{"location":"ex03.html#sample-runs","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ooiwt@pe112:~/ex03-ooiwt$ ./three 1 10 3 6 9 ooiwt@pe112:~/ex03-ooiwt$ ./three 4 5 ooiwt@pe112:~/ex03-ooiwt$ ./three 3 24 3 6 9 12 15 18 21 24","title":"Sample Runs"},{"location":"ex03.html#question-2-factor","text":"Given a number \\(n\\) , we want to find out how many factors \\(n\\) has, excluding the trivial factor 1 and \\(n\\) . Write a program factor that reads, from the standard input, a positive integer \\(n\\) , and prints, to the standard output, the factors of \\(n\\) between 2 and \\(n-1\\) , inclusive).","title":"Question 2: Factor"},{"location":"ex03.html#sample-runs_1","text":"1 2 3 4 5 6 7 8 9 ooiwt@pe112:~/ex03-ooiwt$ ./factor 48 8 ooiwt@pe112:~/ex03-ooiwt$ ./factor 49 1 ooiwt@pe112:~/ex03-ooiwt$ ./factor 1 0","title":"Sample Runs"},{"location":"ex03.html#question-3-parity","text":"Write a program parity , that reads from standard input a positive integer \\(n\\) print, to the standard output, 2 lines, 1 2 odd: X even: Y where X represents the number of odd digits and Y represents the number of even digits. Note that there is exactly one space between the colon : and X or Y and there are no trailing spaces. You may create any function if you need to. The purpose of this question is for you to practice using loops. Hence, try to solve it without using any form of recursion for this question.","title":"Question 3: Parity"},{"location":"ex03.html#sample-runs_2","text":"1 2 3 4 5 6 7 8 albertsutz@pe119:~/ex03-albertsutz$ ./parity 123456 odd: 3 even: 3 albertsutz@pe119:~/ex03-albertsutz$ ./parity 111333 odd: 6 even: 0 Question Credit: Albert Sutiono (cohort 20/21)","title":"Sample Runs"},{"location":"ex03.html#question-4-nine","text":"Write a program that looks for the least significant occurrence of digit 9 in a given number. Your program, nine , should read a positive number from the standard input and print out the position of the least significant occurrence of 9. The rightmost digit has the position of 1, the second last has the position of 2, etc. If the number 9 does not appear in the given number, print 0.","title":"Question 4: Nine"},{"location":"ex03.html#sample-runs_3","text":"1 2 3 4 5 6 7 8 9 ooiwt@pe119:~/ex03-ooiwt$ ./nine 900 3 ooiwt@pe119:~/ex03-ooiwt$ ./nine 9999999 1 ooiwt@pe119:~/ex03-ooiwt$ ./nine 123456780 0","title":"Sample Runs"},{"location":"ex03.html#question-5-hdb","text":"ASCII Art refers to the art of drawing with only common letters, numbers, and symbols on our keyboard. My daughter has discovered that, if we draw rows of # symbols together, it approximately looks like an HDB flat! Write a program hdb that takes in two positive integers \\(w\\) and \\(h\\) , and draw \\(h\\) rows of # symbols, each row containing \\(w\\) # , with no spaces before, in between, and after.","title":"Question 5: HDB"},{"location":"ex03.html#sample-runs_4","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 ooiwt@pe119:~/2122s1/ex03-ooiwt$ ./hdb 3 3 ### ### ### ooiwt@pe119:~/2122s1/ex03-ooiwt$ ./hdb 10 15 ########## ########## ########## ########## ########## ########## ########## ########## ########## ########## ########## ########## ########## ########## ########## ooiwt@pe119:~/2122s1/ex03-ooiwt$ ./hdb 24 10 ######################## ######################## ######################## ######################## ######################## ######################## ######################## ######################## ######################## ########################","title":"Sample Runs"},{"location":"ex04.html","text":"Exercise 4: Binary, Onigiri, Fibonacci Deadline This is an ungraded exercise. Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 0 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. You are comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, and conditional if / else statements. You are comfortable breaking down a problem into smaller sub-problems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function. Learning Objectives Be comfortable writing C programs that involve loops with while/for/do- while statements. Be able to write C programs that are neat and readable, adhering to a common prescribed coding convention. Setup First, accept the assignment on GitHub Then, log in to one of the hosts of CS1010 programming environment and run 1 ~cs1010/get-ex04 You should see the folder ex04-<github username> in your home directory with the assignment skeleton inside. Inside that directory, you should see the following files: binary.c , onigiri.c , and fibonacci.c , are the most important files. They are the skeleton C code that you should edit to solve the assignment and the only files that you should change. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 0 so you should already be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. compile_flags.txt : This file specifies the flags for compilation and is used by both make and clang-tidy . NEW Questions.md containing the description of the questions. This is a plain text file that you can view with vim , less , or other tools. Solving The Assignments Edit the files binary.c , onigiri.c , and fibonacci.c to solve the corresponding question as described below. To compile and run tests with the sample inputs and outputs: 1 make This command will compile all your C files with the appropriate settings and if there is no error, run the test scripts. If you pass the test cases, it will run clang-tidy to check if your code follows good code practices. The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. To compile individial program, type 1 make <program> For instance, the command 1 make echo compiles echo.c into echo without testing or running clang-tidy on it. To test individial program, run 1 ./test.sh <program> For instance, the command 1 ./test.sh echo tests echo without compiling or running clang-tidy on echo.c . Submission When you are ready, run the following command to submit: 1 ~cs1010/submit-ex04 The four files binary.c , onigiri.c , and fibonacci.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Manipulating Files on GitHub Do not manipulate (e.g., edit) the files on GitHub or close the pull requests on GitHub. Doing so would interfere with the scripts and the grading/testing process of CS1010. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Sasha Braus (Group G02) Questions To acclimatize you to the PE1 condition, the questions for this assignment is included in the skeleton instead, in a file named Questions.md . You should learn how to use vim to open both the .c file and the questions.md side-by-side (see https://nus-cs1010.github.io/2122-s1/vim.html#splitting-vims-viewport )","title":"4. Binary, Onigiri, Fibonacci"},{"location":"ex04.html#exercise-4-binary-onigiri-fibonacci","text":"","title":"Exercise 4: Binary, Onigiri, Fibonacci"},{"location":"ex04.html#deadline","text":"This is an ungraded exercise.","title":"Deadline"},{"location":"ex04.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 0 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. You are comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, and conditional if / else statements. You are comfortable breaking down a problem into smaller sub-problems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function.","title":"Prerequisite"},{"location":"ex04.html#learning-objectives","text":"Be comfortable writing C programs that involve loops with while/for/do- while statements. Be able to write C programs that are neat and readable, adhering to a common prescribed coding convention.","title":"Learning Objectives"},{"location":"ex04.html#setup","text":"First, accept the assignment on GitHub Then, log in to one of the hosts of CS1010 programming environment and run 1 ~cs1010/get-ex04 You should see the folder ex04-<github username> in your home directory with the assignment skeleton inside. Inside that directory, you should see the following files: binary.c , onigiri.c , and fibonacci.c , are the most important files. They are the skeleton C code that you should edit to solve the assignment and the only files that you should change. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 0 so you should already be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. compile_flags.txt : This file specifies the flags for compilation and is used by both make and clang-tidy . NEW Questions.md containing the description of the questions. This is a plain text file that you can view with vim , less , or other tools.","title":"Setup"},{"location":"ex04.html#solving-the-assignments","text":"Edit the files binary.c , onigiri.c , and fibonacci.c to solve the corresponding question as described below. To compile and run tests with the sample inputs and outputs: 1 make This command will compile all your C files with the appropriate settings and if there is no error, run the test scripts. If you pass the test cases, it will run clang-tidy to check if your code follows good code practices. The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. To compile individial program, type 1 make <program> For instance, the command 1 make echo compiles echo.c into echo without testing or running clang-tidy on it. To test individial program, run 1 ./test.sh <program> For instance, the command 1 ./test.sh echo tests echo without compiling or running clang-tidy on echo.c .","title":"Solving The Assignments"},{"location":"ex04.html#submission","text":"When you are ready, run the following command to submit: 1 ~cs1010/submit-ex04 The four files binary.c , onigiri.c , and fibonacci.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Manipulating Files on GitHub Do not manipulate (e.g., edit) the files on GitHub or close the pull requests on GitHub. Doing so would interfere with the scripts and the grading/testing process of CS1010.","title":"Submission"},{"location":"ex04.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Sasha Braus (Group G02)","title":"Identifying Yourself"},{"location":"ex04.html#questions","text":"To acclimatize you to the PE1 condition, the questions for this assignment is included in the skeleton instead, in a file named Questions.md . You should learn how to use vim to open both the .c file and the questions.md side-by-side (see https://nus-cs1010.github.io/2122-s1/vim.html#splitting-vims-viewport )","title":"Questions"},{"location":"ex05-comments.html","text":"Exercise 5: Counter, Dot, Unit Question 1: Counter Write a program called counter that reads in a non-negative integer and count how many times each digit appears in this number. Print each digit and the number of times it appears on a separate line, in ascending order of the digits. Digits that do not appear in the input number need not be printed. Guide Using a Loop One way to solve this is to count, for each digit, how many times it has appear in the given number. The function count_digit count how many times digit d appears in n . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void print_digit_count ( long digit , long count ) { if ( count != 0 ) { cs1010_print_long ( digit ); cs1010_print_string ( \": \" ); cs1010_println_long ( count ); } } long count_digit ( long n , long d ) { if ( n == 0 && d == 0 ) { return 1 ; } long counter = 0 ; while ( n != 0 ) { if ( n % 10 == d ) { counter += 1 ; } n = n / 10 ; } return counter ; } int main () { long n = cs1010_read_long (); for ( long digit = 0 ; digit < 10 ; digit += 1 ) { long counter = count_digit ( n , digit ); print_digit_count ( digit , counter ); } } Using an Array We can make the code more efficient. To scan through the input once and count each digit, we would need 10 counters. Instead of having variables counter0 , counter1 , counter2 , etc. We could use an array of 10 counters. Then, we only need to scan through the number once. 1 2 3 4 5 6 7 8 9 10 void count_digits ( long n , long counter [ 10 ]) { if ( n == 0 ) { counter [ 0 ] = 1 ; return ; } while ( n != 0 ) { counter [ n % 10 ] += 1 ; n = n / 10 ; } } The main function then looks like this: 1 2 3 4 5 6 7 8 9 10 11 int main () { long counter [ 10 ] = { 0 }; long n = cs1010_read_long (); count_digits ( n , counter ); for ( long digit = 0 ; digit < 10 ; digit += 1 ) { print_digit_count ( digit , counter [ digit ]); } } Question 2: Dot Write a program called dot that, given two 4-dimension vectors, find its dot product. Your program should read the two vectors from the standard inputs. Each vector is specified by four integers. Print, to the standard output, the dot product of the two vectors. Guide The code for dot product should be quite straightforward: 1 2 3 4 5 6 7 long dot_product ( long v1 [ 4 ], long v2 [ 4 ]) { long result = 0 ; for ( long i = 0 ; i < 4 ; i += 1 ) { result += ( v1 [ i ] * v2 [ i ]); } return result ; } The main is quite simple as well. The only new thing here is that you need to loop through the input to read the vectors. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main () { long v1 [ 4 ]; for ( long i = 0 ; i < 4 ; i += 1 ) { v1 [ i ] = cs1010_read_long (); } long v2 [ 4 ]; for ( long i = 0 ; i < 4 ; i += 1 ) { v2 [ i ] = cs1010_read_long (); } cs1010_println_long ( dot_product ( v1 , v2 )); } Question 3: Unit A unit vector is a vector with a length of 1. Write a program that, given a 3-dimensional vector, find the unit vector in the same direction. Your program should read a 3-D vector V from the standard inputs, specified by three integers. Print, to the standard output, the unit vector in the same direction of V. Print each element in the vector on a new line. Solve this problem by writing a function with the following header. 1 void find_unit_vector ( const long v [ 3 ], double unit [ 3 ]) { .. } Guide Note that v is the input vector since it is a vector of long and has qualifier const . We need to find the magnitude of this vector. The resulting unit vector can then be computed by dividing v with the magnitude. 1 2 3 4 5 6 7 void find_unit_vector ( const long v [ 3 ], double unit [ 3 ]) { double distance = sqrt (( v [ 0 ] * v [ 0 ]) + ( v [ 1 ] * v [ 1 ]) + ( v [ 2 ] * v [ 2 ])); for ( long i = 0 ; i < 3 ; i += 1 ) { unit [ i ] = v [ i ] / distance ; } }","title":"Ex05 comments"},{"location":"ex05-comments.html#exercise-5-counter-dot-unit","text":"","title":"Exercise 5: Counter, Dot, Unit"},{"location":"ex05-comments.html#question-1-counter","text":"Write a program called counter that reads in a non-negative integer and count how many times each digit appears in this number. Print each digit and the number of times it appears on a separate line, in ascending order of the digits. Digits that do not appear in the input number need not be printed.","title":"Question 1: Counter"},{"location":"ex05-comments.html#guide","text":"","title":"Guide"},{"location":"ex05-comments.html#using-a-loop","text":"One way to solve this is to count, for each digit, how many times it has appear in the given number. The function count_digit count how many times digit d appears in n . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 void print_digit_count ( long digit , long count ) { if ( count != 0 ) { cs1010_print_long ( digit ); cs1010_print_string ( \": \" ); cs1010_println_long ( count ); } } long count_digit ( long n , long d ) { if ( n == 0 && d == 0 ) { return 1 ; } long counter = 0 ; while ( n != 0 ) { if ( n % 10 == d ) { counter += 1 ; } n = n / 10 ; } return counter ; } int main () { long n = cs1010_read_long (); for ( long digit = 0 ; digit < 10 ; digit += 1 ) { long counter = count_digit ( n , digit ); print_digit_count ( digit , counter ); } }","title":"Using a Loop"},{"location":"ex05-comments.html#using-an-array","text":"We can make the code more efficient. To scan through the input once and count each digit, we would need 10 counters. Instead of having variables counter0 , counter1 , counter2 , etc. We could use an array of 10 counters. Then, we only need to scan through the number once. 1 2 3 4 5 6 7 8 9 10 void count_digits ( long n , long counter [ 10 ]) { if ( n == 0 ) { counter [ 0 ] = 1 ; return ; } while ( n != 0 ) { counter [ n % 10 ] += 1 ; n = n / 10 ; } } The main function then looks like this: 1 2 3 4 5 6 7 8 9 10 11 int main () { long counter [ 10 ] = { 0 }; long n = cs1010_read_long (); count_digits ( n , counter ); for ( long digit = 0 ; digit < 10 ; digit += 1 ) { print_digit_count ( digit , counter [ digit ]); } }","title":"Using an Array"},{"location":"ex05-comments.html#question-2-dot","text":"Write a program called dot that, given two 4-dimension vectors, find its dot product. Your program should read the two vectors from the standard inputs. Each vector is specified by four integers. Print, to the standard output, the dot product of the two vectors.","title":"Question 2: Dot"},{"location":"ex05-comments.html#guide_1","text":"The code for dot product should be quite straightforward: 1 2 3 4 5 6 7 long dot_product ( long v1 [ 4 ], long v2 [ 4 ]) { long result = 0 ; for ( long i = 0 ; i < 4 ; i += 1 ) { result += ( v1 [ i ] * v2 [ i ]); } return result ; } The main is quite simple as well. The only new thing here is that you need to loop through the input to read the vectors. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int main () { long v1 [ 4 ]; for ( long i = 0 ; i < 4 ; i += 1 ) { v1 [ i ] = cs1010_read_long (); } long v2 [ 4 ]; for ( long i = 0 ; i < 4 ; i += 1 ) { v2 [ i ] = cs1010_read_long (); } cs1010_println_long ( dot_product ( v1 , v2 )); }","title":"Guide"},{"location":"ex05-comments.html#question-3-unit","text":"A unit vector is a vector with a length of 1. Write a program that, given a 3-dimensional vector, find the unit vector in the same direction. Your program should read a 3-D vector V from the standard inputs, specified by three integers. Print, to the standard output, the unit vector in the same direction of V. Print each element in the vector on a new line. Solve this problem by writing a function with the following header. 1 void find_unit_vector ( const long v [ 3 ], double unit [ 3 ]) { .. }","title":"Question 3: Unit"},{"location":"ex05-comments.html#guide_2","text":"Note that v is the input vector since it is a vector of long and has qualifier const . We need to find the magnitude of this vector. The resulting unit vector can then be computed by dividing v with the magnitude. 1 2 3 4 5 6 7 void find_unit_vector ( const long v [ 3 ], double unit [ 3 ]) { double distance = sqrt (( v [ 0 ] * v [ 0 ]) + ( v [ 1 ] * v [ 1 ]) + ( v [ 2 ] * v [ 2 ])); for ( long i = 0 ; i < 3 ; i += 1 ) { unit [ i ] = v [ i ] / distance ; } }","title":"Guide"},{"location":"ex05.html","text":"Exercise 5: Counter, Dot, Unit Deadline This is an ungraded exercise. Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 0 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. You are comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, conditional if / else statements and loops. You are comfortable breaking down a problem into smaller sub-problems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function. Learning Objectives Be comfortable writing C programs that involve fixed-length arrays. Be able to write C programs that are neat and readable, adhering to a common prescribed coding convention. Setup First, accept the assignment on GitHub Then, log in to one of the hosts of CS1010 programming environment and run 1 ~cs1010/get-ex05 You should see the folder ex05-<github username> in your home directory with the assignment skeleton inside. Inside that directory, you should see the following files: counter.c , dot.c , and unit.c , are the most important files. They are the skeleton C code that you should edit to solve the assignment and the only files that you should change. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 0 so you should already be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. NEW memcheck.sh : This is a bash script for check your code against memory errors. compile_flags.txt : This file specifies the flags for compilation and is used by both make and clang-tidy . NEW Questions.md containing the description of the questions. This is a plain text file that you can view with vim , less , or other tools. Solving The Assignments Edit the files counter.c , dot.c , and unit.c to solve the corresponding question as described below. To compile and run tests with the sample inputs and outputs: 1 make This command will compile all your C files with the appropriate settings and if there is no error, run the test scripts. If you pass the test cases, it will run clang-tidy to check if your code follows good code practices. The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. To compile individual program, type 1 make <program> For instance, the command 1 make echo compiles echo.c into echo without testing or running clang-tidy on it. To test individual program, run 1 ./test.sh <program> For instance, the command 1 ./test.sh echo tests echo without compiling or running clang-tidy on echo.c . NEW To check for memory errors while running your code, run 1 ./memcheck.sh <program> You can also run make memcheck to run memcheck.sh on all of your programs at once. Note that this step is not included in make by default since it is slow. Submission When you are ready, run the following command to submit: 1 ~cs1010/submit-ex05 The .c files will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Manipulating Files on GitHub Do not manipulate (e.g., edit) the files on GitHub or close the pull requests on GitHub. Doing so would interfere with the scripts and the grading/testing process of CS1010. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Shang Chi (Group G02) Questions To acclimatize you to the PE1 condition, the questions for this assignment is included in the skeleton instead, in a file named Questions.md . You should learn how to use vim to open both the .c file and the questions.md side-by-side (see https://nus-cs1010.github.io/2122-s1/vim.html#splitting-vims-viewport )","title":"5. Counter, Dot, Unit"},{"location":"ex05.html#exercise-5-counter-dot-unit","text":"","title":"Exercise 5: Counter, Dot, Unit"},{"location":"ex05.html#deadline","text":"This is an ungraded exercise.","title":"Deadline"},{"location":"ex05.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 0 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. You are comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, conditional if / else statements and loops. You are comfortable breaking down a problem into smaller sub-problems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function.","title":"Prerequisite"},{"location":"ex05.html#learning-objectives","text":"Be comfortable writing C programs that involve fixed-length arrays. Be able to write C programs that are neat and readable, adhering to a common prescribed coding convention.","title":"Learning Objectives"},{"location":"ex05.html#setup","text":"First, accept the assignment on GitHub Then, log in to one of the hosts of CS1010 programming environment and run 1 ~cs1010/get-ex05 You should see the folder ex05-<github username> in your home directory with the assignment skeleton inside. Inside that directory, you should see the following files: counter.c , dot.c , and unit.c , are the most important files. They are the skeleton C code that you should edit to solve the assignment and the only files that you should change. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 0 so you should already be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. NEW memcheck.sh : This is a bash script for check your code against memory errors. compile_flags.txt : This file specifies the flags for compilation and is used by both make and clang-tidy . NEW Questions.md containing the description of the questions. This is a plain text file that you can view with vim , less , or other tools.","title":"Setup"},{"location":"ex05.html#solving-the-assignments","text":"Edit the files counter.c , dot.c , and unit.c to solve the corresponding question as described below. To compile and run tests with the sample inputs and outputs: 1 make This command will compile all your C files with the appropriate settings and if there is no error, run the test scripts. If you pass the test cases, it will run clang-tidy to check if your code follows good code practices. The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. To compile individual program, type 1 make <program> For instance, the command 1 make echo compiles echo.c into echo without testing or running clang-tidy on it. To test individual program, run 1 ./test.sh <program> For instance, the command 1 ./test.sh echo tests echo without compiling or running clang-tidy on echo.c . NEW To check for memory errors while running your code, run 1 ./memcheck.sh <program> You can also run make memcheck to run memcheck.sh on all of your programs at once. Note that this step is not included in make by default since it is slow.","title":"Solving The Assignments"},{"location":"ex05.html#submission","text":"When you are ready, run the following command to submit: 1 ~cs1010/submit-ex05 The .c files will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Manipulating Files on GitHub Do not manipulate (e.g., edit) the files on GitHub or close the pull requests on GitHub. Doing so would interfere with the scripts and the grading/testing process of CS1010.","title":"Submission"},{"location":"ex05.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Shang Chi (Group G02)","title":"Identifying Yourself"},{"location":"ex05.html#questions","text":"To acclimatize you to the PE1 condition, the questions for this assignment is included in the skeleton instead, in a file named Questions.md . You should learn how to use vim to open both the .c file and the questions.md side-by-side (see https://nus-cs1010.github.io/2122-s1/vim.html#splitting-vims-viewport )","title":"Questions"},{"location":"ex06.html","text":"Exercise 6: Error, Twilight, Reverse, Unique, LookNSay Deadline This is an ungraded exercise. The questions here are taken from PE I of AY20/21 Semester 1. Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 0 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. You are comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, conditional if / else statements, and loops. You are comfortable breaking down a problem into smaller sub-problems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function. You are able to write C programs that are neat and readable, adhering to a common prescribed coding convention. Learning Objectives Apply concepts learn in Week 1 to Week 6 Build up confidence for Practical Exam I Setup First, accept the assignment on GitHub Then, log in to one of the hosts of CS1010 programming environment and run 1 ~cs1010/get-ex06 You should see the folder ex06-<github username> in your home directory with the assignment skeleton inside. Inside that directory, you should see the following files: error.c , twilight.c , reverse.c , unique.c , and looknsay.c , are the most important files. They are the skeleton C code that you should edit to solve the assignment and the only files that you should change. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 0 so you should already be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. compile_flags.txt : This file specifies the flags for compilation and is used by both make and clang-tidy . NEW Questions.md containing the description of the questions. This is a plain text file that you can view with vim , less , or other tools. Solving The Assignments Edit the files error.c , twilight.c , reverse.c , unique.c , and looknsay.c to solve the corresponding question as described below. To compile and run tests with the sample inputs and outputs: 1 make This command will compile all your C files with the appropriate settings and if there is no error, run the test scripts. If you pass the test cases, it will run clang-tidy to check if your code follows good code practices. The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. To compile individial program, type 1 make <program> For instance, the command 1 make echo compiles echo.c into echo without testing or running clang-tidy on it. To test individial program, run 1 ./test.sh <program> For instance, the command 1 ./test.sh echo tests echo without compiling or running clang-tidy on echo.c . Submission When you are ready, run the following command to submit: 1 ~cs1010/submit-ex06 The files error.c , twilight.c , reverse.c , unique.c , and looknsay.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Manipulating Files on GitHub Do not manipulate (e.g., edit) the files on GitHub or close the pull requests on GitHub. Doing so would interfere with the scripts and the grading/testing process of CS1010. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Geronimo Stilton (Group G02) Questions To acclimatize you to the PE1 condition, the questions for this assignment is included in the skeleton instead, in a file named Questions.md . You should learn how to use vim to open both the .c file and the questions.md side-by-side (see https://nus-cs1010.github.io/2122-s1/vim.html#splitting-vims-viewport )","title":"6. Error, Twilight, Reverse, Unique, LookNSay"},{"location":"ex06.html#exercise-6-error-twilight-reverse-unique-looknsay","text":"","title":"Exercise 6: Error, Twilight, Reverse, Unique, LookNSay"},{"location":"ex06.html#deadline","text":"This is an ungraded exercise. The questions here are taken from PE I of AY20/21 Semester 1.","title":"Deadline"},{"location":"ex06.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 0 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. You are comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, conditional if / else statements, and loops. You are comfortable breaking down a problem into smaller sub-problems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function. You are able to write C programs that are neat and readable, adhering to a common prescribed coding convention.","title":"Prerequisite"},{"location":"ex06.html#learning-objectives","text":"Apply concepts learn in Week 1 to Week 6 Build up confidence for Practical Exam I","title":"Learning Objectives"},{"location":"ex06.html#setup","text":"First, accept the assignment on GitHub Then, log in to one of the hosts of CS1010 programming environment and run 1 ~cs1010/get-ex06 You should see the folder ex06-<github username> in your home directory with the assignment skeleton inside. Inside that directory, you should see the following files: error.c , twilight.c , reverse.c , unique.c , and looknsay.c , are the most important files. They are the skeleton C code that you should edit to solve the assignment and the only files that you should change. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 0 so you should already be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. compile_flags.txt : This file specifies the flags for compilation and is used by both make and clang-tidy . NEW Questions.md containing the description of the questions. This is a plain text file that you can view with vim , less , or other tools.","title":"Setup"},{"location":"ex06.html#solving-the-assignments","text":"Edit the files error.c , twilight.c , reverse.c , unique.c , and looknsay.c to solve the corresponding question as described below. To compile and run tests with the sample inputs and outputs: 1 make This command will compile all your C files with the appropriate settings and if there is no error, run the test scripts. If you pass the test cases, it will run clang-tidy to check if your code follows good code practices. The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. To compile individial program, type 1 make <program> For instance, the command 1 make echo compiles echo.c into echo without testing or running clang-tidy on it. To test individial program, run 1 ./test.sh <program> For instance, the command 1 ./test.sh echo tests echo without compiling or running clang-tidy on echo.c .","title":"Solving The Assignments"},{"location":"ex06.html#submission","text":"When you are ready, run the following command to submit: 1 ~cs1010/submit-ex06 The files error.c , twilight.c , reverse.c , unique.c , and looknsay.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Manipulating Files on GitHub Do not manipulate (e.g., edit) the files on GitHub or close the pull requests on GitHub. Doing so would interfere with the scripts and the grading/testing process of CS1010.","title":"Submission"},{"location":"ex06.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Geronimo Stilton (Group G02)","title":"Identifying Yourself"},{"location":"ex06.html#questions","text":"To acclimatize you to the PE1 condition, the questions for this assignment is included in the skeleton instead, in a file named Questions.md . You should learn how to use vim to open both the .c file and the questions.md side-by-side (see https://nus-cs1010.github.io/2122-s1/vim.html#splitting-vims-viewport )","title":"Questions"},{"location":"ex08.html","text":"Exercise 8: Length, Concat, Search Deadline This is an ungraded exercise. Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 0 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. You are comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, conditional if / else statements, and loops. You are comfortable writing C programs that involve fixed-size arrays . You are comfortable breaking down a problem into smaller sub-problems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function. You are able to write C programs that are neat and readable, adhering to a common prescribed coding convention. Learning Objectives Learn how to write programs that manipulate and process strings in C. Practice documenting functions using Doxygen format. Setup First, accept the assignment on GitHub Then, log in to one of the hosts of CS1010 programming environment and run 1 ~cs1010/get-ex08 You should see the folder ex08-<github username> in your home directory with the assignment skeleton inside. Inside that directory, you should see the following files: length.c , concat.c , and search.c are the most important files. They are the skeleton C code that you should edit to solve the assignment and the only files that you should change. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 0 so you should already be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. compile_flags.txt : This file specifies the flags for compilation and is used by both make and clang-tidy . Questions.md containing the description of the questions. This is a plain text file that you can view with vim , less , or other tools. Solving The Assignments Edit the files length.c , concat.c , and search.c to solve the corresponding question as described in Questions.md . To compile and run tests with the sample inputs and outputs: 1 make This command will compile all your C files with the appropriate settings and if there is no error, run the test scripts. If you pass the test cases, it will run clang-tidy to check if your code follows good code practices. The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. To compile individual program, type 1 make <program> For instance, the command 1 make echo compiles echo.c into echo without testing or running clang-tidy on it. To test individial program, run 1 ./test.sh <program> For instance, the command 1 ./test.sh echo tests echo without compiling or running clang-tidy on echo.c . Submission When you are ready, run the following command to submit: 1 ~cs1010/submit-ex08 The files length.c , concat.c , and search.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Manipulating Files on GitHub Do not manipulate (e.g., edit) the files on GitHub or close the pull requests on GitHub. Doing so would interfere with the scripts and the grading/testing process of CS1010. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Fennec Shand (Group G02) Questions To acclimatize you to the PE condition, the questions for this assignment is included in the skeleton instead, in a file named Questions.md . You should learn how to use vim to open both the .c file and the questions.md side-by-side (see https://nus-cs1010.github.io/2122-s1/vim.html#splitting-vims-viewport )","title":"8. Length, Concat, Search"},{"location":"ex08.html#exercise-8-length-concat-search","text":"","title":"Exercise 8: Length, Concat, Search"},{"location":"ex08.html#deadline","text":"This is an ungraded exercise.","title":"Deadline"},{"location":"ex08.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 0 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. You are comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, conditional if / else statements, and loops. You are comfortable writing C programs that involve fixed-size arrays . You are comfortable breaking down a problem into smaller sub-problems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function. You are able to write C programs that are neat and readable, adhering to a common prescribed coding convention.","title":"Prerequisite"},{"location":"ex08.html#learning-objectives","text":"Learn how to write programs that manipulate and process strings in C. Practice documenting functions using Doxygen format.","title":"Learning Objectives"},{"location":"ex08.html#setup","text":"First, accept the assignment on GitHub Then, log in to one of the hosts of CS1010 programming environment and run 1 ~cs1010/get-ex08 You should see the folder ex08-<github username> in your home directory with the assignment skeleton inside. Inside that directory, you should see the following files: length.c , concat.c , and search.c are the most important files. They are the skeleton C code that you should edit to solve the assignment and the only files that you should change. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 0 so you should already be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. compile_flags.txt : This file specifies the flags for compilation and is used by both make and clang-tidy . Questions.md containing the description of the questions. This is a plain text file that you can view with vim , less , or other tools.","title":"Setup"},{"location":"ex08.html#solving-the-assignments","text":"Edit the files length.c , concat.c , and search.c to solve the corresponding question as described in Questions.md . To compile and run tests with the sample inputs and outputs: 1 make This command will compile all your C files with the appropriate settings and if there is no error, run the test scripts. If you pass the test cases, it will run clang-tidy to check if your code follows good code practices. The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. To compile individual program, type 1 make <program> For instance, the command 1 make echo compiles echo.c into echo without testing or running clang-tidy on it. To test individial program, run 1 ./test.sh <program> For instance, the command 1 ./test.sh echo tests echo without compiling or running clang-tidy on echo.c .","title":"Solving The Assignments"},{"location":"ex08.html#submission","text":"When you are ready, run the following command to submit: 1 ~cs1010/submit-ex08 The files length.c , concat.c , and search.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Manipulating Files on GitHub Do not manipulate (e.g., edit) the files on GitHub or close the pull requests on GitHub. Doing so would interfere with the scripts and the grading/testing process of CS1010.","title":"Submission"},{"location":"ex08.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Fennec Shand (Group G02)","title":"Identifying Yourself"},{"location":"ex08.html#questions","text":"To acclimatize you to the PE condition, the questions for this assignment is included in the skeleton instead, in a file named Questions.md . You should learn how to use vim to open both the .c file and the questions.md side-by-side (see https://nus-cs1010.github.io/2122-s1/vim.html#splitting-vims-viewport )","title":"Questions"},{"location":"ex09.html","text":"Exercise 9: Echo, Subtract, Line Deadline This is an ungraded exercise. Prerequisite You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 0 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. You are comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, conditional if / else statements, and loops. You are comfortable writing C programs that involve fixed-size arrays You are comfortable writing C programs that involve dynamically allocated 1D arrays You are comfortable breaking down a problem into smaller sub-problems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function. You are able to write C programs that are neat and readable, adhering to a common prescribed coding convention. Learning Objectives How to write programs that involve dynamically allocated 2D arrays or a mix of fixed-size and dynamically allocated arrays Setup First, accept the assignment on GitHub Then, log in to one of the hosts of CS1010 programming environment and run 1 ~cs1010/get-ex09 You should see the folder ex09-<github username> in your home directory with the assignment skeleton inside. Inside that directory, you should see the following files: echo.c , subtract.c , and line.c are the most important files. They are the skeleton C code that you should edit to solve the assignment and the only files that you should change. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 0 so you should already be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. compile_flags.txt : This file specifies the flags for compilation and is used by both make and clang-tidy . Questions.md containing the description of the questions. This is a plain text file that you can view with vim , less , or other tools. Solving The Assignments Edit the files echo.c , subtract.c , and line.c to solve the corresponding question as described in Questions.md . To compile and run tests with the sample inputs and outputs: 1 make This command will compile all your C files with the appropriate settings and if there is no error, run the test scripts. If you pass the test cases, it will run clang-tidy to check if your code follows good code practices. The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. To compile individual program, type 1 make <program> For instance, the command 1 make echo compiles echo.c into echo without testing or running clang-tidy on it. To test individial program, run 1 ./test.sh <program> For instance, the command 1 ./test.sh echo tests echo without compiling or running clang-tidy on echo.c . Submission When you are ready, run the following command to submit: 1 ~cs1010/submit-ex09 The files echo.c , subtract.c , and line.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Manipulating Files on GitHub Do not manipulate (e.g., edit) the files on GitHub or close the pull requests on GitHub. Doing so would interfere with the scripts and the grading/testing process of CS1010. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Baby Yoda (Group G02) Questions To acclimatize you to the PE condition, the questions for this assignment is included in the skeleton instead, in a file named Questions.md . You should learn how to use vim to open both the .c file and the questions.md side-by-side (see https://nus-cs1010.github.io/2122-s1/vim.html#splitting-vims-viewport )","title":"9. Echo, Subtract, Line"},{"location":"ex09.html#exercise-9-echo-subtract-line","text":"","title":"Exercise 9: Echo, Subtract, Line"},{"location":"ex09.html#deadline","text":"This is an ungraded exercise.","title":"Deadline"},{"location":"ex09.html#prerequisite","text":"You are able to access the CS1010 programming environment . You are familiar with basic UNIX CLI and using terminal-based editor vim . You have gone through Exercise 0 and have already set up your .gitconfig . You are familiar with the steps of accepting, downloading, and submitting your exercise and assignment. You are familiar with the directory structure and the common files included in your assignment skeleton. You are comfortable writing simple C programs that involve arithmetic operations, long , double , and bool types, conditional if / else statements, and loops. You are comfortable writing C programs that involve fixed-size arrays You are comfortable writing C programs that involve dynamically allocated 1D arrays You are comfortable breaking down a problem into smaller sub-problems which can be resolved using functions, including reusing existing functions written for other programs (with a tweak), writing a function that calls itself, designing what should the inputs and return values/types of a function. You are able to write C programs that are neat and readable, adhering to a common prescribed coding convention.","title":"Prerequisite"},{"location":"ex09.html#learning-objectives","text":"How to write programs that involve dynamically allocated 2D arrays or a mix of fixed-size and dynamically allocated arrays","title":"Learning Objectives"},{"location":"ex09.html#setup","text":"First, accept the assignment on GitHub Then, log in to one of the hosts of CS1010 programming environment and run 1 ~cs1010/get-ex09 You should see the folder ex09-<github username> in your home directory with the assignment skeleton inside. Inside that directory, you should see the following files: echo.c , subtract.c , and line.c are the most important files. They are the skeleton C code that you should edit to solve the assignment and the only files that you should change. inputs and outputs are subdirectories that contain test inputs and test outputs. We use the same convention as Exercise 0 so you should already be familiar with them. Makefile : This is the configuration for the tool make that we use to automate the compilation and testing of the programs. test.sh : This is a bash script for testing your code. compile_flags.txt : This file specifies the flags for compilation and is used by both make and clang-tidy . Questions.md containing the description of the questions. This is a plain text file that you can view with vim , less , or other tools.","title":"Setup"},{"location":"ex09.html#solving-the-assignments","text":"Edit the files echo.c , subtract.c , and line.c to solve the corresponding question as described in Questions.md . To compile and run tests with the sample inputs and outputs: 1 make This command will compile all your C files with the appropriate settings and if there is no error, run the test scripts. If you pass the test cases, it will run clang-tidy to check if your code follows good code practices. The test cases are given in the inputs and outputs subdirectory. You can use cat or less to look at the content of these test cases. You can add more test cases or edit the given ones if needed. To compile individual program, type 1 make <program> For instance, the command 1 make echo compiles echo.c into echo without testing or running clang-tidy on it. To test individial program, run 1 ./test.sh <program> For instance, the command 1 ./test.sh echo tests echo without compiling or running clang-tidy on echo.c .","title":"Solving The Assignments"},{"location":"ex09.html#submission","text":"When you are ready, run the following command to submit: 1 ~cs1010/submit-ex09 The files echo.c , subtract.c , and line.c will be uploaded to GitHub. You can submit multiple times, but only the last submission will be graded. Manipulating Files on GitHub Do not manipulate (e.g., edit) the files on GitHub or close the pull requests on GitHub. Doing so would interfere with the scripts and the grading/testing process of CS1010.","title":"Submission"},{"location":"ex09.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Baby Yoda (Group G02)","title":"Identifying Yourself"},{"location":"ex09.html#questions","text":"To acclimatize you to the PE condition, the questions for this assignment is included in the skeleton instead, in a file named Questions.md . You should learn how to use vim to open both the .c file and the questions.md side-by-side (see https://nus-cs1010.github.io/2122-s1/vim.html#splitting-vims-viewport )","title":"Questions"},{"location":"final.html","text":"Final Assessment Important Information Date: 24 November 2020 (Tuesday) Time: 5pm to 7 pm Venue: Online Scope: Units 1-29, Assignments 1-9, Tutorials 1-11 Format: MCQs and Short Structured Questions Duration: 120 minutes Open Book (You can refer to printed/written notes but no online references are allowed) A calculator is allowed (although you do not need it) E-Exam Procedure We adopt the E-exam procedure for the School of Computing for CS1010. This is a long document with a lot of information. Please read through it carefully. Please set up the software and hardware needed for taking e-exams before the test so that your test-taking experience is as smooth as possible. Note the following supplementary information to complete the E-exam procedure above, specific to CS1010. 2.1 Exam Taking Software We will use Luminus Quiz for the final test. 2.2 Proctoring Protocol Note that the following applies to CS1010: You are allowed to use only a single screen. If you\u2019re using an external monitor, the laptop screen must be switched off. The browser running Luminuz Quiz running on your PC must be in full-screen mode. No other tabs are allowed on the browser. 2.4. Seeking Clarifications on Exam Questions You are allowed to ask clarification questions during the exam. However, you may only ask a boolean yes/no question. For instance, you are not allowed to ask \"What can we assume about the input?\". You should rephrase it as \"Can we assume that the input is always positive?\". Our answers will only be in the form of \"yes\", \"no\", \"no comment\". 2.5. Multi-part Exam CS1010 final assessment is a single-part examination with no break in between. Screen Capturing Screen-capture software - similar to Midterm / PE1 / PE2, you will be required to upload your video to LumiNUS by November 24, 2200 hrs Submission link: https://luminus.nus.edu.sg/modules/c7b362a0-6aee-4b22-b4da-f9e8074249fd/files/84adf298-21a1-4c57-9cf6-4d58c8a0edd5 Secondary device to run Zoom Meeting for invigilation - this should be powered and running for the entire duration of the assessment Do note that failure to comply with proctoring requirements may result in a mark of 0 for the Final and/or other disciplinary action Zoom Session Assignment See Piazza for Zoom links and Luminus for grouping. Invigilators and Email Address See Piazza","title":"Final Assessment"},{"location":"final.html#final-assessment","text":"","title":"Final Assessment"},{"location":"final.html#important-information","text":"Date: 24 November 2020 (Tuesday) Time: 5pm to 7 pm Venue: Online Scope: Units 1-29, Assignments 1-9, Tutorials 1-11 Format: MCQs and Short Structured Questions Duration: 120 minutes Open Book (You can refer to printed/written notes but no online references are allowed) A calculator is allowed (although you do not need it)","title":"Important Information"},{"location":"final.html#e-exam-procedure","text":"We adopt the E-exam procedure for the School of Computing for CS1010. This is a long document with a lot of information. Please read through it carefully. Please set up the software and hardware needed for taking e-exams before the test so that your test-taking experience is as smooth as possible. Note the following supplementary information to complete the E-exam procedure above, specific to CS1010.","title":"E-Exam Procedure"},{"location":"final.html#21-exam-taking-software","text":"We will use Luminus Quiz for the final test.","title":"2.1 Exam Taking Software"},{"location":"final.html#22-proctoring-protocol","text":"Note that the following applies to CS1010: You are allowed to use only a single screen. If you\u2019re using an external monitor, the laptop screen must be switched off. The browser running Luminuz Quiz running on your PC must be in full-screen mode. No other tabs are allowed on the browser.","title":"2.2 Proctoring Protocol"},{"location":"final.html#24-seeking-clarifications-on-exam-questions","text":"You are allowed to ask clarification questions during the exam. However, you may only ask a boolean yes/no question. For instance, you are not allowed to ask \"What can we assume about the input?\". You should rephrase it as \"Can we assume that the input is always positive?\". Our answers will only be in the form of \"yes\", \"no\", \"no comment\".","title":"2.4. Seeking Clarifications on Exam Questions"},{"location":"final.html#25-multi-part-exam","text":"CS1010 final assessment is a single-part examination with no break in between.","title":"2.5. Multi-part Exam"},{"location":"final.html#screen-capturing","text":"Screen-capture software - similar to Midterm / PE1 / PE2, you will be required to upload your video to LumiNUS by November 24, 2200 hrs Submission link: https://luminus.nus.edu.sg/modules/c7b362a0-6aee-4b22-b4da-f9e8074249fd/files/84adf298-21a1-4c57-9cf6-4d58c8a0edd5 Secondary device to run Zoom Meeting for invigilation - this should be powered and running for the entire duration of the assessment Do note that failure to comply with proctoring requirements may result in a mark of 0 for the Final and/or other disciplinary action","title":"Screen Capturing"},{"location":"final.html#zoom-session-assignment","text":"See Piazza for Zoom links and Luminus for grouping.","title":"Zoom Session Assignment"},{"location":"final.html#invigilators-and-email-address","text":"See Piazza","title":"Invigilators and Email Address"},{"location":"github.html","text":"Linking Your PE Accounts to Your GitHub Accounts Prerequisites You should already have your SoC Unix account, cluster access, and SoC VPN set up, and be able to ssh into one of the CS1010 PE nodes. If you are not able to do this, please look at the guide on CS1010 programming environments You should be comfortable with running basic UNIX commands. If you have not gone through the UNIX guide and get your hands dirty, please look at the guide and play with the various basic Unix commands . You should already have a GitHub account and can log into GitHub.com . Purpose Your will be using git (indirectly) for retrieving skeleton code and submitting completed assignments. We will set up your accounts on PE hosts below so that git will be associated with your GitHub account. This is a one-time setup. You don't have to do this for every assignment. 1. Setting up .gitconfig Create and edit a file called .gitconfig in your home directory on the PE host , with the following content: 1 2 3 4 5 [user] name = Your Name email = Your Email [github] user = Your GitHub ID Your email should be whatever you used to sign up GitHub (which may not be your SoC or NUS email). For example, a sample .gitconfig looks like this: 1 2 3 4 5 [user] name = Elsa email = queen@arendelle.gov [github] user = elsasnow16 After saving this file, run: 1 git config --get github.user It should return your GitHub user id. It should print your GitHub user id as already set. If there is a typo, you need to edit .gitconfig again and reload it by repeating the command above. 2. Setting up Password-less Login Every time we run git , we need to authenticate ourselves to GitHub, with GitHub moving to use a personal authentication token instead of a password for authentication, this can be a bit tedious, and could add to the stress especially if you are trying to submit your assignment 30 seconds before the deadline. We, therefore, recommend setting up password-less login to GitHub using SSH keys. Basic of SSH Keys SSH uses public-key cryptography for authentication. The keys come in pairs: a public key and a private key. The private key must be kept safe and known only to you. You should keep the private key in your account, and not share it with others. To authenticate yourself to another host or service, you configure the host/service with your public key. When it is time for you to log in, your private key is \"matched\" 1 with your public key. Since only you know your private key, the service or the host can be sure that you are you and not someone else. Suppose you want to log in from host X to host Y without a password. You generate a pair of keys on X, then keep the private keys on X and store the public keys on Y. If you want to setup SSH Keys so that you can log into CS1010 PE nodes from your computer without a password, for example, you generate the pair of keys on your computer (X) and then copy the public key to CS1010 PE nodes. Our goal now is to authenticate ourselves to GitHub from the CS1010 PE nodes. So, X is the PE nodes, and Y is GitHub. Generating SSH keys The steps are explained in detail on GitHub Docs . Here is a summary of the steps that you should follow for CS1010: On any of the PE nodes, run 1 ssh-keygen -t ed25519 -C \"your_email@example.com\" where your_email@example.com is the email your associate with you used to sign up your GitHub account (i.e., the same one you entered in .gitconfig ). The command will prompt you where to save the key. Just press Enter to save into the default location, which is $HOME/.ssh/id_ed25519 . You will then be prompted for a passphrase. Since our goal is to automate assignment submission without needing to type anything, you should enter an empty passphrase. This increases the security risk, but then, we are working with CS1010 assignments here, not a top-secret project. So empty passphrase will do. You should see something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ooiwt@pe119:~$ ssh-keygen -t ed25519 -C \"ooiwt@comp.nus.edu.sg\" Generating public/private ed25519 key pair. Enter file in which to save the key (/home/o/ooiwt/.ssh/id_ed25519): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/o/ooiwt/.ssh/id_ed25519. Your public key has been saved in /home/o/ooiwt/.ssh/id_ed25519.pub. The key fingerprint is: SHA256:Br3wg7mplVuPyuDz8yZVDSh8Mn5ls5+yPZhTvGzmAkk ooiwt@comp.nus.edu.sg The key's randomart image is: +--[ED25519 256]--+ | . . | | = o.= | | . =oo.=. | | .E=.=o... | | ..Bo=ooS. . | | . =o+.++ o | | + +o = + | | oo = O | | .=oB.. | +----[SHA256]-----+ Adding Your CS1010 Public Key to Your GitHub Account The next step involves logging into GitHub.com, click on your avatar on the top right corner, and choose \"Settings\". Then choose \"SSH and GPG keys\" on the sidebar. Then, click either \"New SSH key\" or \"Add SSH key\". Enter an appropriate title for the key (e.g., \"CS1010 PE Hosts\"). Next, you need to paste your public key into the text box. Go back to your terminal and run 1 cat ~/.ssh/id_ed25519.pub Remember that cat just dumps the content of the file to the standard output. Now, you need to copy the content of the file displayed on the terminal, which is your public key, and paste it into the text box in the browser. Your key should start with ssh-ed22519 and ends with your email address. For instance, this is the exact text that I copy-pasted: 1 ssh-ed25519 AAAZC3NzaC1lZDI1NTE8AAAAIDdmwMpRrhRB95u7CTahehtBEeOdhSxDQdlpCxBK3KCP ooiwt@comp.nus.edu.sg I showed the above as an example, don't use my public key for your GitHub. Otherwise, I will have access to your account :) After entering the title and key above, click the green \"Add SSH key\" button to add the key you entered. If prompted, confirm your GitHub password. These steps are explained in detail on GitHub Docs . 3. Checking Your Authentication Settings To check if you can connect to git@github.com using SSH keys, run: 1 ssh -T git@github.com If everything is set up correctly, you will see the message 1 Hi ooiwt! You've successfully authenticated, but GitHub does not provide shell access. Otherwise, you should see 1 git@github.com: Permission denied (publickey). or other error messages. Note that you need to connect with the username git . Do not use your GitHub username (e.g., do not use ssh -T ooiwt@github.com ) I skipped many cool details here. This topic is part of CS2105 and CS2107. Interested students can google up various articles and videos online about how public-key cryptography is used for authentication. \u21a9","title":"GitHub"},{"location":"github.html#linking-your-pe-accounts-to-your-github-accounts","text":"","title":"Linking Your PE Accounts to Your GitHub Accounts"},{"location":"github.html#prerequisites","text":"You should already have your SoC Unix account, cluster access, and SoC VPN set up, and be able to ssh into one of the CS1010 PE nodes. If you are not able to do this, please look at the guide on CS1010 programming environments You should be comfortable with running basic UNIX commands. If you have not gone through the UNIX guide and get your hands dirty, please look at the guide and play with the various basic Unix commands . You should already have a GitHub account and can log into GitHub.com .","title":"Prerequisites"},{"location":"github.html#purpose","text":"Your will be using git (indirectly) for retrieving skeleton code and submitting completed assignments. We will set up your accounts on PE hosts below so that git will be associated with your GitHub account. This is a one-time setup. You don't have to do this for every assignment.","title":"Purpose"},{"location":"github.html#1-setting-up-gitconfig","text":"Create and edit a file called .gitconfig in your home directory on the PE host , with the following content: 1 2 3 4 5 [user] name = Your Name email = Your Email [github] user = Your GitHub ID Your email should be whatever you used to sign up GitHub (which may not be your SoC or NUS email). For example, a sample .gitconfig looks like this: 1 2 3 4 5 [user] name = Elsa email = queen@arendelle.gov [github] user = elsasnow16 After saving this file, run: 1 git config --get github.user It should return your GitHub user id. It should print your GitHub user id as already set. If there is a typo, you need to edit .gitconfig again and reload it by repeating the command above.","title":"1. Setting up .gitconfig"},{"location":"github.html#2-setting-up-password-less-login","text":"Every time we run git , we need to authenticate ourselves to GitHub, with GitHub moving to use a personal authentication token instead of a password for authentication, this can be a bit tedious, and could add to the stress especially if you are trying to submit your assignment 30 seconds before the deadline. We, therefore, recommend setting up password-less login to GitHub using SSH keys.","title":"2. Setting up Password-less Login"},{"location":"github.html#basic-of-ssh-keys","text":"SSH uses public-key cryptography for authentication. The keys come in pairs: a public key and a private key. The private key must be kept safe and known only to you. You should keep the private key in your account, and not share it with others. To authenticate yourself to another host or service, you configure the host/service with your public key. When it is time for you to log in, your private key is \"matched\" 1 with your public key. Since only you know your private key, the service or the host can be sure that you are you and not someone else. Suppose you want to log in from host X to host Y without a password. You generate a pair of keys on X, then keep the private keys on X and store the public keys on Y. If you want to setup SSH Keys so that you can log into CS1010 PE nodes from your computer without a password, for example, you generate the pair of keys on your computer (X) and then copy the public key to CS1010 PE nodes. Our goal now is to authenticate ourselves to GitHub from the CS1010 PE nodes. So, X is the PE nodes, and Y is GitHub.","title":"Basic of SSH Keys"},{"location":"github.html#generating-ssh-keys","text":"The steps are explained in detail on GitHub Docs . Here is a summary of the steps that you should follow for CS1010: On any of the PE nodes, run 1 ssh-keygen -t ed25519 -C \"your_email@example.com\" where your_email@example.com is the email your associate with you used to sign up your GitHub account (i.e., the same one you entered in .gitconfig ). The command will prompt you where to save the key. Just press Enter to save into the default location, which is $HOME/.ssh/id_ed25519 . You will then be prompted for a passphrase. Since our goal is to automate assignment submission without needing to type anything, you should enter an empty passphrase. This increases the security risk, but then, we are working with CS1010 assignments here, not a top-secret project. So empty passphrase will do. You should see something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ooiwt@pe119:~$ ssh-keygen -t ed25519 -C \"ooiwt@comp.nus.edu.sg\" Generating public/private ed25519 key pair. Enter file in which to save the key (/home/o/ooiwt/.ssh/id_ed25519): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/o/ooiwt/.ssh/id_ed25519. Your public key has been saved in /home/o/ooiwt/.ssh/id_ed25519.pub. The key fingerprint is: SHA256:Br3wg7mplVuPyuDz8yZVDSh8Mn5ls5+yPZhTvGzmAkk ooiwt@comp.nus.edu.sg The key's randomart image is: +--[ED25519 256]--+ | . . | | = o.= | | . =oo.=. | | .E=.=o... | | ..Bo=ooS. . | | . =o+.++ o | | + +o = + | | oo = O | | .=oB.. | +----[SHA256]-----+","title":"Generating SSH keys"},{"location":"github.html#adding-your-cs1010-public-key-to-your-github-account","text":"The next step involves logging into GitHub.com, click on your avatar on the top right corner, and choose \"Settings\". Then choose \"SSH and GPG keys\" on the sidebar. Then, click either \"New SSH key\" or \"Add SSH key\". Enter an appropriate title for the key (e.g., \"CS1010 PE Hosts\"). Next, you need to paste your public key into the text box. Go back to your terminal and run 1 cat ~/.ssh/id_ed25519.pub Remember that cat just dumps the content of the file to the standard output. Now, you need to copy the content of the file displayed on the terminal, which is your public key, and paste it into the text box in the browser. Your key should start with ssh-ed22519 and ends with your email address. For instance, this is the exact text that I copy-pasted: 1 ssh-ed25519 AAAZC3NzaC1lZDI1NTE8AAAAIDdmwMpRrhRB95u7CTahehtBEeOdhSxDQdlpCxBK3KCP ooiwt@comp.nus.edu.sg I showed the above as an example, don't use my public key for your GitHub. Otherwise, I will have access to your account :) After entering the title and key above, click the green \"Add SSH key\" button to add the key you entered. If prompted, confirm your GitHub password. These steps are explained in detail on GitHub Docs .","title":"Adding Your CS1010 Public Key to Your GitHub Account"},{"location":"github.html#3-checking-your-authentication-settings","text":"To check if you can connect to git@github.com using SSH keys, run: 1 ssh -T git@github.com If everything is set up correctly, you will see the message 1 Hi ooiwt! You've successfully authenticated, but GitHub does not provide shell access. Otherwise, you should see 1 git@github.com: Permission denied (publickey). or other error messages. Note that you need to connect with the username git . Do not use your GitHub username (e.g., do not use ssh -T ooiwt@github.com ) I skipped many cool details here. This topic is part of CS2105 and CS2107. Interested students can google up various articles and videos online about how public-key cryptography is used for authentication. \u21a9","title":"3. Checking Your Authentication Settings"},{"location":"library.html","text":"The CS1010 I/O Library To help students get started with C programming without worrying too much about the details and pitfalls of using printf and scanf , we provide a simple-to-use library to read and write integers, floating point numbers, and strings. The libraries are pre-installed in CS1010 programming environments , with cs1010.h located under ~cs1010/include and libcs1010.a located under ~cs1010/lib . Using the Library Header To use the CS1010 I/O library, you should #include the file cs1010.h , like this: 1 #include \"cs1010.h\" at the top of your C program. Linking The CS1010 I/O library is provided as the file libcs1010.a . To link to the library, you need to compile with -lcs1010 . Usually, you need to specify where you can find cs1010.h with the -I flag, and libcs1010.a with the -L flag. On the CS1010 programming environment, you would need to compile using the command line: 1 clang -I ~cs1010/include -L ~cs1010/lib hello.c -lcs1010 Although it is a long string to type, you should type it once and use up arrow in bash to go back to this command over-and-over again. For advanced students, we suggest that you put this in a shell script so that you just need to run the shell script to compile the program. We have also automated this for you for your assignments and exercises using the make command. Reading of a Single Value The CS1010 library supports reading of long value, double value, and strings (both space-separated words and newline-separated lines) from the standard input. For long and double . The relevant methods are: long cs1010_read_long() Returns a long value from the standard input. An error message will be printed (to stderr ) if the input sequence is not a valid long value -- in which case the value LONG_MAX will be returned. Example: 1 long year = cs1010_read_long (); double cs1010_read_double() Returns a double value from the standard input. An error message will be printed (to stderr ) if the input sequence is not a valid double value -- in which case the value DBL_MAX will be returned. Example: 1 double cap = cs1010_read_double (); char* cs1010_read_word() Returns a char * pointing to the next white-space-separated string from the standard input. A white-space character is defined based on the standard C function isspace() and includes the space , tab \\t , and newline \\n character. Returns NULL if there is an error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . 1 2 3 4 5 char * word = cs1010_read_word (); // use word to do something : : free ( word ); char* cs1010_read_line() Returns a char * pointing to the next new-line-separated string from the standard input. The string returns from cs1010_read_line() includes the newline character (if one is found). Returns NULL if there is an error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . 1 2 3 4 5 char * line = cs1010_read_line (); // use line to do something : : free ( line ); size_t cs1010_read_size_t() ( NEW ) Returns a size_t value from the standard input. An error message will be printed (to stderr ) if the input sequence is not a valid size_t value -- in which case the value 0 will be returned. Example: 1 size_t size = cs1010_read_size_t (); Reading of Multiple Values The CS1010 library also supports reading of multiple values. ( NEW ) These funtions takes in an argument of type size_t instead of long . long* cs1010_read_long_array(size_t k) Returns k numbers of long values read from the standard input stored in an array. An error message will be printed (to stderr ) for each input that is not a valid long value -- in which case the value LONG_MAX will be populated in the corresponding array element. Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . 1 2 3 4 5 6 7 8 size_t k = cs1010_read_size_t (); long * values = cs1010_read_long_array ( k ); if ( values != NULL ) { // Do something with array values : : free ( values ); } double* cs1010_read_double_array(size_t k) Returns k numbers of double values read from the standard input stored in an array. An error message will be printed (to stderr ) for each input that is not a valid double value -- in which case the value DBL_MAX will be populated in the corresponding array element. Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . 1 2 3 4 5 6 7 8 size_t k = cs1010_read_size_t (); double * values = cs1010_read_double_array ( k ); if ( values != NULL ) { // Do something with array values : : free ( values ); } char** cs1010_read_word_array(size_t k) Returns k white-space-separated words read from the standard input stored in an array. The notion of \"word\" is the same to cs1010_read_word() . Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each word and for the whole array by calling free . 1 2 3 4 5 6 7 8 9 10 11 size_t k = cs1010_read_size_t (); char ** words = cs1010_read_word_array ( k ); if ( words != NULL ) { // Do something with array words : : for ( size_t i = 0 ; i < k ; i += 1 ) { free ( words [ i ]); } free ( words ); } char** cs1010_read_line_array(size_t k) Returns k new-line-separated words read from the standard input stored in an array. The notion of line is the same to cs1010_read_line() . Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each line and for the whole array by calling free . 1 2 3 4 5 6 7 8 9 10 11 12 13 size_t k = cs1010_read_size_t (); char ** lines = cs1010_read_line_array ( k ); if ( lines == NULL ) { // Deal with error return ; } // Do something with array lines : : for ( size_t i = 0 ; i < k ; i += 1 ) { free ( lines [ i ]); } free ( lines ); Printing of a Single Value The CS1010 library provides a few convenience functions to format and print long and double values to the standard output. void cs1010_print_long(long value) and void cs1010_println_long(long value) Print value to the standard output (with printf format %ld ). The cs1010_println_long version prints a newline after the value. 1 2 3 long x ; : cs1010_print_long ( x ); void cs1010_print_double(double value) and void cs1010_println_double(double value) Print value to the standard output (with printf format %.4f ). The cs1010_println_double version prints a newline after the value. 1 2 3 double x ; : cs1010_println_double ( x ); void cs1010_print_string(char *str) and void cs1010_println_string(char *str) Print a given string str to the standard output. These functions are provided for completeness and is a simple wrapper around printf(str) and printf(\"%s\\n\", str) repsectively. 1 cs1010_println_string ( \"hello world!\" ); Printing single character There is no cs1010_print_char method. You can use putchar from the C standard library for this purpose. void cs1010_print_pointer(void *ptr) and void cs1010_println_pointer(void *ptr) ( NEW ) Print a given pointer ptr to the standard output in decimal format. 1 2 long * x ; cs1010_println_pointer ( & x ); Clearing screen The CS1010 library provides a function to clear your screen. 1 cs1010_clear_screen (); Installing the Library If you want to install the libraries on your own computer for purposes other than CS1010, you can do the following: To get an updated copy of the library, clone it from its git repo on GitHub with the command: 1 git clone https://github.com/nus-cs1010/libcs1010.git It is recommended you do this in your home directory. You should see an output similar to: 1 2 3 4 5 Cloning into 'libcs1010'... remote: Counting objects: 6, done. remote: Compressing objects: 100% (3/3), done. remote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (6/6), done. After that, you should see a subdirectory libcs1010 created in your current directory. Inside, there should be a file called Makefile , and two subdirectories called include and src . To compile the library, run 1 make This should compile the file src/cs1010.c and create a static C library named libcs1010.a under the lib directory.","title":"CS1010 I/O Library"},{"location":"library.html#the-cs1010-io-library","text":"To help students get started with C programming without worrying too much about the details and pitfalls of using printf and scanf , we provide a simple-to-use library to read and write integers, floating point numbers, and strings. The libraries are pre-installed in CS1010 programming environments , with cs1010.h located under ~cs1010/include and libcs1010.a located under ~cs1010/lib .","title":"The CS1010 I/O Library"},{"location":"library.html#using-the-library","text":"","title":"Using the Library"},{"location":"library.html#header","text":"To use the CS1010 I/O library, you should #include the file cs1010.h , like this: 1 #include \"cs1010.h\" at the top of your C program.","title":"Header"},{"location":"library.html#linking","text":"The CS1010 I/O library is provided as the file libcs1010.a . To link to the library, you need to compile with -lcs1010 . Usually, you need to specify where you can find cs1010.h with the -I flag, and libcs1010.a with the -L flag. On the CS1010 programming environment, you would need to compile using the command line: 1 clang -I ~cs1010/include -L ~cs1010/lib hello.c -lcs1010 Although it is a long string to type, you should type it once and use up arrow in bash to go back to this command over-and-over again. For advanced students, we suggest that you put this in a shell script so that you just need to run the shell script to compile the program. We have also automated this for you for your assignments and exercises using the make command.","title":"Linking"},{"location":"library.html#reading-of-a-single-value","text":"The CS1010 library supports reading of long value, double value, and strings (both space-separated words and newline-separated lines) from the standard input. For long and double . The relevant methods are: long cs1010_read_long() Returns a long value from the standard input. An error message will be printed (to stderr ) if the input sequence is not a valid long value -- in which case the value LONG_MAX will be returned. Example: 1 long year = cs1010_read_long (); double cs1010_read_double() Returns a double value from the standard input. An error message will be printed (to stderr ) if the input sequence is not a valid double value -- in which case the value DBL_MAX will be returned. Example: 1 double cap = cs1010_read_double (); char* cs1010_read_word() Returns a char * pointing to the next white-space-separated string from the standard input. A white-space character is defined based on the standard C function isspace() and includes the space , tab \\t , and newline \\n character. Returns NULL if there is an error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . 1 2 3 4 5 char * word = cs1010_read_word (); // use word to do something : : free ( word ); char* cs1010_read_line() Returns a char * pointing to the next new-line-separated string from the standard input. The string returns from cs1010_read_line() includes the newline character (if one is found). Returns NULL if there is an error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . 1 2 3 4 5 char * line = cs1010_read_line (); // use line to do something : : free ( line ); size_t cs1010_read_size_t() ( NEW ) Returns a size_t value from the standard input. An error message will be printed (to stderr ) if the input sequence is not a valid size_t value -- in which case the value 0 will be returned. Example: 1 size_t size = cs1010_read_size_t ();","title":"Reading of a Single Value"},{"location":"library.html#reading-of-multiple-values","text":"The CS1010 library also supports reading of multiple values. ( NEW ) These funtions takes in an argument of type size_t instead of long . long* cs1010_read_long_array(size_t k) Returns k numbers of long values read from the standard input stored in an array. An error message will be printed (to stderr ) for each input that is not a valid long value -- in which case the value LONG_MAX will be populated in the corresponding array element. Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . 1 2 3 4 5 6 7 8 size_t k = cs1010_read_size_t (); long * values = cs1010_read_long_array ( k ); if ( values != NULL ) { // Do something with array values : : free ( values ); } double* cs1010_read_double_array(size_t k) Returns k numbers of double values read from the standard input stored in an array. An error message will be printed (to stderr ) for each input that is not a valid double value -- in which case the value DBL_MAX will be populated in the corresponding array element. Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . 1 2 3 4 5 6 7 8 size_t k = cs1010_read_size_t (); double * values = cs1010_read_double_array ( k ); if ( values != NULL ) { // Do something with array values : : free ( values ); } char** cs1010_read_word_array(size_t k) Returns k white-space-separated words read from the standard input stored in an array. The notion of \"word\" is the same to cs1010_read_word() . Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each word and for the whole array by calling free . 1 2 3 4 5 6 7 8 9 10 11 size_t k = cs1010_read_size_t (); char ** words = cs1010_read_word_array ( k ); if ( words != NULL ) { // Do something with array words : : for ( size_t i = 0 ; i < k ; i += 1 ) { free ( words [ i ]); } free ( words ); } char** cs1010_read_line_array(size_t k) Returns k new-line-separated words read from the standard input stored in an array. The notion of line is the same to cs1010_read_line() . Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each line and for the whole array by calling free . 1 2 3 4 5 6 7 8 9 10 11 12 13 size_t k = cs1010_read_size_t (); char ** lines = cs1010_read_line_array ( k ); if ( lines == NULL ) { // Deal with error return ; } // Do something with array lines : : for ( size_t i = 0 ; i < k ; i += 1 ) { free ( lines [ i ]); } free ( lines );","title":"Reading of Multiple Values"},{"location":"library.html#printing-of-a-single-value","text":"The CS1010 library provides a few convenience functions to format and print long and double values to the standard output. void cs1010_print_long(long value) and void cs1010_println_long(long value) Print value to the standard output (with printf format %ld ). The cs1010_println_long version prints a newline after the value. 1 2 3 long x ; : cs1010_print_long ( x ); void cs1010_print_double(double value) and void cs1010_println_double(double value) Print value to the standard output (with printf format %.4f ). The cs1010_println_double version prints a newline after the value. 1 2 3 double x ; : cs1010_println_double ( x ); void cs1010_print_string(char *str) and void cs1010_println_string(char *str) Print a given string str to the standard output. These functions are provided for completeness and is a simple wrapper around printf(str) and printf(\"%s\\n\", str) repsectively. 1 cs1010_println_string ( \"hello world!\" ); Printing single character There is no cs1010_print_char method. You can use putchar from the C standard library for this purpose. void cs1010_print_pointer(void *ptr) and void cs1010_println_pointer(void *ptr) ( NEW ) Print a given pointer ptr to the standard output in decimal format. 1 2 long * x ; cs1010_println_pointer ( & x );","title":"Printing of a Single Value"},{"location":"library.html#clearing-screen","text":"The CS1010 library provides a function to clear your screen. 1 cs1010_clear_screen ();","title":"Clearing screen"},{"location":"library.html#installing-the-library","text":"If you want to install the libraries on your own computer for purposes other than CS1010, you can do the following: To get an updated copy of the library, clone it from its git repo on GitHub with the command: 1 git clone https://github.com/nus-cs1010/libcs1010.git It is recommended you do this in your home directory. You should see an output similar to: 1 2 3 4 5 Cloning into 'libcs1010'... remote: Counting objects: 6, done. remote: Compressing objects: 100% (3/3), done. remote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (6/6), done. After that, you should see a subdirectory libcs1010 created in your current directory. Inside, there should be a file called Makefile , and two subdirectories called include and src . To compile the library, run 1 make This should compile the file src/cs1010.c and create a static C library named libcs1010.a under the lib directory.","title":"Installing the Library"},{"location":"make.html","text":"Compiling and Testing with make make is a programmer's utility to automate the workflow of the edit-compile-run cycle. We use make for all your exercises, assignments, and practical exams. A Makefile is provided for each of your assignments, exercises, and during practical exams. You don't have to know how to write a Makefile , but interested students can contact the teaching team for learning resources. For most of the situations, you only need to run: 1 make Our Makefile is configured so that make performs the following three tasks, in order: - compile all the *.c files, with the correct flags and libraries, to generate the executable binaries. - run clang-tidy on all the *.c files to check if you follow good programming habits in your code - run test.sh on each of the programs, on each of the inputs, and cross-check if the output is correct. make is smart enough that, if a C file has not changed since the last compilation, it will not recompile the file. If you only want to run clang-tidy on all the C files, you can run 1 make tidy If you only want to test all the programs, you can run 1 make test Sometimes it is useful to test run a particular program only. For example, if you want to test only the program digits , then 1 ./test.sh digits Finally, you can also run 1 make clean to remove all the generated executable files.","title":"Make"},{"location":"make.html#compiling-and-testing-with-make","text":"make is a programmer's utility to automate the workflow of the edit-compile-run cycle. We use make for all your exercises, assignments, and practical exams. A Makefile is provided for each of your assignments, exercises, and during practical exams. You don't have to know how to write a Makefile , but interested students can contact the teaching team for learning resources. For most of the situations, you only need to run: 1 make Our Makefile is configured so that make performs the following three tasks, in order: - compile all the *.c files, with the correct flags and libraries, to generate the executable binaries. - run clang-tidy on all the *.c files to check if you follow good programming habits in your code - run test.sh on each of the programs, on each of the inputs, and cross-check if the output is correct. make is smart enough that, if a C file has not changed since the last compilation, it will not recompile the file. If you only want to run clang-tidy on all the C files, you can run 1 make tidy If you only want to test all the programs, you can run 1 make test Sometimes it is useful to test run a particular program only. For example, if you want to test only the program digits , then 1 ./test.sh digits Finally, you can also run 1 make clean to remove all the generated executable files.","title":"Compiling and Testing with make"},{"location":"messages.html","text":"Common clang Errors and Warnings Here is the list of common clang errors and warnings that you may encounter. We will expand this list over the semester. How to Read the Messages clang messages always start with the name of the file, the line number, and the character position. For instance, 1 error.c:3:5: error: use of undeclared identifier 'x' shows the error in the file error.c , line 3, position 5. In vim , you can use :<line number> to jump directly to the line containing this error. Variables Error: Use of undeclared identifier C is a static type language, and thus every variable used must be declared with its type. E.g., 1 2 3 4 int main () { x = 0 ; } would lead to the error 1 2 3 x.c:3:5: error: use of undeclared identifier 'x' x = 0; ^ In the example above, x is used by not declared. To fix, declare x with its type. E.g., 1 2 3 4 int main () { long x = 0 ; } Error: Redefinition of a variable Each variable should be declared exactly once within its scope (scoped by { and } ). E.g., 1 2 3 4 5 int main () { long x = 0 ; long x = 1 ; } Would give the error 1 2 3 4 5 6 x.c:4:10: error: redefinition of 'x' long x = 1; ^ x.c:3:10: note: previous definition is here long x = 0; ^ To fix, check whether you intend the second declaration to be the same variable (in which case, remove the declaration) or a new one (in which case, give it a different name). Warning: Unused Variable Declaring variables that are not used clutters the code. It is a good programming practice to only declare the variables that you need. CS1010 insists on this. If you declare variables that you end up not using, you will be penalized. 1 2 3 4 int main () { long x = 1 ; } Would result in 1 2 3 x.c:4:10: warning: unused variable 'x' [-Wunused-variable] long x = 1; ^ To fix, go through all such warnings and remove any variables that you declared/initialized but never used. Warning: Variable May Be Uninitialized A variable is uninitialized if it is declared but not assigned any value. This might lead to bugs in your code. 1 2 3 4 5 int main () { long y ; return y ; } Would result in 1 2 3 4 5 6 7 x.c:4:10: warning: variable 'y' is uninitialized when used here [-Wuninitialized] return y; ^ x.c:3:9: note: initialize the variable 'y' to silence this warning long y; ^ = 0 To fix, initialize the variable to appropriate value. Warning: Declarations shadows a local variable. Avoid naming a variable the same name as another variable in the outer scope. Doing so makes your code confusing to read. E.g., 1 2 3 4 5 6 int main () { long x = 0 ; if ( x < 0 ) { long x = 1 ; } } causes the following warning: 1 2 3 4 5 6 x.c:4:10: warning: declaration shadows a local variable [-Wshadow] long x = 1; ^ x.c:2:8: note: previous declaration is here long x = 0; ^ Warning: No previous extern declaration for non-static variable A global variable is detected. The use of global variables is bug-prone and should be avoided. For instance, 1 2 3 4 int x ; int main () { x = 1 ; } would lead to 1 2 3 4 5 6 7 8 x.c:1:6: warning: no previous extern declaration for non-static variable 'x' [-Wmissing-variable-declarations] long x; ^ x.c:1:1: note: declare 'static' if the variable is not intended to be used outside of this translation unit long x; ^ To fix, make the variable local and pass it around from function to function. Functions Warning: Type specifier missing Functions must have a return type declared. C, by default, treats all functions as returning int if the return type is not declared. It is, however, a good programming practice to always declare the return type explicitly, even if it is returning int . CS1010 insists on this and you will be penalized if you do not declare the return type. E.g., 1 2 3 main () { } would give the warning 1 2 3 x.c:1:1: warning: type specifier missing, defaults to 'int' [-Wimplicit-int] main() ^ Warning: Implicit declaration of function All functions in C must be declared before they are used. If the function is defined elsewhere, the header file containing the function declaration should be included. Without the function declaration, the compile will guess the type of the arguments and its return type. An incorrect guess would lead to buggy code and thus should be avoided. E.g., 1 2 3 4 main () { sqrt ( 4 ); } would give the warning 1 2 3 4 x.c:3:4: warning: implicitly declaring library function 'sqrt' with type 'double (double)' [-Wimplicit-function-declaration] sqrt(4); ^ To fix, include the appropriate header file. Error: Undefined reference to a function This error is usually accompanied by an \"implicit declaration of function\" warning. During linking, clang tries to locate the definition of a function. Calling a function that is not defined would lead to the error above. E.g., 1 2 3 int main () { foo (); } would give the error: 1 2 3 /tmp/x-edd854.o: In function `main': x.c:(.text+0xb): undefined reference to `foo' clang: error: linker command failed with exit code 1 (use -v to see invocation)u Error: Too many/few arguments to a function call Each function should be called with exactly the number of arguments defined. E.g., 1 2 3 4 5 #include <math.h> int main () { sqrt (); } would lead to: 1 2 3 x.c:4:10: error: too few arguments to function call, single argument '__x' was not specified sqrt(); ~~~~ ^ To fix, check the documentation or the man page of the function you are calling to understand the number of arguments needed. Warning: Control reaches the end of non-void function Every non-void function, except main , must return a value. If you define a non-void function but did not include a return statement, the compiler would warn you. Failing the return the intended value means the caller would not receive the correct value back, leading to a buggy code. E.g., 1 2 3 int foo () { } would lead to the warning: 1 2 x.c:3:1: warning: control reaches end of non-void function [-Wreturn-type] } To fix this, double-check if the function needs to return anything. If not, change the return type to void . Otherwise, return the appropriate value. Warning: Parameter is not declared, defaulting to type int The type of each parameter to a function must be declared explicitly. Not doing so would lead to code that is cognitively harder to understand and bug-prone than necessary. For example, 1 2 3 int foo ( x ) { return x ; } would give 1 2 3 x.c:1:9: warning: parameter 'x' was not declared, defaulting to type 'int' [-Wpedantic] int foo(x) { ^ To fix, declare an appropriate type for each parameter. Warning: Unused Parameter Every parameter that you pass into a function must serve a purpose and so should be used. For instance, 1 2 3 int foo ( long x ) { return 0 ; } leads to the warning: 1 2 3 x.c:1:14: warning: unused parameter 'x' [-Wunused-parameter] int foo(long x) { ^ To fix, either remove the parameter x if you do not need it or check that you do not unintentionally leave x unused. Logic Warning: Expression result unused The result of your expression should be used. Otherwise, the computation is wasted. For instance: 1 2 3 4 int main () { long x = 0 ; x + 2 ; } causes the warning: 1 2 3 x.c:3:5: warning: expression result unused [-Wunused-value] x + 2; ~ ^ ~ To fix, check the expression is necessary. If so, use it as intended. Otherwise, remove it. Warning: Code/return/break will never be executed The execution flow of your code is incorrect. Part of the code will never be executed and is redundant. 1 2 3 4 5 int main () { long x ; return 0 ; x = 1 ; } causes the warning: 1 2 3 x.c:4:7: warning: code will never be executed [-Wunreachable-code] x = 1; ^ To fix, check the logic of your code and remove redundant code. Warning: Comparing floating point with == or != is unsafe Floating numbers should never be compared with == operator since the representation is not precise. 1 2 3 4 void foo ( double x ) { if ( x == 0.03 ) { } } causes the warning 1 2 3 x.c:2:9: warning: comparing floating point with == or != is unsafe [-Wfloat-equal] if (x == 0.03) { ~ ^ ~~~~ To fix this, use > and < comparison with a small error. For instance, 1 2 if ( x > 0.003 - EPSILON && x < 0.003 + EPSILON ) { } where EPSILON is a very small number.","title":"C Compiler Messages"},{"location":"messages.html#common-clang-errors-and-warnings","text":"Here is the list of common clang errors and warnings that you may encounter. We will expand this list over the semester.","title":"Common clang Errors and Warnings"},{"location":"messages.html#how-to-read-the-messages","text":"clang messages always start with the name of the file, the line number, and the character position. For instance, 1 error.c:3:5: error: use of undeclared identifier 'x' shows the error in the file error.c , line 3, position 5. In vim , you can use :<line number> to jump directly to the line containing this error.","title":"How to Read the Messages"},{"location":"messages.html#variables","text":"","title":"Variables"},{"location":"messages.html#error-use-of-undeclared-identifier","text":"C is a static type language, and thus every variable used must be declared with its type. E.g., 1 2 3 4 int main () { x = 0 ; } would lead to the error 1 2 3 x.c:3:5: error: use of undeclared identifier 'x' x = 0; ^ In the example above, x is used by not declared. To fix, declare x with its type. E.g., 1 2 3 4 int main () { long x = 0 ; }","title":"Error: Use of undeclared identifier"},{"location":"messages.html#error-redefinition-of-a-variable","text":"Each variable should be declared exactly once within its scope (scoped by { and } ). E.g., 1 2 3 4 5 int main () { long x = 0 ; long x = 1 ; } Would give the error 1 2 3 4 5 6 x.c:4:10: error: redefinition of 'x' long x = 1; ^ x.c:3:10: note: previous definition is here long x = 0; ^ To fix, check whether you intend the second declaration to be the same variable (in which case, remove the declaration) or a new one (in which case, give it a different name).","title":"Error: Redefinition of a variable"},{"location":"messages.html#warning-unused-variable","text":"Declaring variables that are not used clutters the code. It is a good programming practice to only declare the variables that you need. CS1010 insists on this. If you declare variables that you end up not using, you will be penalized. 1 2 3 4 int main () { long x = 1 ; } Would result in 1 2 3 x.c:4:10: warning: unused variable 'x' [-Wunused-variable] long x = 1; ^ To fix, go through all such warnings and remove any variables that you declared/initialized but never used.","title":"Warning: Unused Variable"},{"location":"messages.html#warning-variable-may-be-uninitialized","text":"A variable is uninitialized if it is declared but not assigned any value. This might lead to bugs in your code. 1 2 3 4 5 int main () { long y ; return y ; } Would result in 1 2 3 4 5 6 7 x.c:4:10: warning: variable 'y' is uninitialized when used here [-Wuninitialized] return y; ^ x.c:3:9: note: initialize the variable 'y' to silence this warning long y; ^ = 0 To fix, initialize the variable to appropriate value.","title":"Warning: Variable May Be Uninitialized"},{"location":"messages.html#warning-declarations-shadows-a-local-variable","text":"Avoid naming a variable the same name as another variable in the outer scope. Doing so makes your code confusing to read. E.g., 1 2 3 4 5 6 int main () { long x = 0 ; if ( x < 0 ) { long x = 1 ; } } causes the following warning: 1 2 3 4 5 6 x.c:4:10: warning: declaration shadows a local variable [-Wshadow] long x = 1; ^ x.c:2:8: note: previous declaration is here long x = 0; ^","title":"Warning: Declarations shadows a local variable."},{"location":"messages.html#warning-no-previous-extern-declaration-for-non-static-variable","text":"A global variable is detected. The use of global variables is bug-prone and should be avoided. For instance, 1 2 3 4 int x ; int main () { x = 1 ; } would lead to 1 2 3 4 5 6 7 8 x.c:1:6: warning: no previous extern declaration for non-static variable 'x' [-Wmissing-variable-declarations] long x; ^ x.c:1:1: note: declare 'static' if the variable is not intended to be used outside of this translation unit long x; ^ To fix, make the variable local and pass it around from function to function.","title":"Warning: No previous extern declaration for non-static variable"},{"location":"messages.html#functions","text":"","title":"Functions"},{"location":"messages.html#warning-type-specifier-missing","text":"Functions must have a return type declared. C, by default, treats all functions as returning int if the return type is not declared. It is, however, a good programming practice to always declare the return type explicitly, even if it is returning int . CS1010 insists on this and you will be penalized if you do not declare the return type. E.g., 1 2 3 main () { } would give the warning 1 2 3 x.c:1:1: warning: type specifier missing, defaults to 'int' [-Wimplicit-int] main() ^","title":"Warning: Type specifier missing"},{"location":"messages.html#warning-implicit-declaration-of-function","text":"All functions in C must be declared before they are used. If the function is defined elsewhere, the header file containing the function declaration should be included. Without the function declaration, the compile will guess the type of the arguments and its return type. An incorrect guess would lead to buggy code and thus should be avoided. E.g., 1 2 3 4 main () { sqrt ( 4 ); } would give the warning 1 2 3 4 x.c:3:4: warning: implicitly declaring library function 'sqrt' with type 'double (double)' [-Wimplicit-function-declaration] sqrt(4); ^ To fix, include the appropriate header file.","title":"Warning: Implicit declaration of function"},{"location":"messages.html#error-undefined-reference-to-a-function","text":"This error is usually accompanied by an \"implicit declaration of function\" warning. During linking, clang tries to locate the definition of a function. Calling a function that is not defined would lead to the error above. E.g., 1 2 3 int main () { foo (); } would give the error: 1 2 3 /tmp/x-edd854.o: In function `main': x.c:(.text+0xb): undefined reference to `foo' clang: error: linker command failed with exit code 1 (use -v to see invocation)u","title":"Error: Undefined reference to a function"},{"location":"messages.html#error-too-manyfew-arguments-to-a-function-call","text":"Each function should be called with exactly the number of arguments defined. E.g., 1 2 3 4 5 #include <math.h> int main () { sqrt (); } would lead to: 1 2 3 x.c:4:10: error: too few arguments to function call, single argument '__x' was not specified sqrt(); ~~~~ ^ To fix, check the documentation or the man page of the function you are calling to understand the number of arguments needed.","title":"Error: Too many/few arguments to a function call"},{"location":"messages.html#warning-control-reaches-the-end-of-non-void-function","text":"Every non-void function, except main , must return a value. If you define a non-void function but did not include a return statement, the compiler would warn you. Failing the return the intended value means the caller would not receive the correct value back, leading to a buggy code. E.g., 1 2 3 int foo () { } would lead to the warning: 1 2 x.c:3:1: warning: control reaches end of non-void function [-Wreturn-type] } To fix this, double-check if the function needs to return anything. If not, change the return type to void . Otherwise, return the appropriate value.","title":"Warning: Control reaches the end of non-void function"},{"location":"messages.html#warning-parameter-is-not-declared-defaulting-to-type-int","text":"The type of each parameter to a function must be declared explicitly. Not doing so would lead to code that is cognitively harder to understand and bug-prone than necessary. For example, 1 2 3 int foo ( x ) { return x ; } would give 1 2 3 x.c:1:9: warning: parameter 'x' was not declared, defaulting to type 'int' [-Wpedantic] int foo(x) { ^ To fix, declare an appropriate type for each parameter.","title":"Warning: Parameter is not declared, defaulting to type int"},{"location":"messages.html#warning-unused-parameter","text":"Every parameter that you pass into a function must serve a purpose and so should be used. For instance, 1 2 3 int foo ( long x ) { return 0 ; } leads to the warning: 1 2 3 x.c:1:14: warning: unused parameter 'x' [-Wunused-parameter] int foo(long x) { ^ To fix, either remove the parameter x if you do not need it or check that you do not unintentionally leave x unused.","title":"Warning: Unused Parameter"},{"location":"messages.html#logic","text":"","title":"Logic"},{"location":"messages.html#warning-expression-result-unused","text":"The result of your expression should be used. Otherwise, the computation is wasted. For instance: 1 2 3 4 int main () { long x = 0 ; x + 2 ; } causes the warning: 1 2 3 x.c:3:5: warning: expression result unused [-Wunused-value] x + 2; ~ ^ ~ To fix, check the expression is necessary. If so, use it as intended. Otherwise, remove it.","title":"Warning: Expression result unused"},{"location":"messages.html#warning-codereturnbreak-will-never-be-executed","text":"The execution flow of your code is incorrect. Part of the code will never be executed and is redundant. 1 2 3 4 5 int main () { long x ; return 0 ; x = 1 ; } causes the warning: 1 2 3 x.c:4:7: warning: code will never be executed [-Wunreachable-code] x = 1; ^ To fix, check the logic of your code and remove redundant code.","title":"Warning: Code/return/break will never be executed"},{"location":"messages.html#warning-comparing-floating-point-with-or-is-unsafe","text":"Floating numbers should never be compared with == operator since the representation is not precise. 1 2 3 4 void foo ( double x ) { if ( x == 0.03 ) { } } causes the warning 1 2 3 x.c:2:9: warning: comparing floating point with == or != is unsafe [-Wfloat-equal] if (x == 0.03) { ~ ^ ~~~~ To fix this, use > and < comparison with a small error. For instance, 1 2 if ( x > 0.003 - EPSILON && x < 0.003 + EPSILON ) { } where EPSILON is a very small number.","title":"Warning: Comparing floating point with == or != is unsafe"},{"location":"midterm.html","text":"Midterm Visit this page for updates about midterm information. Important Information Date: 27 September 2021 (Monday) Time: 12noon to 2 pm Venue: Online Scope: Units 1-12, Assignments 1-2, Exercises 1-4 Format: MCQs, MRQs, True/False, Fill-in-the-Blank, and Short Structured Questions Duration: 60 minutes Open Book (You can refer to printed/written notes but no online references are allowed) A calculator is allowed Practice Paper To be available on Week 6. Taking Exam on Campus If you wish to take the midterm on campus, please fill up this survey . Note that: We cannot guarantee we will be able to find a sufficiently large and quiet venue for everyone. The midterm will still be taken online. Only the invigilation will be done face-to-face. Once the list of students taking midterm on campus is finalized, it cannot be changed. E-Exam Procedure We adopt the E-exam procedure for the School of Computing for CS1010. This is a long document with a lot of information. Please read through it carefully. Please set up the software and hardware needed for taking e-exams before the test so that your test-taking experience is as smooth as possible. Note the following supplementary information to complete the E-exam procedure above, specific to CS1010. 1.2.1. On PC We recommend Penopto for screen recording. 2.1 Exam Taking Software We will use Luminus Quiz for the midterm test. 2.2 Proctoring Protocol Note that the following applies to CS1010: You are allowed to use only a single screen. If you\u2019re using an external monitor, the laptop screen must be switched off. The browser running LumiNUS Quiz running on your PC must be in full-screen mode. No other tabs are allowed on the browser. 2.4. Seeking Clarifications on Exam Questions You are allowed to ask clarification questions during the exam. However, you may only ask a boolean yes/no question. For instance, you are not allowed to ask \"What can we assume about the input?\". You should rephrase it as \"Can we assume that the input is always positive?\". Our answers will only be in the form of \"yes\", \"no\", \"no comment\". 2.5. Multi-part Exam CS1010 midterm is only a single part with no break in between. 12. Screen Recording Software We recommend Penopto for screen recording. Zoom Session Assignment Zoom session assignment is available internally via LumiNUS Zoom links is now available via Piazza Invigilators and Email Address 1 2 3 4 5 6 7 8 9 10 11 12 X01 Wang Chengxin cwang@u.nus.edu X02 Alvin Heng Jun Ren alvin.heng@u.nus.edu X03 Felix Halim felix@u.nus.edu X04 Tean Wei Jun e0540193@u.nus.edu X05 Liang Yuzhao e0543802@u.nus.edu X06 Ng Cheng Yang, Titus titusng@u.nus.edu X07 Wong Zhen Wei e0407196@u.nus.edu X08 Lok Ke Wen kewen.lok@u.nus.edu X09 Hubertus Adhy Pratama Setiawan adhy.setiawan@u.nus.edu X10 Ling Yan Hao lyanhao@comp.nus.edu.sg X11 Song Kai song.kai@u.nus.edu X12 Luo Xinjian xinjian.luo@u.nus.edu Emergency Contact (Examination issues) Zoom Chat (when permission is given by the proctor) If Zoom fails, use MS Teams (when permission is given by the proctor) If Zoom/Teams fail, as a last resort, you may email the instructors/proctors Emergency Contact for Technical Issues Contact NUS IT Online Exam Support via Microsoft Teams here","title":"Midterm"},{"location":"midterm.html#midterm","text":"Visit this page for updates about midterm information.","title":"Midterm"},{"location":"midterm.html#important-information","text":"Date: 27 September 2021 (Monday) Time: 12noon to 2 pm Venue: Online Scope: Units 1-12, Assignments 1-2, Exercises 1-4 Format: MCQs, MRQs, True/False, Fill-in-the-Blank, and Short Structured Questions Duration: 60 minutes Open Book (You can refer to printed/written notes but no online references are allowed) A calculator is allowed","title":"Important Information"},{"location":"midterm.html#practice-paper","text":"To be available on Week 6.","title":"Practice Paper"},{"location":"midterm.html#taking-exam-on-campus","text":"If you wish to take the midterm on campus, please fill up this survey . Note that: We cannot guarantee we will be able to find a sufficiently large and quiet venue for everyone. The midterm will still be taken online. Only the invigilation will be done face-to-face. Once the list of students taking midterm on campus is finalized, it cannot be changed.","title":"Taking Exam on Campus"},{"location":"midterm.html#e-exam-procedure","text":"We adopt the E-exam procedure for the School of Computing for CS1010. This is a long document with a lot of information. Please read through it carefully. Please set up the software and hardware needed for taking e-exams before the test so that your test-taking experience is as smooth as possible. Note the following supplementary information to complete the E-exam procedure above, specific to CS1010.","title":"E-Exam Procedure"},{"location":"midterm.html#121-on-pc","text":"We recommend Penopto for screen recording.","title":"1.2.1. On PC"},{"location":"midterm.html#21-exam-taking-software","text":"We will use Luminus Quiz for the midterm test.","title":"2.1 Exam Taking Software"},{"location":"midterm.html#22-proctoring-protocol","text":"Note that the following applies to CS1010: You are allowed to use only a single screen. If you\u2019re using an external monitor, the laptop screen must be switched off. The browser running LumiNUS Quiz running on your PC must be in full-screen mode. No other tabs are allowed on the browser.","title":"2.2 Proctoring Protocol"},{"location":"midterm.html#24-seeking-clarifications-on-exam-questions","text":"You are allowed to ask clarification questions during the exam. However, you may only ask a boolean yes/no question. For instance, you are not allowed to ask \"What can we assume about the input?\". You should rephrase it as \"Can we assume that the input is always positive?\". Our answers will only be in the form of \"yes\", \"no\", \"no comment\".","title":"2.4. Seeking Clarifications on Exam Questions"},{"location":"midterm.html#25-multi-part-exam","text":"CS1010 midterm is only a single part with no break in between.","title":"2.5. Multi-part Exam"},{"location":"midterm.html#12-screen-recording-software","text":"We recommend Penopto for screen recording.","title":"12. Screen Recording Software"},{"location":"midterm.html#zoom-session-assignment","text":"Zoom session assignment is available internally via LumiNUS Zoom links is now available via Piazza","title":"Zoom Session Assignment"},{"location":"midterm.html#invigilators-and-email-address","text":"1 2 3 4 5 6 7 8 9 10 11 12 X01 Wang Chengxin cwang@u.nus.edu X02 Alvin Heng Jun Ren alvin.heng@u.nus.edu X03 Felix Halim felix@u.nus.edu X04 Tean Wei Jun e0540193@u.nus.edu X05 Liang Yuzhao e0543802@u.nus.edu X06 Ng Cheng Yang, Titus titusng@u.nus.edu X07 Wong Zhen Wei e0407196@u.nus.edu X08 Lok Ke Wen kewen.lok@u.nus.edu X09 Hubertus Adhy Pratama Setiawan adhy.setiawan@u.nus.edu X10 Ling Yan Hao lyanhao@comp.nus.edu.sg X11 Song Kai song.kai@u.nus.edu X12 Luo Xinjian xinjian.luo@u.nus.edu","title":"Invigilators and Email Address"},{"location":"midterm.html#emergency-contact-examination-issues","text":"Zoom Chat (when permission is given by the proctor) If Zoom fails, use MS Teams (when permission is given by the proctor) If Zoom/Teams fail, as a last resort, you may email the instructors/proctors","title":"Emergency Contact (Examination issues)"},{"location":"midterm.html#emergency-contact-for-technical-issues","text":"Contact NUS IT Online Exam Support via Microsoft Teams here","title":"Emergency Contact for Technical Issues"},{"location":"outcomes.html","text":"After taking CS1010, students should be familiar with fundamental programming concepts and methodology (variables, assignments, conditions, branches, loops, functions, recursions, structures); be familiar with and appreciate good programming practice, and apply it to follow-up courses; be able to apply problem-solving knowledge and skills to write small, well-documented, effective C programs; be able to appreciate the use of simple data structure such as array, know their limitations to pave way for more complex data structures in the next course; know the responsibilities of an ethical programmer; be able to write simple programs in the corresponding programming language to solve a task, given the constraints on the inputs; be able to manually trace through a program to identify logical errors; be able to differentiate between logical errors, syntax errors, and run-time errors; be exposed informally to the concept of code specification in the form of comments in the code, explaining what are the expected inputs and outputs and what are the assumptions; know about what are some insecure functions to avoid; be able to generate test cases on their own, with a focus on boundary/special cases; be able to debug with printf or equivalent functions; be aware of common strategies and good practices of debugging with printf or equivalent functions; be able to identify opportunities to, and write, modularized code; be exposed to a debugger; be able to write code following good programming style (clear comments, naming convention, indentation, etc.); understand the different data types and that there exists a representation of each in the memory, as well as the limitation of the representations due to the limited number of bits; develop a simple mental model of how a program is executed (CPU runs the code on data that is stored in memory, function call leads to the creation of call frames, which can explain recursion and variable scoping, etc). For interpreted language, understand the role of virtual machine/interpreter; be able to understand at a high level the compilation process (from pre-processing to compiling to linking), where applicable; understand the concept of reusability and how a software application can be built on top of software libraries/packages (standard or third parties); be able to implement bubble sort and insertion sort; be able to implement linear search and binary search (both iterative and recursive versions);","title":"Learning Outcomes"},{"location":"pe1.html","text":"Practice Exam 1 Basic Info Date: 2 October 2021 (Saturday) Time: 9 am to 12noon (Report to invigilator at 9 am, exam starts at 9:30am) Venue: Online (except those already informed) Scope: Units 1-12, Assignments 1-2, Exercises 1-4 5 programming questions: from very easy to very hard Criteria: correctness and style. There will be one question where efficiency matters. Duration: 2 hours and 30 minutes Open Book (You can refer to printed/written materials, but no online resources are allowed). Practice Paper Exercise 6 Exercise 7 Special Restrictions You will be issued a special account for use on the day of the practical exam. This will be sent to your NUS email account and you will be able to test it during Week 7's lab session. You will need to log into a special set of PE nodes through ssh to solve the exam questions. You are not allowed to use the Internet for other purposes. You are only allowed to (i) interact with the files on the PE nodes through ssh ; and (ii) communicate with the invigilators through Zoom. File transfer into the PE nodes is not allowed. Vim Configuration Your default account will have the same .vimrc as ~cs1010/.vimrc on the CS1010 PE hosts. You are free to edit this during the practical exams. You, however, will not be able to download vim plugins. You can only install from a list of approved vim plugins and installation instructions . After loggin in, you will be given 5 minutes to configure your ~/.vimrc environment and set up allowed plugins. General Advice Save your program regularly. We will use setup every account with ~/.vimrc copied from ~cs1010/.vimrc . Thus, you can find the last saved version of your files under ~/.backup if you accidentally deleted your code. Plan your time properly. Do not spend excessive time on any task. Read through all questions and solved those that you are confident to solve first. There are five questions, from very easy to very hard. Solve as many as you can. I expect most students will be able to solve 3 out of the 5 questions within the time limit. You don't need to solve all questions to deserve an A grade. There is one mark allocated to style for each question. As long as you keep your code clean, neat, and readable, you will get this one mark, almost for free. Review the CS1010 style guide so that you know what is expected in terms of coding style. Don't start typing your code right away. Think about the solution first -- what variables are needed? What is the control flow (using branches and loops)? Draw out the flowchart if it helps. Break down the problem into smaller ones if the problem is too complex to solve. You are not allowed to start typing on the computer until the invigilator announced that you can do so. Just like the assignments, you are not given all the test cases that we will be using during grading. Please test your code against additional test cases, especially for boundary cases. E-Exam Procedure We adopt the E-exam procedure for the School of Computing for CS1010. This is a long document with a lot of information. Please read through it carefully. Please set up the software and hardware needed for taking e-exams before the test so that your test-taking experience is as smooth as possible. Note the following supplementary information to complete the E-exam procedure above, specific to CS1010. 2.1 Exam Taking Software You will use a terminal to ssh into your allocated PE nodes to take the practical exam. You can only access the PE nodes for examination via SoC VPN or through SoC network. 2.2 Proctoring Protocol Note that the following applies to CS1010: You are allowed to use only a single screen. If you\u2019re using an external monitor, the laptop screen must be switched off. The terminal running on your PC must be in full-screen mode. Terminal window/tab other than the one used to connect to the PE nodes are not allowed. You are allowed only one full-screen terminal window. You may use split windows within vim to view the exam questions and your code side-by-side. If you need to switch to other Windows (e.g., Zoom chat to ask question), you need to get permission from the invigilator. 2.4. Seeking Clarifications on Exam Questions You are allowed to ask clarification questions during the exam. However, you may only ask a boolean yes/no question. For instance, you are not allowed to ask \"What can we assume about the input?\". You should rephrase it as \"Can we assume that the input is always positive?\". Our answers will only be in the form of \"yes\", \"no\", \"no comment\". 2.5. Multi-part Exam There is only a single part with no break in between. 12. Screen Recording Software We recommend Penopto for screen recording. Zoom Session Assignment Zoom session assignment is available internally via LumiNUS Zoom links to be made available via Piazza (two days before the PE1) Invigilators and Email Address 1 2 3 4 5 6 7 8 9 10 11 12 X01 Guo Ai guo.ai@u.nus.edu X02 Luo Xinjian xinjian.luo@u.nus.edu X03 Alvin Heng alvin.heng@u.nus.edu X04 Song Kai song.kai@u.nus.edu X05 Eric Bryan e0555789@u.nus.edu X06 Tean Wei Jun e0540193@u.nus.edu X07 Liang Yuzhao e0543802@u.nus.edu X08 Felix Halim e0407645@u.nus.edu X09 Xia Fuxi e0426189@u.nus.edu X10 Ling Yan Hao e0174827@u.nus.edu X11 Adi Nata e0425080@u.nus.edu X12 Wang ChengXin e0673190@u.nus.edu Emergency Contact (Examination issues) Zoom Chat (when permission is given by the proctor) If Zoom fails, use MS Teams (when permission is given by the proctor) If Zoom/Teams fail, as a last resort, you may email the instructors/proctors Emergency Contact (Technical Issues) School of Computing - Technical Services Telephone: 6516 2736 Email: techsvc@comp.nus.edu.sg Emergency Telephone: 6874 2736 (available only during emergencies and network outages)","title":"PE1"},{"location":"pe1.html#practice-exam-1","text":"","title":"Practice Exam 1"},{"location":"pe1.html#basic-info","text":"Date: 2 October 2021 (Saturday) Time: 9 am to 12noon (Report to invigilator at 9 am, exam starts at 9:30am) Venue: Online (except those already informed) Scope: Units 1-12, Assignments 1-2, Exercises 1-4 5 programming questions: from very easy to very hard Criteria: correctness and style. There will be one question where efficiency matters. Duration: 2 hours and 30 minutes Open Book (You can refer to printed/written materials, but no online resources are allowed).","title":"Basic Info"},{"location":"pe1.html#practice-paper","text":"Exercise 6 Exercise 7","title":"Practice Paper"},{"location":"pe1.html#special-restrictions","text":"You will be issued a special account for use on the day of the practical exam. This will be sent to your NUS email account and you will be able to test it during Week 7's lab session. You will need to log into a special set of PE nodes through ssh to solve the exam questions. You are not allowed to use the Internet for other purposes. You are only allowed to (i) interact with the files on the PE nodes through ssh ; and (ii) communicate with the invigilators through Zoom. File transfer into the PE nodes is not allowed.","title":"Special Restrictions"},{"location":"pe1.html#vim-configuration","text":"Your default account will have the same .vimrc as ~cs1010/.vimrc on the CS1010 PE hosts. You are free to edit this during the practical exams. You, however, will not be able to download vim plugins. You can only install from a list of approved vim plugins and installation instructions . After loggin in, you will be given 5 minutes to configure your ~/.vimrc environment and set up allowed plugins.","title":"Vim Configuration"},{"location":"pe1.html#general-advice","text":"Save your program regularly. We will use setup every account with ~/.vimrc copied from ~cs1010/.vimrc . Thus, you can find the last saved version of your files under ~/.backup if you accidentally deleted your code. Plan your time properly. Do not spend excessive time on any task. Read through all questions and solved those that you are confident to solve first. There are five questions, from very easy to very hard. Solve as many as you can. I expect most students will be able to solve 3 out of the 5 questions within the time limit. You don't need to solve all questions to deserve an A grade. There is one mark allocated to style for each question. As long as you keep your code clean, neat, and readable, you will get this one mark, almost for free. Review the CS1010 style guide so that you know what is expected in terms of coding style. Don't start typing your code right away. Think about the solution first -- what variables are needed? What is the control flow (using branches and loops)? Draw out the flowchart if it helps. Break down the problem into smaller ones if the problem is too complex to solve. You are not allowed to start typing on the computer until the invigilator announced that you can do so. Just like the assignments, you are not given all the test cases that we will be using during grading. Please test your code against additional test cases, especially for boundary cases.","title":"General Advice"},{"location":"pe1.html#e-exam-procedure","text":"We adopt the E-exam procedure for the School of Computing for CS1010. This is a long document with a lot of information. Please read through it carefully. Please set up the software and hardware needed for taking e-exams before the test so that your test-taking experience is as smooth as possible. Note the following supplementary information to complete the E-exam procedure above, specific to CS1010.","title":"E-Exam Procedure"},{"location":"pe1.html#21-exam-taking-software","text":"You will use a terminal to ssh into your allocated PE nodes to take the practical exam. You can only access the PE nodes for examination via SoC VPN or through SoC network.","title":"2.1 Exam Taking Software"},{"location":"pe1.html#22-proctoring-protocol","text":"Note that the following applies to CS1010: You are allowed to use only a single screen. If you\u2019re using an external monitor, the laptop screen must be switched off. The terminal running on your PC must be in full-screen mode. Terminal window/tab other than the one used to connect to the PE nodes are not allowed. You are allowed only one full-screen terminal window. You may use split windows within vim to view the exam questions and your code side-by-side. If you need to switch to other Windows (e.g., Zoom chat to ask question), you need to get permission from the invigilator.","title":"2.2 Proctoring Protocol"},{"location":"pe1.html#24-seeking-clarifications-on-exam-questions","text":"You are allowed to ask clarification questions during the exam. However, you may only ask a boolean yes/no question. For instance, you are not allowed to ask \"What can we assume about the input?\". You should rephrase it as \"Can we assume that the input is always positive?\". Our answers will only be in the form of \"yes\", \"no\", \"no comment\".","title":"2.4. Seeking Clarifications on Exam Questions"},{"location":"pe1.html#25-multi-part-exam","text":"There is only a single part with no break in between.","title":"2.5. Multi-part Exam"},{"location":"pe1.html#12-screen-recording-software","text":"We recommend Penopto for screen recording.","title":"12. Screen Recording Software"},{"location":"pe1.html#zoom-session-assignment","text":"Zoom session assignment is available internally via LumiNUS Zoom links to be made available via Piazza (two days before the PE1)","title":"Zoom Session Assignment"},{"location":"pe1.html#invigilators-and-email-address","text":"1 2 3 4 5 6 7 8 9 10 11 12 X01 Guo Ai guo.ai@u.nus.edu X02 Luo Xinjian xinjian.luo@u.nus.edu X03 Alvin Heng alvin.heng@u.nus.edu X04 Song Kai song.kai@u.nus.edu X05 Eric Bryan e0555789@u.nus.edu X06 Tean Wei Jun e0540193@u.nus.edu X07 Liang Yuzhao e0543802@u.nus.edu X08 Felix Halim e0407645@u.nus.edu X09 Xia Fuxi e0426189@u.nus.edu X10 Ling Yan Hao e0174827@u.nus.edu X11 Adi Nata e0425080@u.nus.edu X12 Wang ChengXin e0673190@u.nus.edu","title":"Invigilators and Email Address"},{"location":"pe1.html#emergency-contact-examination-issues","text":"Zoom Chat (when permission is given by the proctor) If Zoom fails, use MS Teams (when permission is given by the proctor) If Zoom/Teams fail, as a last resort, you may email the instructors/proctors","title":"Emergency Contact (Examination issues)"},{"location":"pe1.html#emergency-contact-technical-issues","text":"School of Computing - Technical Services Telephone: 6516 2736 Email: techsvc@comp.nus.edu.sg Emergency Telephone: 6874 2736 (available only during emergencies and network outages)","title":"Emergency Contact (Technical Issues)"},{"location":"pe2.html","text":"Practice Exam 2 Basic Info Date: 7 November 2020 (Saturday) Time: 9 am to 12noon (Report to invigilator at 9 am, exam starts at 9:30am) Venue: Online Scope: Units 1-27, Assignments 1-8, Tutorials 1-10 5 programming questions: from very easy to very hard Criteria: correctness, style, efficiency, and documentation. These are applied differently to different question (e.g., efficiency is important only for some questions, documentation is required only for some questions). Duration: 2 hours and 30 minutes Open Book (You can refer to printed/written materials, but no online resources are allowed). Special Restrictions You will be issued a special account for use on the day of the practical exam. This will been sent to your NUS email account and you should will get a chance to test it during Thursday's tutorial session. You will need to log into a special set of PE nodes through ssh to solve the exam questions. You are not allowed to use the Internet for other purposes. You are only allowed to (i) interact with the files on the PE nodes through ssh ; and (ii) communicate with the invigilators through Zoom. File transfer into the PE nodes is not allowed. Vim Configuration Your default account will have the same .vimrc as ~cs1010/.vimrc on the CS1010 PE hosts. You are free to edit this during the practical exams. You, however, will not be able to download nor install vim plugins. E-Exam Procedure We adopt the E-exam procedure for the School of Computing for CS1010. This is a long document with a lot of information. Please read through it carefully. Please set up the software and hardware needed for taking e-exams before the test so that your test-taking experience is as smooth as possible. Note the following supplementary information to complete the E-exam procedure above, specific to CS1010. 2.1 Exam Taking Software You will use a terminal to ssh into your allocated PE nodes to take the practical exam. 1 You can only access the PE nodes for examination through either SoC VPN or tunnels through sunfire. 2.2 Proctoring Protocol Note that the following applies to CS1010: You are allowed to use only a single screen. If you\u2019re using an external monitor, the laptop screen must be switched off. The terminal running on your PC must be in full-screen mode. Terminal window/tab other than the one used to connect to the PE nodes are not allowed. You are allowed only one full-screen terminal window. You may use split windows within vim to view the exam questions and your code side-by-side. If you need to switch to other Windows (e.g., Zoom chat to ask question), you need to get permission from the invigilator. Do note that failure to comply with proctoring requirements may require you to retake PE2 2.4. Seeking Clarifications on Exam Questions You are allowed to ask clarification questions during the exam. However, you may only ask a boolean yes/no question. For instance, you are not allowed to ask \"What can we assume about the input?\". You should rephrase it as \"Can we assume that the input is always positive?\". Our answers will only be in the form of \"yes\", \"no\", \"no comment\". 2.5. Multi-part Exam There is only a single part with no break in between. 9.6. Completion of Exam The folder to submit the your recording to is LumiNUS> CS1010 > Files > PE2 Screen Capture Video Submission. You should submit it no later than 7 November 2020, 2359. Note that failure to submit equates to you not being proctored for Practical Examination 2. Zoom Session Assignment Group assignment is available on Luminus. Zoom sessions are available on Piazza Invigilators TBD Emergency Contact (Examination issues) Zoom Chat (when permission is given by the proctor) If Zoom fails, MS Teams (when permission is given by the proctor) If Zoom/Teams fail, as a last resort, you may email the instructors/proctors Find Proctor and Instructor Email Information on LumiNUS > CS1010 > Module Details > Facilitators (Top Menu) (note down the email before the exam in case Luminus fails) Emergency Contact for Technical Issues School of Computing - Technical Services Telephone: 6516 2736 Email: techsvc@comp.nus.edu.sg Emergency Telephone: 6874 2736 (available only during emergencies and network outages) General Advice Save your program regularly. We will use setup every account with ~/.vimrc copied from ~cs1010/.vimrc . Thus, you can find the last saved version of your files under ~/.backup if you accidentally deleted your code. Plan your time properly. Do not spend excessive time on any task. Read through all questions and solved those that you are confident to solve first. There are five questions, from very easy to very hard. Solve as many as you can. I expect most students will be able to solve 3 out of the 5 questions within the time limit. There is one mark allocated to style for each question. As long as you keep your code clean, neat, and readable, you will get this one mark, almost for free. Review the CS1010 style guide so that you know what is expected in terms of coding style. Don't start typing your code right away. Think about the solution first -- what variables are needed? What is the control flow (using branches and loops)? Draw out the flowchart if it helps. Break down the problem into smaller ones if the problem is too complex to solve. You are not allowed to start typing on the computer until the invigilator announced that you can do so. Just like the assignments, you are not given all the test cases that we will be using during grading. Please test your code against additional test cases, especially for boundary cases. Practice Paper You can use the PE question from 18/19 Semester 1 as the practice paper. Download the question paper Accept the assignment on GitHub Run ~cs1010/get-pe19 on any PE host to get the skeleton code and test cases Run ~cs1010/submit-pe19 to submit/archive your solution on GitHub","title":"Practice Exam 2"},{"location":"pe2.html#practice-exam-2","text":"","title":"Practice Exam 2"},{"location":"pe2.html#basic-info","text":"Date: 7 November 2020 (Saturday) Time: 9 am to 12noon (Report to invigilator at 9 am, exam starts at 9:30am) Venue: Online Scope: Units 1-27, Assignments 1-8, Tutorials 1-10 5 programming questions: from very easy to very hard Criteria: correctness, style, efficiency, and documentation. These are applied differently to different question (e.g., efficiency is important only for some questions, documentation is required only for some questions). Duration: 2 hours and 30 minutes Open Book (You can refer to printed/written materials, but no online resources are allowed).","title":"Basic Info"},{"location":"pe2.html#special-restrictions","text":"You will be issued a special account for use on the day of the practical exam. This will been sent to your NUS email account and you should will get a chance to test it during Thursday's tutorial session. You will need to log into a special set of PE nodes through ssh to solve the exam questions. You are not allowed to use the Internet for other purposes. You are only allowed to (i) interact with the files on the PE nodes through ssh ; and (ii) communicate with the invigilators through Zoom. File transfer into the PE nodes is not allowed.","title":"Special Restrictions"},{"location":"pe2.html#vim-configuration","text":"Your default account will have the same .vimrc as ~cs1010/.vimrc on the CS1010 PE hosts. You are free to edit this during the practical exams. You, however, will not be able to download nor install vim plugins.","title":"Vim Configuration"},{"location":"pe2.html#e-exam-procedure","text":"We adopt the E-exam procedure for the School of Computing for CS1010. This is a long document with a lot of information. Please read through it carefully. Please set up the software and hardware needed for taking e-exams before the test so that your test-taking experience is as smooth as possible. Note the following supplementary information to complete the E-exam procedure above, specific to CS1010.","title":"E-Exam Procedure"},{"location":"pe2.html#21-exam-taking-software","text":"You will use a terminal to ssh into your allocated PE nodes to take the practical exam. 1 You can only access the PE nodes for examination through either SoC VPN or tunnels through sunfire.","title":"2.1 Exam Taking Software"},{"location":"pe2.html#22-proctoring-protocol","text":"Note that the following applies to CS1010: You are allowed to use only a single screen. If you\u2019re using an external monitor, the laptop screen must be switched off. The terminal running on your PC must be in full-screen mode. Terminal window/tab other than the one used to connect to the PE nodes are not allowed. You are allowed only one full-screen terminal window. You may use split windows within vim to view the exam questions and your code side-by-side. If you need to switch to other Windows (e.g., Zoom chat to ask question), you need to get permission from the invigilator. Do note that failure to comply with proctoring requirements may require you to retake PE2","title":"2.2 Proctoring Protocol"},{"location":"pe2.html#24-seeking-clarifications-on-exam-questions","text":"You are allowed to ask clarification questions during the exam. However, you may only ask a boolean yes/no question. For instance, you are not allowed to ask \"What can we assume about the input?\". You should rephrase it as \"Can we assume that the input is always positive?\". Our answers will only be in the form of \"yes\", \"no\", \"no comment\".","title":"2.4. Seeking Clarifications on Exam Questions"},{"location":"pe2.html#25-multi-part-exam","text":"There is only a single part with no break in between.","title":"2.5. Multi-part Exam"},{"location":"pe2.html#96-completion-of-exam","text":"The folder to submit the your recording to is LumiNUS> CS1010 > Files > PE2 Screen Capture Video Submission. You should submit it no later than 7 November 2020, 2359. Note that failure to submit equates to you not being proctored for Practical Examination 2.","title":"9.6. Completion of Exam"},{"location":"pe2.html#zoom-session-assignment","text":"Group assignment is available on Luminus. Zoom sessions are available on Piazza","title":"Zoom Session Assignment"},{"location":"pe2.html#invigilators","text":"TBD","title":"Invigilators"},{"location":"pe2.html#emergency-contact-examination-issues","text":"Zoom Chat (when permission is given by the proctor) If Zoom fails, MS Teams (when permission is given by the proctor) If Zoom/Teams fail, as a last resort, you may email the instructors/proctors Find Proctor and Instructor Email Information on LumiNUS > CS1010 > Module Details > Facilitators (Top Menu) (note down the email before the exam in case Luminus fails)","title":"Emergency Contact (Examination issues)"},{"location":"pe2.html#emergency-contact-for-technical-issues","text":"School of Computing - Technical Services Telephone: 6516 2736 Email: techsvc@comp.nus.edu.sg Emergency Telephone: 6874 2736 (available only during emergencies and network outages)","title":"Emergency Contact for Technical Issues"},{"location":"pe2.html#general-advice","text":"Save your program regularly. We will use setup every account with ~/.vimrc copied from ~cs1010/.vimrc . Thus, you can find the last saved version of your files under ~/.backup if you accidentally deleted your code. Plan your time properly. Do not spend excessive time on any task. Read through all questions and solved those that you are confident to solve first. There are five questions, from very easy to very hard. Solve as many as you can. I expect most students will be able to solve 3 out of the 5 questions within the time limit. There is one mark allocated to style for each question. As long as you keep your code clean, neat, and readable, you will get this one mark, almost for free. Review the CS1010 style guide so that you know what is expected in terms of coding style. Don't start typing your code right away. Think about the solution first -- what variables are needed? What is the control flow (using branches and loops)? Draw out the flowchart if it helps. Break down the problem into smaller ones if the problem is too complex to solve. You are not allowed to start typing on the computer until the invigilator announced that you can do so. Just like the assignments, you are not given all the test cases that we will be using during grading. Please test your code against additional test cases, especially for boundary cases.","title":"General Advice"},{"location":"pe2.html#practice-paper","text":"You can use the PE question from 18/19 Semester 1 as the practice paper. Download the question paper Accept the assignment on GitHub Run ~cs1010/get-pe19 on any PE host to get the skeleton code and test cases Run ~cs1010/submit-pe19 to submit/archive your solution on GitHub","title":"Practice Paper"},{"location":"policies.html","text":"Policies Email Communication Piazza is the preferred platform if you have questions to ask or issues to raise (either publicly to your classmates or privately to the instructors). But if you must use email, please use only your official NUS email for communication with the teaching staff -- either the one with @u.nus.edu or @comp.nus.edu.sg . Prefix your email subject with [CS1010] . If you email us privately and we feel that your questions/answers are useful to the rest of the class, we will publish it on Piazza, with anonymization when appropriate. Tutorial and Lab Sessions Attendance is not compulsory at NUS, but we do take attendance during the tutorial and lab sessions for contract tracing purposes. You should stick to your allocated time slot for labs and tutorials. If there is a strong reason for you to attend another session, please inform your tutor. Late Submissions All programming assignments must be submitted on time. If you need an extension, please ask for one and provide a justification for approval. Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not). For late submission, there is a 1% penalty (of the total assessment grade) for every 5-minutes after the deadline, capped at 80%. For example, if an assessment that was given 40 marks was submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty). If it is submitted 10 hours after the deadline, the student will get 8 marks (as the cap of 80% penalty has been reached). No submission will be accepted a week after the deadline. Discussions and Plagiarism We encourage discussions among students for programming assignments, but each student should be responsible for writing his/her own code and should give credits to others when appropriate. NUS and School of Computing have a high standard of academic honesty and take any violation seriously. In the context of computing modules, source code plagiarism -- copying code from another source and attributing it as one's own code -- is a serious violation. Please read the page Preventing Plagiarism from the school's website to familiarize yourself with the policy. I adopt a \"no mercy\" policy when it comes to disciplinary action on plagiarism. Both parties, the student who copied, and the student who allowed others to copy, will be penalized equally. Lecture Video The recorded zoom video will be recorded and posted online 1-2 days after the lecture. This will be done on a 'best effort' basis and lecture video will not be guaranteed to be available on time or at all. Posting of video lecture is meant to help students who attended the lecture to recap the content or to help those who are not able to attend the lecture due to unexpected circumstances. It does not mean that you should skip the lecture. Research has shown that the effect of over-reliance on lecture video is negative. Model Solutions and Slides Slides will be posted after the class. Note that slides are used as a visual aid to assist me during the lectures. It is not meant as a summary of lectures nor a replacement of lecture notes. In a module like CS1010, there is often not a single correct answer. Hence, there is no model solution for this module. Sample solutions may be posted (both good and bad ones) for discussion. I strongly encourage students to discuss your solution with the teaching team, instead of just comparing your solution with the sample solution. Grading Students will receive the grades they deserve irrespective of how the other students in the class perform (i.e., no bell curve). In other words, the number of As and Fs will not be artificially capped. Open Book Assessment All assessment, including practical exams, midterm test, and final assessment, are open book assessment -- you can bring in your notes or other analog reference materials. There is nothing to memorize for this class.","title":"Policies"},{"location":"policies.html#policies","text":"","title":"Policies"},{"location":"policies.html#email-communication","text":"Piazza is the preferred platform if you have questions to ask or issues to raise (either publicly to your classmates or privately to the instructors). But if you must use email, please use only your official NUS email for communication with the teaching staff -- either the one with @u.nus.edu or @comp.nus.edu.sg . Prefix your email subject with [CS1010] . If you email us privately and we feel that your questions/answers are useful to the rest of the class, we will publish it on Piazza, with anonymization when appropriate.","title":"Email Communication"},{"location":"policies.html#tutorial-and-lab-sessions","text":"Attendance is not compulsory at NUS, but we do take attendance during the tutorial and lab sessions for contract tracing purposes. You should stick to your allocated time slot for labs and tutorials. If there is a strong reason for you to attend another session, please inform your tutor.","title":"Tutorial and Lab Sessions"},{"location":"policies.html#late-submissions","text":"All programming assignments must be submitted on time. If you need an extension, please ask for one and provide a justification for approval. Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not). For late submission, there is a 1% penalty (of the total assessment grade) for every 5-minutes after the deadline, capped at 80%. For example, if an assessment that was given 40 marks was submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty). If it is submitted 10 hours after the deadline, the student will get 8 marks (as the cap of 80% penalty has been reached). No submission will be accepted a week after the deadline.","title":"Late Submissions"},{"location":"policies.html#discussions-and-plagiarism","text":"We encourage discussions among students for programming assignments, but each student should be responsible for writing his/her own code and should give credits to others when appropriate. NUS and School of Computing have a high standard of academic honesty and take any violation seriously. In the context of computing modules, source code plagiarism -- copying code from another source and attributing it as one's own code -- is a serious violation. Please read the page Preventing Plagiarism from the school's website to familiarize yourself with the policy. I adopt a \"no mercy\" policy when it comes to disciplinary action on plagiarism. Both parties, the student who copied, and the student who allowed others to copy, will be penalized equally.","title":"Discussions and Plagiarism"},{"location":"policies.html#lecture-video","text":"The recorded zoom video will be recorded and posted online 1-2 days after the lecture. This will be done on a 'best effort' basis and lecture video will not be guaranteed to be available on time or at all. Posting of video lecture is meant to help students who attended the lecture to recap the content or to help those who are not able to attend the lecture due to unexpected circumstances. It does not mean that you should skip the lecture. Research has shown that the effect of over-reliance on lecture video is negative.","title":"Lecture Video"},{"location":"policies.html#model-solutions-and-slides","text":"Slides will be posted after the class. Note that slides are used as a visual aid to assist me during the lectures. It is not meant as a summary of lectures nor a replacement of lecture notes. In a module like CS1010, there is often not a single correct answer. Hence, there is no model solution for this module. Sample solutions may be posted (both good and bad ones) for discussion. I strongly encourage students to discuss your solution with the teaching team, instead of just comparing your solution with the sample solution.","title":"Model Solutions and Slides"},{"location":"policies.html#grading","text":"Students will receive the grades they deserve irrespective of how the other students in the class perform (i.e., no bell curve). In other words, the number of As and Fs will not be artificially capped.","title":"Grading"},{"location":"policies.html#open-book-assessment","text":"All assessment, including practical exams, midterm test, and final assessment, are open book assessment -- you can bring in your notes or other analog reference materials. There is nothing to memorize for this class.","title":"Open Book Assessment"},{"location":"readings.html","text":"Readings Must Read How NOT to Go About a Programming Assignment , by Agustin Cernuda del Rio. Computer programming students invariably fall into more than one bad habit. It can be extremely difficult to eradicate them (and many lecturers and professional programmers keep succumbing to them time and again).. Best Teacher I Ever Had , by David Owen. Mr. Whitson taught sixth-grade science. On the first day of class, he gave us a lecture about a creature called the cattywampus, .. Why C? Learn C programming and the rest will come, by Marty Jacobs The Resurgence of C Programming, by Mark Barlow You Can't Dig Upwards, by Evan Miller Vim Time to Drop Emacs and Vi? on StackOverflow. \" Programmers are notorious for using the tools that helps them get the job done in the most efficient way possible. These editors are ancient yet still being used because they are good, solid editors, proven by time. If they get the job done and get the job done well, why should we drop them in favor of something else? \" What are the benefits of learning Vim? on Stack Overflow. \" Usually vim's killer features are considered: A) that it's available on pretty much every Unix you'll ever encounter and B) your fingers very rarely have to leave the home row, which means you'll be able to edit text very, very quickly. It's also usually very fast and lightweight even when editing huge files. \" Learn vim Progressively \" I suggest you teach yourself Vim in 4 steps: 1. Survive. 2. Feel comfortable. 3. Feel Better, Stronger, Faster. 4. Use superpowers of vim \" Where Vim Came From -- from TwoBitHistory. \" Perhaps more importantly, while we\u2019re asking questions, why does exiting Vim involve typing :wq? Sure, it\u2019s a \u201cwrite\u201d operation followed by a \u201cquit\u201d operation, but that is not a particularly intuitive convention. Who decided that copying text should instead be called \u201cyanking\u201d? Why is :%s/foo/bar/gc short for \u201cfind and replace\u201d? Vim\u2019s idiosyncrasies seem too arbitrary to have been made up, but then where did they come from?\" Vim's Big Idea - by Mike Kozlowski. \"This philosophy of minimalist commands that can be composed together is the fundamental originating philosophy of Unix, and Vim exemplifies it like no other editor.\" VIM Pays Excellent Dividends - by John Bjorn Nelson. \"Being conservative, let\u2019s say it makes you 5% more productive. More specifically\u200a\u2014\u200aonce your brain maps the keystrokes to muscle memory\u200a\u2014\u200ait makes you 5% faster at completing the mundane tasks\u2026the ones which dominate programming. That added productivity snowballs. It\u2019s an extra twenty minutes a day to build or explore (or learn), that used to go to copy/paste-like operations.\" The Powers of VIM - by Artem Dudarev The 11 Steps to Learning Vim - by damassi . \"Regardless of the initial confusion and difficulty in getting started, you're making your future developer self immensely more productive by diving in and taking the plunge. Seriously. I'm just a few weeks in right now and I can positively say that learning Vim has been the best work-related decision of my life. It's fun, and in the strangest of ways it makes you think better.\" Vim for People Who Think Things like Vim and Weird and Hard - by Harry Roberts . \"the fact that, yes, people still use an editor that is over 20 years old (in turn based on a tool from the 70s), and those people number in the hundreds of thousands, perhaps they might be onto something.\" Why I use Vim - Pascal Precht. \"once I was able to do some basic operations in Vim and actually started working again, I made almost as twice as much progress at work in about half the time. I know that sounds kind of crazy but I\u2019m serious. And that convinced me that I made the right choice. So, do yourself a favor and climb that mountain. Just remember that you can slide down afterwards.\" Vim Video Tutorial (from Aaron Tan) Lesson 1 Lesson 2 Lesson 3 Lesson 4","title":"Readings"},{"location":"readings.html#readings","text":"","title":"Readings"},{"location":"readings.html#must-read","text":"How NOT to Go About a Programming Assignment , by Agustin Cernuda del Rio. Computer programming students invariably fall into more than one bad habit. It can be extremely difficult to eradicate them (and many lecturers and professional programmers keep succumbing to them time and again).. Best Teacher I Ever Had , by David Owen. Mr. Whitson taught sixth-grade science. On the first day of class, he gave us a lecture about a creature called the cattywampus, ..","title":"Must Read"},{"location":"readings.html#why-c","text":"Learn C programming and the rest will come, by Marty Jacobs The Resurgence of C Programming, by Mark Barlow You Can't Dig Upwards, by Evan Miller","title":"Why C?"},{"location":"readings.html#vim","text":"Time to Drop Emacs and Vi? on StackOverflow. \" Programmers are notorious for using the tools that helps them get the job done in the most efficient way possible. These editors are ancient yet still being used because they are good, solid editors, proven by time. If they get the job done and get the job done well, why should we drop them in favor of something else? \" What are the benefits of learning Vim? on Stack Overflow. \" Usually vim's killer features are considered: A) that it's available on pretty much every Unix you'll ever encounter and B) your fingers very rarely have to leave the home row, which means you'll be able to edit text very, very quickly. It's also usually very fast and lightweight even when editing huge files. \" Learn vim Progressively \" I suggest you teach yourself Vim in 4 steps: 1. Survive. 2. Feel comfortable. 3. Feel Better, Stronger, Faster. 4. Use superpowers of vim \" Where Vim Came From -- from TwoBitHistory. \" Perhaps more importantly, while we\u2019re asking questions, why does exiting Vim involve typing :wq? Sure, it\u2019s a \u201cwrite\u201d operation followed by a \u201cquit\u201d operation, but that is not a particularly intuitive convention. Who decided that copying text should instead be called \u201cyanking\u201d? Why is :%s/foo/bar/gc short for \u201cfind and replace\u201d? Vim\u2019s idiosyncrasies seem too arbitrary to have been made up, but then where did they come from?\" Vim's Big Idea - by Mike Kozlowski. \"This philosophy of minimalist commands that can be composed together is the fundamental originating philosophy of Unix, and Vim exemplifies it like no other editor.\" VIM Pays Excellent Dividends - by John Bjorn Nelson. \"Being conservative, let\u2019s say it makes you 5% more productive. More specifically\u200a\u2014\u200aonce your brain maps the keystrokes to muscle memory\u200a\u2014\u200ait makes you 5% faster at completing the mundane tasks\u2026the ones which dominate programming. That added productivity snowballs. It\u2019s an extra twenty minutes a day to build or explore (or learn), that used to go to copy/paste-like operations.\" The Powers of VIM - by Artem Dudarev The 11 Steps to Learning Vim - by damassi . \"Regardless of the initial confusion and difficulty in getting started, you're making your future developer self immensely more productive by diving in and taking the plunge. Seriously. I'm just a few weeks in right now and I can positively say that learning Vim has been the best work-related decision of my life. It's fun, and in the strangest of ways it makes you think better.\" Vim for People Who Think Things like Vim and Weird and Hard - by Harry Roberts . \"the fact that, yes, people still use an editor that is over 20 years old (in turn based on a tool from the 70s), and those people number in the hundreds of thousands, perhaps they might be onto something.\" Why I use Vim - Pascal Precht. \"once I was able to do some basic operations in Vim and actually started working again, I made almost as twice as much progress at work in about half the time. I know that sounds kind of crazy but I\u2019m serious. And that convinced me that I made the right choice. So, do yourself a favor and climb that mountain. Just remember that you can slide down afterwards.\"","title":"Vim"},{"location":"readings.html#vim-video-tutorial-from-aaron-tan","text":"Lesson 1 Lesson 2 Lesson 3 Lesson 4","title":"Vim Video Tutorial (from Aaron Tan)"},{"location":"schedule.html","text":"Schedule This is the schedule for CS1010. Note: Assignments are released on Thursday and due the following Tuesday 23:59. Catch-up sessions are optional review + Q&A sessions meant for students who need time to recap and catch up. They are held on Saturday morning 10 am to 12noon Practical exams are held on Saturday morning from 9 am to 12noon Midterm is held during the lecture slot. The topics covered are tentative. Class Activities Week Starting.. Topics Assignment Catch Up Session / Practical Exam 1 2021-08-09 Computational Problem Solving 2 2021-08-16 Functions & Types 3 2021-08-23 Basic C programs CU1 4 2021-08-30 Conditionals AS1 5 2021-09-06 Loops AS2 6 2021-09-13 Memory, Array, Strings AS3 CU2 - 2021-09-20 Break 7 2021-09-27 Midterm AS4 PE1 8 2021-10-04 Call-by-Referece, nD-Array AS5 9 2021-10-11 Efficiency, Macro AS6 10 2021-10-18 Searching and Sorting AS7 CU3 11 2021-10-25 More recursion AS8 12 2021-11-01 Struct and I/O AS9 PE2 13 2021-11-08 Recap CU4","title":"Schedule"},{"location":"schedule.html#schedule","text":"This is the schedule for CS1010. Note: Assignments are released on Thursday and due the following Tuesday 23:59. Catch-up sessions are optional review + Q&A sessions meant for students who need time to recap and catch up. They are held on Saturday morning 10 am to 12noon Practical exams are held on Saturday morning from 9 am to 12noon Midterm is held during the lecture slot. The topics covered are tentative.","title":"Schedule"},{"location":"schedule.html#class-activities","text":"Week Starting.. Topics Assignment Catch Up Session / Practical Exam 1 2021-08-09 Computational Problem Solving 2 2021-08-16 Functions & Types 3 2021-08-23 Basic C programs CU1 4 2021-08-30 Conditionals AS1 5 2021-09-06 Loops AS2 6 2021-09-13 Memory, Array, Strings AS3 CU2 - 2021-09-20 Break 7 2021-09-27 Midterm AS4 PE1 8 2021-10-04 Call-by-Referece, nD-Array AS5 9 2021-10-11 Efficiency, Macro AS6 10 2021-10-18 Searching and Sorting AS7 CU3 11 2021-10-25 More recursion AS8 12 2021-11-01 Struct and I/O AS9 PE2 13 2021-11-08 Recap CU4","title":"Class Activities"},{"location":"style.html","text":"CS1010 C Style In CS1010, you should following the following style guide when you write your code for your graded homework and practical exams. We typically allocate a few marks for coding style (each assignment/exam may have different allocation). You will lose marks for violation of style. This guide is modified from past CS1010 style guide by Aaron Tan. Why Coding Style is Important Quote \"It is not merely a matter of aesthetics that programs should be written in a particular style. Rather there is a psychological basis for writing programs in a conventional manner: programmers have strong expectations that other programmers will follow these discourse rules. If the rules are violated, then the utility afforded by the expectations that programmers have built up over time is effectively nullified. The results from the experiments with novice and advanced student programmers and with professional programmers described in this paper provide clear support for these claims.\" Elliot Soloway and Kate Ehrlich. \"Empirical studies of programming knowledge.\" IEEE Transactions on Software Engineering 5 (1984): 595-609. 1. Variable Declaration Each variable should be declared in its own line. 1 2 double weight ; // The weight of the baby double height ; // The height of the baby Avoid 1 double weight , height ; // Weight and height of the baby 2. Give Variables Descriptive Names This is the most important rule to follow. The name of a type, variable, function, constant should inform us of its purpose clearly without the readers having to guess or look up its meaning. For example, int number_of_coins; is an appropriate variable but not int c; . Avoid using a single character for variable names. There are some exceptions, however, as shown below: If the variable is the problem size and it is given in the task statement. For example, a problem dealing with n values, hence the variable may be called n (preferably with a comment to explain). If the variable is a transient/temporary variable whose purpose is clear. -If the variable is a loop variable whose purpose is clear. 3. Shorten Variable Names with Naming Conventions Despite the recommendation for descriptive names, identifiers can be short yet descriptive by using abbreviations and/or common naming conventions. For example, MAX_LEN , num_of_elems , pcurr , table_num . However, do not invent your own abbreviation. For instance, names like nm_elemnts should be avoided. 4. Avoid Negated Variable or Function Names Negated variables often result in hard-to-read double-negatives in an expression like !is_not_err . So, avoid is_not_error , is_not_found , is_not_valid , cannot_open_file . Instead, we prefer is_error , is_found , is_valid , can_open_file etc. 5. Use #define to Define Constants for Magic Numbers Avoid direct use of magic numbers. Constant literals which have special meanings should be named and its named identifier should be used in its place. For example: Avoid: 1 2 3 for ( i = 0 ; i < 100 ; i += 1 ) { : } Prefer: 1 2 3 4 5 #define MAX_LEN 100 : for (i = 0; i < MAX_LEN; i += 1) { : } 6. Naming Conventions Constants All constant identifiers must be written in all caps and separated by an underscore _ . For instance MAX_ITERATIONS , MAX_LEN , GOLDEN_RATIO , COLOR_DEFAULT , PI . Variables and Functions Use lower case letters for variable names and function names, with multiple words separated by underscore _ . Example, cs1010_read_long , is_prime . 7. Use Consistent Indentation to Emphasize Block Structure The code should be properly and neatly indented to emphasize the nested logical structure of the program. An indentation of 2 or 4 spaces is recommended (8 is too wide). Every block that follows a for , while , if-else , do-while statement must be indented from its enclosing block. Comments within a block should follow the indentation level of its enclosing block. For example, 1 2 3 4 5 6 7 for ( i = 0 ; i < 3 ; i += 1 ) { // Comments should be indented too while ( j != i ) { // More indented comments printf ( \"Hello \\n \" ); } } The following are the wrong ways to indent the comments. 1 2 3 4 5 6 7 for ( i = 0 ; i < 3 ; i += 1 ) { // This comment should be indented and aligned with the while statement. while ( j != i ) { // This comment should be aligned with the printf statement. printf ( \"Hello \\n \" ); } } 8. Don't Mix Tabs and Spaces You must use only spaces in your code. Do not use tabs. You can add the configuration set expandtab to automatically expand any tab that you enter into spaces. 9. Spaces in if , else , for , while , do - while Statements Add a single space between the keywords if , else , for , while and the following parentheses and between the parentheses and next curly bracket. For instance: 1 2 3 for( ... ) { // not good for( ... ){ // not good for ( ... ) { // good 10. Spaces in Assignments Add a single space before and after = . 1 2 3 4 a=b; // no a= b; // no a =b; // no a = b; // OK! 11. Positions of Open and Close Braces There are two camps on the position of open braces. The following shows the \"trailing open braces\": 1 2 3 4 5 for ( i = 0 ; i < 3 ; i += 1 ) { while ( j != i ) { printf ( \"Hello \\n \" ); } } The following shows the \"leading open braces\". The leading open brace must be aligned with the block of the construct it is in: 1 2 3 4 5 6 7 for ( i = 0 ; i < 3 ; i += 1 ) { while ( j != i ) { printf ( \"Hello \\n \" ); } } Both styles are acceptable, but you should be consistent and should not mix both styles in a single program. For close braces, they should be leading close braces aligned with the block of the construct. Close braces should NOT be trailing as that would make it hard to spot them. 12. Avoid Else After Return Adding an else after a return statement in the if block is unnecessary and increases the indentation level. If the last statement of the if block is a return statement, we should skip the else statement. 1 2 3 4 5 6 7 8 9 if ( x == 1 ) { return 10 ; } else { if ( y == 2 ) { return 13 ; } else { return 89 ; } } can be written as the following equivalent code: 1 2 3 4 5 6 7 if ( x == 1 ) { return 10 ; } if ( y == 2 ) { return 13 ; } return 89 ; 13. Comment Major Code Segments Adequately Major segments of code should have explanatory comments. A major segment may be a loop block or a function block. You should comment on complicated logic, expressions, or algorithms, explaining what you are doing in the code, including why and how. An \"if\" block with a complex condition or an expression that is hard to understand should have explanatory comments. For example, 1 2 3 4 // Check and reject out-of-bounds indices if ( k < 0 || k >= MAX_LEN ) { return -1 ; } 14. Avoid Superfluous Comments A comment such as: 1 i += 1 // add one to i serves no purpose, adds clutter to a program and does more harm than good. 15. Blank Lines It is good to add a blank line between two functions, or two long segments of code for readability. 1 2 3 4 5 6 7 8 9 // This function ... int f ( int x ) { // body } // This function ... int g ( double y ) { // body } 1 2 3 4 5 6 7 8 9 10 // Statements 1 to 10 belong to a sub-task statement1 ; statement2 ; : statement10 ; // Leave a blank line for readability statement11 ; statement12 ; : However, guard against the use of excessive blank lines. Double blank lines and triply blank lines, or more, should not be present. 16. Long Lines If a line (be it a statement or a comment) is too long (more than 80 characters), do not let it run through the screen and wrap around. Instead, split it into a few lines. 1 if (( has_cs2010 || has_cs2020 || has_cs2040 || has_cs2040C ) && ( has_st1232 || has_st2131 || has_st2132 || has_st2334 ) && ( has_ma1102R || has_ma1505 || ( has_ma1511 && has_ma1512 ) || has_ma1521 ) && ( has_ma1101R || has_ma1311 || has_ma1506 || has_ma1508E )) is bad 1 2 3 4 if (( has_cs2010 || has_cs2020 || has_cs2040 || has_cs2040c ) && ( has_st1232 || has_st2131 || has_st2132 || has_st2334 ) && ( has_ma1102r || has_ma1505 || ( has_ma1511 && has_ma1512 ) || has_ma1521 ) && ( has_ma1101r || has_ma1311 || has_ma1506 || has_ma1508e )) is better.","title":"C Style Convention"},{"location":"style.html#cs1010-c-style","text":"In CS1010, you should following the following style guide when you write your code for your graded homework and practical exams. We typically allocate a few marks for coding style (each assignment/exam may have different allocation). You will lose marks for violation of style. This guide is modified from past CS1010 style guide by Aaron Tan.","title":"CS1010 C Style"},{"location":"style.html#why-coding-style-is-important","text":"Quote \"It is not merely a matter of aesthetics that programs should be written in a particular style. Rather there is a psychological basis for writing programs in a conventional manner: programmers have strong expectations that other programmers will follow these discourse rules. If the rules are violated, then the utility afforded by the expectations that programmers have built up over time is effectively nullified. The results from the experiments with novice and advanced student programmers and with professional programmers described in this paper provide clear support for these claims.\" Elliot Soloway and Kate Ehrlich. \"Empirical studies of programming knowledge.\" IEEE Transactions on Software Engineering 5 (1984): 595-609.","title":"Why Coding Style is Important"},{"location":"style.html#1-variable-declaration","text":"Each variable should be declared in its own line. 1 2 double weight ; // The weight of the baby double height ; // The height of the baby Avoid 1 double weight , height ; // Weight and height of the baby","title":"1. Variable Declaration"},{"location":"style.html#2-give-variables-descriptive-names","text":"This is the most important rule to follow. The name of a type, variable, function, constant should inform us of its purpose clearly without the readers having to guess or look up its meaning. For example, int number_of_coins; is an appropriate variable but not int c; . Avoid using a single character for variable names. There are some exceptions, however, as shown below: If the variable is the problem size and it is given in the task statement. For example, a problem dealing with n values, hence the variable may be called n (preferably with a comment to explain). If the variable is a transient/temporary variable whose purpose is clear. -If the variable is a loop variable whose purpose is clear.","title":"2. Give Variables Descriptive Names"},{"location":"style.html#3-shorten-variable-names-with-naming-conventions","text":"Despite the recommendation for descriptive names, identifiers can be short yet descriptive by using abbreviations and/or common naming conventions. For example, MAX_LEN , num_of_elems , pcurr , table_num . However, do not invent your own abbreviation. For instance, names like nm_elemnts should be avoided.","title":"3. Shorten Variable Names with Naming Conventions"},{"location":"style.html#4-avoid-negated-variable-or-function-names","text":"Negated variables often result in hard-to-read double-negatives in an expression like !is_not_err . So, avoid is_not_error , is_not_found , is_not_valid , cannot_open_file . Instead, we prefer is_error , is_found , is_valid , can_open_file etc.","title":"4. Avoid Negated Variable or Function Names"},{"location":"style.html#5-use-define-to-define-constants-for-magic-numbers","text":"Avoid direct use of magic numbers. Constant literals which have special meanings should be named and its named identifier should be used in its place. For example: Avoid: 1 2 3 for ( i = 0 ; i < 100 ; i += 1 ) { : } Prefer: 1 2 3 4 5 #define MAX_LEN 100 : for (i = 0; i < MAX_LEN; i += 1) { : }","title":"5. Use #define to Define Constants for Magic Numbers"},{"location":"style.html#6-naming-conventions","text":"","title":"6. Naming Conventions"},{"location":"style.html#constants","text":"All constant identifiers must be written in all caps and separated by an underscore _ . For instance MAX_ITERATIONS , MAX_LEN , GOLDEN_RATIO , COLOR_DEFAULT , PI .","title":"Constants"},{"location":"style.html#variables-and-functions","text":"Use lower case letters for variable names and function names, with multiple words separated by underscore _ . Example, cs1010_read_long , is_prime .","title":"Variables and Functions"},{"location":"style.html#7-use-consistent-indentation-to-emphasize-block-structure","text":"The code should be properly and neatly indented to emphasize the nested logical structure of the program. An indentation of 2 or 4 spaces is recommended (8 is too wide). Every block that follows a for , while , if-else , do-while statement must be indented from its enclosing block. Comments within a block should follow the indentation level of its enclosing block. For example, 1 2 3 4 5 6 7 for ( i = 0 ; i < 3 ; i += 1 ) { // Comments should be indented too while ( j != i ) { // More indented comments printf ( \"Hello \\n \" ); } } The following are the wrong ways to indent the comments. 1 2 3 4 5 6 7 for ( i = 0 ; i < 3 ; i += 1 ) { // This comment should be indented and aligned with the while statement. while ( j != i ) { // This comment should be aligned with the printf statement. printf ( \"Hello \\n \" ); } }","title":"7. Use Consistent Indentation to Emphasize Block Structure"},{"location":"style.html#8-dont-mix-tabs-and-spaces","text":"You must use only spaces in your code. Do not use tabs. You can add the configuration set expandtab to automatically expand any tab that you enter into spaces.","title":"8. Don't Mix Tabs and Spaces"},{"location":"style.html#9-spaces-in-if-else-for-while-do-while-statements","text":"Add a single space between the keywords if , else , for , while and the following parentheses and between the parentheses and next curly bracket. For instance: 1 2 3 for( ... ) { // not good for( ... ){ // not good for ( ... ) { // good","title":"9. Spaces in if, else, for, while, do-while Statements"},{"location":"style.html#10-spaces-in-assignments","text":"Add a single space before and after = . 1 2 3 4 a=b; // no a= b; // no a =b; // no a = b; // OK!","title":"10. Spaces in Assignments"},{"location":"style.html#11-positions-of-open-and-close-braces","text":"There are two camps on the position of open braces. The following shows the \"trailing open braces\": 1 2 3 4 5 for ( i = 0 ; i < 3 ; i += 1 ) { while ( j != i ) { printf ( \"Hello \\n \" ); } } The following shows the \"leading open braces\". The leading open brace must be aligned with the block of the construct it is in: 1 2 3 4 5 6 7 for ( i = 0 ; i < 3 ; i += 1 ) { while ( j != i ) { printf ( \"Hello \\n \" ); } } Both styles are acceptable, but you should be consistent and should not mix both styles in a single program. For close braces, they should be leading close braces aligned with the block of the construct. Close braces should NOT be trailing as that would make it hard to spot them.","title":"11. Positions of Open and Close Braces"},{"location":"style.html#12-avoid-else-after-return","text":"Adding an else after a return statement in the if block is unnecessary and increases the indentation level. If the last statement of the if block is a return statement, we should skip the else statement. 1 2 3 4 5 6 7 8 9 if ( x == 1 ) { return 10 ; } else { if ( y == 2 ) { return 13 ; } else { return 89 ; } } can be written as the following equivalent code: 1 2 3 4 5 6 7 if ( x == 1 ) { return 10 ; } if ( y == 2 ) { return 13 ; } return 89 ;","title":"12. Avoid Else After Return"},{"location":"style.html#13-comment-major-code-segments-adequately","text":"Major segments of code should have explanatory comments. A major segment may be a loop block or a function block. You should comment on complicated logic, expressions, or algorithms, explaining what you are doing in the code, including why and how. An \"if\" block with a complex condition or an expression that is hard to understand should have explanatory comments. For example, 1 2 3 4 // Check and reject out-of-bounds indices if ( k < 0 || k >= MAX_LEN ) { return -1 ; }","title":"13. Comment Major Code Segments Adequately"},{"location":"style.html#14-avoid-superfluous-comments","text":"A comment such as: 1 i += 1 // add one to i serves no purpose, adds clutter to a program and does more harm than good.","title":"14. Avoid Superfluous Comments"},{"location":"style.html#15-blank-lines","text":"It is good to add a blank line between two functions, or two long segments of code for readability. 1 2 3 4 5 6 7 8 9 // This function ... int f ( int x ) { // body } // This function ... int g ( double y ) { // body } 1 2 3 4 5 6 7 8 9 10 // Statements 1 to 10 belong to a sub-task statement1 ; statement2 ; : statement10 ; // Leave a blank line for readability statement11 ; statement12 ; : However, guard against the use of excessive blank lines. Double blank lines and triply blank lines, or more, should not be present.","title":"15. Blank Lines"},{"location":"style.html#16-long-lines","text":"If a line (be it a statement or a comment) is too long (more than 80 characters), do not let it run through the screen and wrap around. Instead, split it into a few lines. 1 if (( has_cs2010 || has_cs2020 || has_cs2040 || has_cs2040C ) && ( has_st1232 || has_st2131 || has_st2132 || has_st2334 ) && ( has_ma1102R || has_ma1505 || ( has_ma1511 && has_ma1512 ) || has_ma1521 ) && ( has_ma1101R || has_ma1311 || has_ma1506 || has_ma1508E )) is bad 1 2 3 4 if (( has_cs2010 || has_cs2020 || has_cs2040 || has_cs2040c ) && ( has_st1232 || has_st2131 || has_st2132 || has_st2334 ) && ( has_ma1102r || has_ma1505 || ( has_ma1511 && has_ma1512 ) || has_ma1521 ) && ( has_ma1101r || has_ma1311 || has_ma1506 || has_ma1508e )) is better.","title":"16. Long Lines"},{"location":"tmate.html","text":"tmate tmate is a tool that allows us to share our terminal with one another. It is an essential tool for us to run our labs online. To run tmate , type 1 $ tmate on the command prompt on any of the PE nodes. You should see that the screen is cleared, and a bar appears at the bottom of your screen with the word [tmate] . First Run The first time you run tmate , you will be asked to generate an SSH key. You can do this by running ssh-keygen and follow the instructions therein. Sharing Your Terminal With Someone After you started tmate , you can run: 1 $ tmate show-messages or 1 $ tmate showmsgs This will display a message similar to the following: 1 2 3 4 5 6 7 Sun Aug 23 10:37:06 2020 [tmate] Connecting to ssh.tmate.io... Sun Aug 23 10:37:06 2020 [tmate] Note: clear your terminal before sharing readonly access Sun Aug 23 10:37:06 2020 [tmate] web session read only: https://tmate.io/t/ro-fhVJJmuNzpy2qBmpaB6n6v3Cb Sun Aug 23 10:37:06 2020 [tmate] ssh session read only: ssh ro-fhVJJmuNzpy2qBmpaB6n6v3Cb@sgp1.tmate.io Sun Aug 23 10:37:06 2020 [tmate] web session: https://tmate.io/t/SDgPyXE9juTRJpb6ghpCvVrxE Sun Aug 23 10:37:06 2020 [tmate] ssh session: ssh SDgPyXE9juTRJpb6ghpCvVrxE@sgp1.tmate.io Sun Aug 23 10:37:26 2020 [tmate] tmate can be upgraded to 2.4.0. See https://tmate.io for a list of new features The most important lines are the Lines 3-6. If you want to show your terminal with someone else, but do not want to give them the control to type into your terminal, you can share the information about the read-only sessions on Line 3-4. If you want to let someone else type into your terminal, share Line 5-6 with them. Doing so with your tutors would be very helpful during the tutorial session. Keep your tmate sessions private Do not at any time, make these links public -- only share them with people you trust. Quitting tmate To exit from tmate , you just need to hit Ctrl + D on your tmate command prompt. This should bring you back to your usual command prompt (the bar labeling [tmate] should disappear).","title":"TMate"},{"location":"tmate.html#tmate","text":"tmate is a tool that allows us to share our terminal with one another. It is an essential tool for us to run our labs online. To run tmate , type 1 $ tmate on the command prompt on any of the PE nodes. You should see that the screen is cleared, and a bar appears at the bottom of your screen with the word [tmate] .","title":"tmate"},{"location":"tmate.html#first-run","text":"The first time you run tmate , you will be asked to generate an SSH key. You can do this by running ssh-keygen and follow the instructions therein.","title":"First Run"},{"location":"tmate.html#sharing-your-terminal-with-someone","text":"After you started tmate , you can run: 1 $ tmate show-messages or 1 $ tmate showmsgs This will display a message similar to the following: 1 2 3 4 5 6 7 Sun Aug 23 10:37:06 2020 [tmate] Connecting to ssh.tmate.io... Sun Aug 23 10:37:06 2020 [tmate] Note: clear your terminal before sharing readonly access Sun Aug 23 10:37:06 2020 [tmate] web session read only: https://tmate.io/t/ro-fhVJJmuNzpy2qBmpaB6n6v3Cb Sun Aug 23 10:37:06 2020 [tmate] ssh session read only: ssh ro-fhVJJmuNzpy2qBmpaB6n6v3Cb@sgp1.tmate.io Sun Aug 23 10:37:06 2020 [tmate] web session: https://tmate.io/t/SDgPyXE9juTRJpb6ghpCvVrxE Sun Aug 23 10:37:06 2020 [tmate] ssh session: ssh SDgPyXE9juTRJpb6ghpCvVrxE@sgp1.tmate.io Sun Aug 23 10:37:26 2020 [tmate] tmate can be upgraded to 2.4.0. See https://tmate.io for a list of new features The most important lines are the Lines 3-6. If you want to show your terminal with someone else, but do not want to give them the control to type into your terminal, you can share the information about the read-only sessions on Line 3-4. If you want to let someone else type into your terminal, share Line 5-6 with them. Doing so with your tutors would be very helpful during the tutorial session. Keep your tmate sessions private Do not at any time, make these links public -- only share them with people you trust.","title":"Sharing Your Terminal With Someone"},{"location":"tmate.html#quitting-tmate","text":"To exit from tmate , you just need to hit Ctrl + D on your tmate command prompt. This should bring you back to your usual command prompt (the bar labeling [tmate] should disappear).","title":"Quitting tmate"},{"location":"tutors.html","text":"Teaching Team Labs Venue 12 - 2 PM 2 - 4 PM 4 - 6 PM PL2 COM1-B109 C02 AKHIL VUPUTURI D02 CHENG SIYUAN E02 ALBERT SUTIONO PL3 COM1-B108 C03 FRANCISCO CHENSAN D03 HO ZHEN HONG E03 BRENDAN LAU SIEW ZHI PL4 COM1-B111 C04 IVANDER JONATHAN MARELLA WASKITO D04 HOE JUN LEONG E04 MODAK SHANTANU BHARAT PL5 COM1-B110 C05 KHENUS TAN JIA LIANG D05 LIANG YUZHAO E05 GUO AI PL6 COM1-0120 C06 NGO PHUC CUONG D06 LYU JIAWEN E06 KERBY SOH CHEN KER WSL1 i3-0339 C07 LING YAN HAO D07 MA ZIJIAN E07 LIAU KAI JIE WSL2 i3-0338 C08 LEE JIA YI D08 NG CHENG YANG, TITUS E08 ERIC BRYAN WSL3 i3-0336 C09 TEAN WEI JUN D09 SEO GIMIN E09 WONG ZHEN WEI Venue 6 - 8 PM Zoom F01 ADI NATA Zoom F02 LOK KE WEN Tutorials Time Group Venue Tutor 8 AM T01 SR3 COM1-0212 OOI WEI TSANG 9 AM T02 SR3 COM1-0212 HUBERTUS ADHY PRATAMA SETIAWAN 10 AM T03 SR3 COM1-0212 ALVIN HENG JUN REN 11 AM T04 SR3 COM1-0212 ALVIN HENG JUN REN 12 PM T05 SR3 COM1-0212 FELIX HALIM 1 PM T06 SR3 COM1-0212 FELIX HALIM 1 PM T06A SR @ LT19 XIA FUXI 2 PM T07 SR3 COM1-0212 CHRISTOPHER GOH ZHEN FUNG 2 PM T07A SR @ LT19 XIA FUXI 3 PM T08 SR3 COM1-0212 CHRISTOPHER GOH ZHEN FUNG 4 PM T09 SR3 COM1-0212 SONG KAI 5 PM T10 SR3 COM1-0212 HUBERTUS ADHY PRATAMA SETIAWAN 6 PM T11 Online SONG KAI e-Exam Management SONG KAI WANG CHENGXIN LUO XINJIAN Piazza and Exercise/Assignment Management HU JIALUN","title":"Teaching Team"},{"location":"tutors.html#teaching-team","text":"","title":"Teaching Team"},{"location":"tutors.html#labs","text":"Venue 12 - 2 PM 2 - 4 PM 4 - 6 PM PL2 COM1-B109 C02 AKHIL VUPUTURI D02 CHENG SIYUAN E02 ALBERT SUTIONO PL3 COM1-B108 C03 FRANCISCO CHENSAN D03 HO ZHEN HONG E03 BRENDAN LAU SIEW ZHI PL4 COM1-B111 C04 IVANDER JONATHAN MARELLA WASKITO D04 HOE JUN LEONG E04 MODAK SHANTANU BHARAT PL5 COM1-B110 C05 KHENUS TAN JIA LIANG D05 LIANG YUZHAO E05 GUO AI PL6 COM1-0120 C06 NGO PHUC CUONG D06 LYU JIAWEN E06 KERBY SOH CHEN KER WSL1 i3-0339 C07 LING YAN HAO D07 MA ZIJIAN E07 LIAU KAI JIE WSL2 i3-0338 C08 LEE JIA YI D08 NG CHENG YANG, TITUS E08 ERIC BRYAN WSL3 i3-0336 C09 TEAN WEI JUN D09 SEO GIMIN E09 WONG ZHEN WEI Venue 6 - 8 PM Zoom F01 ADI NATA Zoom F02 LOK KE WEN","title":"Labs"},{"location":"tutors.html#tutorials","text":"Time Group Venue Tutor 8 AM T01 SR3 COM1-0212 OOI WEI TSANG 9 AM T02 SR3 COM1-0212 HUBERTUS ADHY PRATAMA SETIAWAN 10 AM T03 SR3 COM1-0212 ALVIN HENG JUN REN 11 AM T04 SR3 COM1-0212 ALVIN HENG JUN REN 12 PM T05 SR3 COM1-0212 FELIX HALIM 1 PM T06 SR3 COM1-0212 FELIX HALIM 1 PM T06A SR @ LT19 XIA FUXI 2 PM T07 SR3 COM1-0212 CHRISTOPHER GOH ZHEN FUNG 2 PM T07A SR @ LT19 XIA FUXI 3 PM T08 SR3 COM1-0212 CHRISTOPHER GOH ZHEN FUNG 4 PM T09 SR3 COM1-0212 SONG KAI 5 PM T10 SR3 COM1-0212 HUBERTUS ADHY PRATAMA SETIAWAN 6 PM T11 Online SONG KAI","title":"Tutorials"},{"location":"tutors.html#e-exam-management","text":"SONG KAI WANG CHENGXIN LUO XINJIAN","title":"e-Exam Management"},{"location":"tutors.html#piazza-and-exerciseassignment-management","text":"HU JIALUN","title":"Piazza and Exercise/Assignment Management"},{"location":"unix.html","text":"Basic UNIX Commands UNIX-based operating systems provide a command line to interact with the system: to create directories, to manipulate files, to run certain applications. While these tasks can be done through a GUI interface, a command line is still useful because (i) it provides a simple way to interact with a remote system (only text are exchanged between the local and remote hosts instead of graphics); (ii) it is extremely flexible and provides many customization options; (iii) you can easily automate the sequence of commands to issue for repetitive tasks; and (iv) it is faster. Connect to the Programming Environment (PE) If you would like to follow the following examples, you should first ssh into one of the PE hosts provided. We will use pe111 in the following example. But feel free to use pe112 up to pe120 for your practice. You should read this guide to see how to access and connect to the environment. Once you are connected, you should see a prompt like this. 1 ooiwt@pe111:~$ This interface is provided by a UNIX bash -- this shell sits in a loop and waits for users to enter a command, then it interprets and executes the command. There are many versions of shells, the default shell for our PE is bash 1 . The following is adapted for CS1010 from the instructions created by Aaron Tan . Bugs are mine. The power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are case-sensitive . All commands are to be entered after the UNIX prompt of the form 1 ooiwt@pe111:~$ ~ indicates that you are currently in your home directory. The following examples assume that user ooiwt is logged into pe111 . It might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below: Each user has his/her own home directory, which is where he/she will be automatically placed when he/she logs in to the system. The above figure shows where the home directory of the user ooiwt resides in the directory tree. The user ooiwt may create files or directories in his/her home directory, but not elsewhere unless permission is given. pwd : Print Current Working directory pwd shows you which directory you are currently in 1 2 ooiwt@pe111:~$ pwd /home/o/ooiwt UNIX uses forward slash / to deliminate different parts of the directory structure. This is the same notation as URLs so you should already be familiar with it. ls : LiSt files The ls list the files in the current working directory. 1 2 ooiwt@pe111:~$ ls ooiwt@pe111:~$ If you do not have any regular files in your home directory, as you should when you first log in, you should immediately return to the bash prompt. Rule of Silence UNIX follows the rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program. So, if ls has nothing to list, it will list nothing (as opposed to, say, printing \"This is an empty directory.\") mkdir : MaKe a subDIRectory The mkdir command creates a subdirectory with the given name in the current directory. 1 2 3 4 5 ooiwt@pe111:~$ mkdir tut01 ooiwt@pe111:~$ ls tut01 ooiwt@pe111:~$ ls -F tut01/ Here, you create a directory called tut01 . Now, when you ls , you can see the directory listed. You may also use ls -F for more information ( -F is one of the many options / flags available for the ls command. To see a complete list of the options, refer to the man pages, i.e., man ls .) The slash / beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used. You may also use the ls -l command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification. Use Ctrl + P for Command History Unix maintains a history of your previously executed UNIX commands, and you may use Ctrl + P and Ctrl + N to go through it. Press the Ctrl + P until you find a previously executed UNIX command. You may then press Enter to execute it or edit the command before executing it. This is handy when you need to repeatedly execute a long UNIX command. cd : Change Directory To navigate in the directory tree, changing the current working directory from to another, we use the cd command. 1 2 ooiwt@pe111:~$ cd tut01 ooiwt@pe111:~/tut01$ Note that the prompt changes to ~/tut01 to indicate that you are now in the tut01 directory below your HOME directory. Entering cd alone brings you back to your HOME directory, i.e., the directory in which you started with when you first logged into the system. 1 2 ooiwt@pe111:~/tut01$ cd ooiwt@pe111:~$ Two dots .. refers to the parent directory. So, alternatively, for the case above, since we are only one level down from the HOME , to return home, we can alternatively use cd .. . 1 2 ooiwt@pe111:~/tut01$ cd .. ooiwt@pe111:~$ rmdir : ReMove a subDIRectory rmdir removes a subDIRectory in current directory -- note that a directory must be empty before it can be removed. 1 2 3 4 5 ooiwt@pe111:~$ rmdir tut01 ooiwt@pe111:~$ ls -F ooiwt@pe111:~$ mkdir tut01 ooiwt@pe111:~$ ls -F tut01/ cp : CoPy files 1 2 3 ooiwt@pe111:~/tut01$ cp ~cs1010/tut01/hello.c . ooiwt@pe111:~/tut01$ ls hello.c The command above copies the file hello.c from the HOME of user cs1010 , under directory tut01 , to the current directory. If you want to copy the whole directory, use -r flag, where r stands for recursive copy. 1 ooiwt@pe111:~/tut01$ cp -r ~cs1010/tut01 . In the last command above, the single . refers to the current directory. The directory tut01 and everything under it will be copied to the current directory. mv : MoVe or rename files mv can move files from one directory to another. 1 2 3 4 5 6 7 ooiwt@pe111:~/tut01$ ls hello.c ooiwt@pe111:~/tut01$ mv hello.c .. ooiwt@pe111:~/tut01$ ls ooiwt@pe111:~/tut01$ ls .. hello.c ooiwt@pe111:~/tut01$ mv ../hello.c . Here, we tell mv to copy move a file hello.c from the parent directory to the current directory. mv can also be used to rename files. 1 2 3 ooiwt@pe111:~/tut01$ mv hello.c hello_world.c ooiwt@pe111:~/tut01$ ls hello_world.c Use TAB for Name Completion If you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type: 1 ooiwt@pe111:~/tut01$ mv h and press the Tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"h\". Otherwise, it will fill up the filename to the point where you need to type in more characters for disambiguation. The Tab key can also complete the name of a command. rm : ReMove files Be careful with this command -- files deleted cannot be restored. There is no trash or recycled bin like in Mac or Windows. 1 2 3 ooiwt@pe111:~/tut01$ rm hello.c ooiwt@pe111:~/tut01$ ls ooiwt@pe111:~/tut01$ rm -rf * While Unix command line provides lots of flexibility and power, with great power comes great responsibility. Some of the commands are extremely dangerous. rm -rf * is the most famous one. The notation * refers to all files, and the flag -f means forceful deletion (no question asked!), and -r means remove recursively everything under the current directory tree. Accidentally running this command has ruined many files. Read more here rm comes with a -i flag that interactively asks you if you are sure if you want to delete a file. It is a good idea to always run rm -i . On pe111 , we have configured everyone's account so that rm is aliased to rm -i by default. So when you run rm hello.c , it actually runs rm -i hello.c . 1 2 ooiwt@pe111:~/tut01$ rm hello.c rm: remove regular file 'hello.c' ? Type y or n to answer yes or no respectively. If you set up your own UNIX OS, you should add this alias 1 alias rm = \"rm -i\" to your .bashrc (Google to find out how). Other useful aliases to avoid accidentally overwriting existing files are: 1 2 alias mv = \"mv -i\" alias cp = \"cp -i\" cat : CATenate file content to the screen To quickly take a look at the content of the file, use the cat command. 1 ooiwt@pe111:~/tut01$ cat hello.c less is variant of cat that includes features to read each page leisurely) 1 ooiwt@pe111:~/tut01$ less hello.c In less , use <space> to move down one page, b to move Back up one page, and q to Quit. man : Online MANual An online help facility is available in UNIX via the man command ( man stands for MANual). To look for more information about any UNIX command, for example, ls , type man ls . Type man man and refer to Man Pages to find out more about the facility. To exit man , press q . Now that you are familiar with how the UNIX bash works, I won't show the command prompt any more in the rest of this article. chmod : Changing UNIX File Permission It is important to guide our files properly on a multi-user system where users share the same file system. UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read ( r ), write ( w ), and execute ( x ), for four classes of users, the user who owns of the file ( u ), users in the same group as the owner ( g ), all other users ( o ), and all users ( a ) (union of all three classes before) When you run ls -l , you will see the permission encoded as strings that look like -rw------- or drwx--x--x besides other file information. The first character indicates if the file is a directory ( d ) or not ( - ). The next three characters are the permission for the owner. rwx means that the owner can do all three: reading, writing, and executing, rw- means that the owner can read and write, but cannot execute. The next three characters are the permission for the users in the same group. The last three characters are the permission for the users in the other groups. To change permission, we use the chmod command. Let's say that we want to remove the read and write permission from all other users in the group. You can run: 1 chmod g-rw <file> where <file> is the name of the file whose permission you want to change. This would change the permission from -rw-rw-rw- to -rw----rw- , or from -rwxr--r-- to -rwx---r-- . To add executable permission to everyone, you can run: 1 chmod a+x <file> This would change the permission from -rw-rw-rw- to -rwxrwxrwx , or from -rwxr--r-- to rwxr-xr-x , and so on. You get the idea. Another way to change the permission is to set the permission directly, instead of adding with + and removing with - . To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7. So, rwx is 7, rw- is 6, -w- is 2, --- is 0, etc. To set the permission of a file to -r--r--r-- (readable by everyone), run: 1 chmod 444 <file> To set the permission to -rw------- , run: 1 chmod 600 <file> and so on. It is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises. scp : Secure Copy Secure copy, or scp , is one way to transfer files from the programming environments to your local computer for archiving or storage. Let's say you want to transfer a set of C files from the directory a01 to your local computer, then, on your local computer, run: 1 ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/*.c . Warning If you have files with the same name in the remote directory, the files will be overwritten without warning. I have lost my code a few times due to scp . The expression *.c is a regular expression that means all files with filename ending with .c . You can copy specific files as well. For instance, 1 ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/hello.c . scp supports -r (recursive copy) as well. Specifying A Path in UNIX In any command above, when we need to refer to a directory or a file, we need to specify an unambiguous location of the directory or the file. The most precise way to specify the location is to use the full path, or the absolute path . For instance: 1 cp /home/o/ooiwt/tut01/hello.c /home/o/ooiwt/tut01/hello_world.c That's a lot of characters to type. We could shorten it in a few ways. We could specify the location with respect to the home directory using ~ . ~ooiwt refers to the home directory of user ooiwt . 1 cp ~ooiwt/tut01/hello.c ~ooiwt/tut01/hello_world.c If you are ooiwt , then you can omit ooiwt , since ~ without any username refers to your home directory. 1 cp ~/tut01/hello.c ~/tut01/hello_world.c Or we could specify the location with respect to the current directory. Suppose the current working directory is ~/tut01 (i.e., we have cd into ~/tut01 ), then we could say this: 1 cp ./hello.c ./hello_world.c Recall that a single dot . refers to the current directory. The ./ however is redundant unless you are executing a command. Since, by specifying a file name or a directory without a path (i.e., not using any / ), the bash looks for the file or directory in the current directory. So, we could just do: 1 cp hello.c hello_world.c Another important short form for relative location is .. . Recall that this refers to the parent directory. Suppose that the current directory is in ~/tut02 . Then, to copy the files in ~/tut01 , you can run: 1 cp ../tut01/hello.c ../tut01/hello_world.c I run fish on my macOS, as you might have noticed during the in-class demos. You can use any shell you like if you know what you are doing. Otherwise, bash is a popular one. \u21a9","title":"UNIX"},{"location":"unix.html#basic-unix-commands","text":"UNIX-based operating systems provide a command line to interact with the system: to create directories, to manipulate files, to run certain applications. While these tasks can be done through a GUI interface, a command line is still useful because (i) it provides a simple way to interact with a remote system (only text are exchanged between the local and remote hosts instead of graphics); (ii) it is extremely flexible and provides many customization options; (iii) you can easily automate the sequence of commands to issue for repetitive tasks; and (iv) it is faster.","title":"Basic UNIX Commands"},{"location":"unix.html#connect-to-the-programming-environment-pe","text":"If you would like to follow the following examples, you should first ssh into one of the PE hosts provided. We will use pe111 in the following example. But feel free to use pe112 up to pe120 for your practice. You should read this guide to see how to access and connect to the environment. Once you are connected, you should see a prompt like this. 1 ooiwt@pe111:~$ This interface is provided by a UNIX bash -- this shell sits in a loop and waits for users to enter a command, then it interprets and executes the command. There are many versions of shells, the default shell for our PE is bash 1 . The following is adapted for CS1010 from the instructions created by Aaron Tan . Bugs are mine. The power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are case-sensitive . All commands are to be entered after the UNIX prompt of the form 1 ooiwt@pe111:~$ ~ indicates that you are currently in your home directory. The following examples assume that user ooiwt is logged into pe111 . It might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below: Each user has his/her own home directory, which is where he/she will be automatically placed when he/she logs in to the system. The above figure shows where the home directory of the user ooiwt resides in the directory tree. The user ooiwt may create files or directories in his/her home directory, but not elsewhere unless permission is given.","title":"Connect to the Programming Environment (PE)"},{"location":"unix.html#pwd-print-current-working-directory","text":"pwd shows you which directory you are currently in 1 2 ooiwt@pe111:~$ pwd /home/o/ooiwt UNIX uses forward slash / to deliminate different parts of the directory structure. This is the same notation as URLs so you should already be familiar with it.","title":"pwd: Print Current Working directory"},{"location":"unix.html#ls-list-files","text":"The ls list the files in the current working directory. 1 2 ooiwt@pe111:~$ ls ooiwt@pe111:~$ If you do not have any regular files in your home directory, as you should when you first log in, you should immediately return to the bash prompt. Rule of Silence UNIX follows the rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program. So, if ls has nothing to list, it will list nothing (as opposed to, say, printing \"This is an empty directory.\")","title":"ls: LiSt files"},{"location":"unix.html#mkdir-make-a-subdirectory","text":"The mkdir command creates a subdirectory with the given name in the current directory. 1 2 3 4 5 ooiwt@pe111:~$ mkdir tut01 ooiwt@pe111:~$ ls tut01 ooiwt@pe111:~$ ls -F tut01/ Here, you create a directory called tut01 . Now, when you ls , you can see the directory listed. You may also use ls -F for more information ( -F is one of the many options / flags available for the ls command. To see a complete list of the options, refer to the man pages, i.e., man ls .) The slash / beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used. You may also use the ls -l command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification. Use Ctrl + P for Command History Unix maintains a history of your previously executed UNIX commands, and you may use Ctrl + P and Ctrl + N to go through it. Press the Ctrl + P until you find a previously executed UNIX command. You may then press Enter to execute it or edit the command before executing it. This is handy when you need to repeatedly execute a long UNIX command.","title":"mkdir: MaKe a subDIRectory"},{"location":"unix.html#cd-change-directory","text":"To navigate in the directory tree, changing the current working directory from to another, we use the cd command. 1 2 ooiwt@pe111:~$ cd tut01 ooiwt@pe111:~/tut01$ Note that the prompt changes to ~/tut01 to indicate that you are now in the tut01 directory below your HOME directory. Entering cd alone brings you back to your HOME directory, i.e., the directory in which you started with when you first logged into the system. 1 2 ooiwt@pe111:~/tut01$ cd ooiwt@pe111:~$ Two dots .. refers to the parent directory. So, alternatively, for the case above, since we are only one level down from the HOME , to return home, we can alternatively use cd .. . 1 2 ooiwt@pe111:~/tut01$ cd .. ooiwt@pe111:~$","title":"cd: Change Directory"},{"location":"unix.html#rmdir-remove-a-subdirectory","text":"rmdir removes a subDIRectory in current directory -- note that a directory must be empty before it can be removed. 1 2 3 4 5 ooiwt@pe111:~$ rmdir tut01 ooiwt@pe111:~$ ls -F ooiwt@pe111:~$ mkdir tut01 ooiwt@pe111:~$ ls -F tut01/","title":"rmdir: ReMove a subDIRectory"},{"location":"unix.html#cp-copy-files","text":"1 2 3 ooiwt@pe111:~/tut01$ cp ~cs1010/tut01/hello.c . ooiwt@pe111:~/tut01$ ls hello.c The command above copies the file hello.c from the HOME of user cs1010 , under directory tut01 , to the current directory. If you want to copy the whole directory, use -r flag, where r stands for recursive copy. 1 ooiwt@pe111:~/tut01$ cp -r ~cs1010/tut01 . In the last command above, the single . refers to the current directory. The directory tut01 and everything under it will be copied to the current directory.","title":"cp: CoPy files"},{"location":"unix.html#mv-move-or-rename-files","text":"mv can move files from one directory to another. 1 2 3 4 5 6 7 ooiwt@pe111:~/tut01$ ls hello.c ooiwt@pe111:~/tut01$ mv hello.c .. ooiwt@pe111:~/tut01$ ls ooiwt@pe111:~/tut01$ ls .. hello.c ooiwt@pe111:~/tut01$ mv ../hello.c . Here, we tell mv to copy move a file hello.c from the parent directory to the current directory. mv can also be used to rename files. 1 2 3 ooiwt@pe111:~/tut01$ mv hello.c hello_world.c ooiwt@pe111:~/tut01$ ls hello_world.c Use TAB for Name Completion If you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type: 1 ooiwt@pe111:~/tut01$ mv h and press the Tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"h\". Otherwise, it will fill up the filename to the point where you need to type in more characters for disambiguation. The Tab key can also complete the name of a command.","title":"mv: MoVe or rename files"},{"location":"unix.html#rm-remove-files","text":"Be careful with this command -- files deleted cannot be restored. There is no trash or recycled bin like in Mac or Windows. 1 2 3 ooiwt@pe111:~/tut01$ rm hello.c ooiwt@pe111:~/tut01$ ls ooiwt@pe111:~/tut01$ rm -rf * While Unix command line provides lots of flexibility and power, with great power comes great responsibility. Some of the commands are extremely dangerous. rm -rf * is the most famous one. The notation * refers to all files, and the flag -f means forceful deletion (no question asked!), and -r means remove recursively everything under the current directory tree. Accidentally running this command has ruined many files. Read more here rm comes with a -i flag that interactively asks you if you are sure if you want to delete a file. It is a good idea to always run rm -i . On pe111 , we have configured everyone's account so that rm is aliased to rm -i by default. So when you run rm hello.c , it actually runs rm -i hello.c . 1 2 ooiwt@pe111:~/tut01$ rm hello.c rm: remove regular file 'hello.c' ? Type y or n to answer yes or no respectively. If you set up your own UNIX OS, you should add this alias 1 alias rm = \"rm -i\" to your .bashrc (Google to find out how). Other useful aliases to avoid accidentally overwriting existing files are: 1 2 alias mv = \"mv -i\" alias cp = \"cp -i\"","title":"rm: ReMove files"},{"location":"unix.html#cat-catenate-file-content-to-the-screen","text":"To quickly take a look at the content of the file, use the cat command. 1 ooiwt@pe111:~/tut01$ cat hello.c less is variant of cat that includes features to read each page leisurely) 1 ooiwt@pe111:~/tut01$ less hello.c In less , use <space> to move down one page, b to move Back up one page, and q to Quit.","title":"cat: CATenate file content to the screen"},{"location":"unix.html#man-online-manual","text":"An online help facility is available in UNIX via the man command ( man stands for MANual). To look for more information about any UNIX command, for example, ls , type man ls . Type man man and refer to Man Pages to find out more about the facility. To exit man , press q . Now that you are familiar with how the UNIX bash works, I won't show the command prompt any more in the rest of this article.","title":"man: Online MANual"},{"location":"unix.html#chmod-changing-unix-file-permission","text":"It is important to guide our files properly on a multi-user system where users share the same file system. UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read ( r ), write ( w ), and execute ( x ), for four classes of users, the user who owns of the file ( u ), users in the same group as the owner ( g ), all other users ( o ), and all users ( a ) (union of all three classes before) When you run ls -l , you will see the permission encoded as strings that look like -rw------- or drwx--x--x besides other file information. The first character indicates if the file is a directory ( d ) or not ( - ). The next three characters are the permission for the owner. rwx means that the owner can do all three: reading, writing, and executing, rw- means that the owner can read and write, but cannot execute. The next three characters are the permission for the users in the same group. The last three characters are the permission for the users in the other groups. To change permission, we use the chmod command. Let's say that we want to remove the read and write permission from all other users in the group. You can run: 1 chmod g-rw <file> where <file> is the name of the file whose permission you want to change. This would change the permission from -rw-rw-rw- to -rw----rw- , or from -rwxr--r-- to -rwx---r-- . To add executable permission to everyone, you can run: 1 chmod a+x <file> This would change the permission from -rw-rw-rw- to -rwxrwxrwx , or from -rwxr--r-- to rwxr-xr-x , and so on. You get the idea. Another way to change the permission is to set the permission directly, instead of adding with + and removing with - . To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7. So, rwx is 7, rw- is 6, -w- is 2, --- is 0, etc. To set the permission of a file to -r--r--r-- (readable by everyone), run: 1 chmod 444 <file> To set the permission to -rw------- , run: 1 chmod 600 <file> and so on. It is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises.","title":"chmod: Changing UNIX File Permission"},{"location":"unix.html#scp-secure-copy","text":"Secure copy, or scp , is one way to transfer files from the programming environments to your local computer for archiving or storage. Let's say you want to transfer a set of C files from the directory a01 to your local computer, then, on your local computer, run: 1 ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/*.c . Warning If you have files with the same name in the remote directory, the files will be overwritten without warning. I have lost my code a few times due to scp . The expression *.c is a regular expression that means all files with filename ending with .c . You can copy specific files as well. For instance, 1 ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/hello.c . scp supports -r (recursive copy) as well.","title":"scp: Secure Copy"},{"location":"unix.html#specifying-a-path-in-unix","text":"In any command above, when we need to refer to a directory or a file, we need to specify an unambiguous location of the directory or the file. The most precise way to specify the location is to use the full path, or the absolute path . For instance: 1 cp /home/o/ooiwt/tut01/hello.c /home/o/ooiwt/tut01/hello_world.c That's a lot of characters to type. We could shorten it in a few ways. We could specify the location with respect to the home directory using ~ . ~ooiwt refers to the home directory of user ooiwt . 1 cp ~ooiwt/tut01/hello.c ~ooiwt/tut01/hello_world.c If you are ooiwt , then you can omit ooiwt , since ~ without any username refers to your home directory. 1 cp ~/tut01/hello.c ~/tut01/hello_world.c Or we could specify the location with respect to the current directory. Suppose the current working directory is ~/tut01 (i.e., we have cd into ~/tut01 ), then we could say this: 1 cp ./hello.c ./hello_world.c Recall that a single dot . refers to the current directory. The ./ however is redundant unless you are executing a command. Since, by specifying a file name or a directory without a path (i.e., not using any / ), the bash looks for the file or directory in the current directory. So, we could just do: 1 cp hello.c hello_world.c Another important short form for relative location is .. . Recall that this refers to the parent directory. Suppose that the current directory is in ~/tut02 . Then, to copy the files in ~/tut01 , you can run: 1 cp ../tut01/hello.c ../tut01/hello_world.c I run fish on my macOS, as you might have noticed during the in-class demos. You can use any shell you like if you know what you are doing. Otherwise, bash is a popular one. \u21a9","title":"Specifying A Path in UNIX"},{"location":"vim.html","text":"Vim Tips I collected some tips on vim that I find helpful. If you are new to vim , please try out the command vimtutor on any machine where vim is installed, and check out the nice article Learn vim Progressively . 1. Useful Configuration You can configure your vim by putting your configuration options and scripts in the ~/.vimrc file (a hidden file named .vimrc in your home directory). This file will be loaded whenever you start vim . You can copy a sample .vimrc file from ~cs1010/.vimrc to your home directory. You can edit this file ~/.vimrc just like any other file, using vim . Help In vim, the command :help <topic> shows help about a particular topic in vim . Example, :help backup . Backup Files You can ask vim to automatically backup files that you edit. This has been a lifesaver for me on multiple occasions. In your ~/.vimrc file, 1 set backup will cause a copy of your file to be saved with suffix ~ appended to its name every time you save. I prefer not to clutter my working directory, so I set 1 set backupdir=~/.backup and create a directory named ~/.backup to store my backup files. So if you made changes to a file that you regretted, or if you accidentally deleted a file, you can check under ~/.backup to see if the backup can save you. Syntax Highlighting If for some reasons, syntax highlighting is not on by default, add this to your ~/.vimrc : 1 syntax on Ruler and Numbers If you prefer to show the line number you are on and the column number you are on, adding the commands to ~/.vimrc 1 set ruler will display the line number and the column number on the lower right corner. You can also add 1 set number to label each line with a line number. Auto Indentation Proper indentation is important to make your code readable (to yourself and others). You should enable this in vim with: 1 2 set autoindent set smartindent Autoindent will cause the next line to have the same indentation as the previous line; while smartindent has some understanding of C-like syntax (such as recognizing { and } ) and indent your code accordingly. The size of the indentation is based on the setting shiftwidth . For CS1010, please set it to either 2 or 4 : 1 set shiftwidth=2 2. Navigation Basic Navigation Use K and J keys to move up and down (just like Gmail and Facebook!). H and L to move left and right. Other shortcuts (no need to memorize them now, just refer back when you feel like you are typing too many H J K L to see how you can navigate faster). W jump to the beginning of the next word B ump to the beginning of the previous word (reverse of w ) E jump to the end of the word (or next word when pressed again) F char: search forward in the line and sit on the next matching char T char: search forward in the line and sit on one space before the matching char Shift + 4 ($) jump to the end of line 0 jump to the beginning of the line Shift + 6 (^) jump to the first non-blank character of the line Shift + 5 (%) jump between matching parentheses Ctrl + D jump forward (Down) half page Ctrl + F jump Forward one page Ctrl + U jump backward (Up) half page Ctrl + B jump Backward half page Jumping to a Line If the compiler tells you there is an error on Line \\(x\\) , you can issue :<x> to jump to Line \\(x\\) . For instance, :40 will go to Line 40. 3. Editing Operations Undo Since we are on the topic of correcting mistakes, U in command mode undo your changes. Prefix it with a number \\(n\\) to undo \\(n\\) times. If you want to undo your undo, Ctrl + R will redo. Navigation + Editing vim is powerful because you can combine operations with navigation . For instance C to change, D to delete, Y to yank (copy). Since W is the navigation command to move over the current word, combining them we get: C W change the current word (delete the current word and enter insert mode) D W delete the current word Y W yank the current word (copy word into buffer) Can you guess what each of these do: D F Shift + 0 D F Shift + 0 C Shift + 4 Y 0 If you repeat the operation C , D , and Y , it applies to the whole line, so: C C change the whole line D D delete the whole line Y Y yank the whole line You can add a number before an operation to specify how many times you want to repeat an operation. So 5 D D deletes 5 lines, 5 D W deletes 5 words, etc. See the article Operator, the True Power of Vim for more details. Swapping Lines Sometimes you want to swap the order of two lines of code, in command mode, D D P will do the trick. D D deletes the current line, P paste it after the current line, in effect swapping the order of the two lines. Commenting blocks of code Sometimes we need to comment out a whole block of code in C for testing purposes. There are several ways to do it in vim : Place the cursor on the first line of the block of code you want to comment on. 0 to jump to the beginning of the line Shift + V enter visual mode Use the arrow key to select the block of code you want to comment on. Shift + I to insert at the beginning of the line (here, since we already selected the block, we will insert at the beginning of every selected) / / to insert the C comment character (you will see it inserted in the current line, but don't worry) Esc to escape from the visual code. To uncomment, Place the cursor on the first line of the block of code you want to comment. 0 to jump to the beginning of the line Ctrl + V enter block visual mode Use the arrow key to select the columns of text containing // X to delete them 4. Other Advanced Features Search and Replace in vim 1 :%s/oldWord/newWord/gc : enters the command mode. % means apply to the whole document, s means substitute, g means global (otherwise, only the first occurrence of each line is replaced). c is optional -- adding it cause vim to confirm with you before each replacement Shell Command If you need to issue a shell command quickly, you don't have to exit vim , run the command, and launch vim again. You can use ! , 1 :!<command> will issue the command to shell. E.g., 1 :!ls You can use this to compile your current file, without exiting vim . 1 :!make make is actually a builtin command for vim so you can also simply run 1 :make Abbreviation You can use the command ab to abbreviate frequently typed commands. E.g., in your ~/.vimrc , 1 ab pl cs1010_print_long( Now, when you type pl , it will be expanded into cs1010_print_long( Auto-Completion You can use Ctrl + P or Ctrl + N to auto-complete. By default, the autocomplete dictionary is based on the text in your current editing buffers. This is a very useful keystroke saver for long function and variable names. Auto-Indent the Whole File You can G G = Shift + G in command mode to auto-indent the whole file. G G is the command to go to the beginning of the file. = is the command to indent. Shift + G is the command to go to the end of the file. Splitting vim 's Viewport :sp file.c splits the vim window horizontally :vsp file.c splits the vim window vertically Ctrl + W Ctrl + W moves between the different vim viewports 5. Color Schemes NEW We have installed vim-colorscheme bundle under ~cs1010/.vim/vim-colorschemes/colors . There are a few steps needed. First, the standard .vimrc is designed for 16 colors, and some of these color schemes are more colorful than that. You need to comment the following three lines from your ~/.vimrc 1 2 3 4 \" The following should give 16 colors \" set t_AB=^[[%?%p1%{8}%<%t%p1%{40}%+%e%p1%{92}%+%;%dm \" set t_AF=^[[%?%p1%{8}%<%t%p1%{30}%+%e%p1%{82}%+%;%dm \" set t_Co=16 Then, run 1 2 mkdir -p ~/.vim ln -s ~cs1010/.vim/vim-colorschemes/colors ~/.vim/colors After that, your can change your vim color scheme as usual. For instance, 1 :color gruvbox You can add the line color gruvbox to your ~/.vimrc so that the color scheme is loaded at the start of every vim session. The bundle includes some of the popular color schemes among students, such as molokai, solarized, and gruvbox. Some color schemes display differently depending on whether the background is set to dark or light Some examples, with set background=dark in ~/.vimrc : The default color scheme: The molokai color scheme: The gruvbox color scheme 6. Recovery Files NEW Vim automatically saves the files you are editing into temporary swap files, with extension .swp . These files are hidden so you don't normally see them when you run ls . (You need to run ls -a to view the hidden files) The swap files are useful if your editing session is disrupted before you save (e.g., the network is disconnected, you accidentally close the terminal, your OS crashes, etc.). When you launch vim to edit a file, say, foo.c . vim will check if a swap file .foo.c.swp exist. If it does, vim with display the following 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Found a swap file by the name \".foo.c.swp\" owned by: elsa dated: Sat Aug 21 15:01:04 2021 file name: ~elsa/foo.c modified: no user name: elsa host name: pe116 process ID: 7863 (STILL RUNNING) While opening file \"foo.c\" dated: Mon Jul 12 18:38:37 2021 (1) Another program may be editing the same file. If this is the case, be careful not to end up with two different instances of the same file when making changes. Quit, or continue with caution. (2) An edit session for this file crashed. If this is the case, use \":recover\" or \"vim -r a.c\" to recover the changes (see \":help recovery\"). If you did this already, delete the swap file \".a.c.swp\" to avoid this message. Swap file \".a.c.swp\" already exists! [O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit, (A)bort: The messages above is self-explanatory. Read it carefully. Most of the time, you want to choose \"R\" to recover your edits, so that you can continue editing. Remember to remove the file .foo.c.swp after you have recovered. Otherwise vim will prompt you the above messages every time you edit foo.c . Warning: if foo.c is newer than the state saved in .foo.c.swp , and you recover from .foo.c.swp , you will revert back to the state of the file as saved in the swap file. This can happen if (i) you edit the file without recovery, or (ii) you recover the file, continue editing, but did not remove the .foo.c.swp file after. 7. Approved Plugins UPDATED The following plugins are approved for use during practical exams. You will be given time to install them (only if you wish to use them) into your exam environment at the beginning of the practical exam. DelimitMate DelimitMate is a plugin that automatically inserts a closing } , ) , > , etc when you type the opening symbol. To install this plugin in the exam environment, run 1 ln -s ~cs1010/.vim/pack/plugins/start/delimitMate.vim ~/.vim/pack/plugins/start Vim-Rainbow vim-rainbow is a plugin that matches opening and closing brackets and colors the matching pairs with matching colors. To install this plugin in the exam environment, run 1 ln -s ~cs1010/.vim/pack/plugins/start/vim-rainbow ~/.vim/pack/plugins/start The following line will be added on your ~/.vimrc in the environment: 1 let g:rainbow_active = 1 NERDTree NERDTree provides a file browsing pane on the left (activated with :NERDTree ). To install this plugin in the exam environment, run 1 ln -s ~cs1010/.vim/pack/plugins/start/nerdtree ~/.vim/pack/plugins/start Lightline Lightline provides a more useful status line for vim . To install this plugin in the exam environment, run 1 ln -s ~cs1010/.vim/pack/plugins/start/lightline.vim ~/.vim/pack/plugins/start Unavailable Plugins The following plugins are not allowed as they provide too much help for writing C programs. coc syntastic youcompleteme 8. Other Useful Plugins (Just Not for Exams) Syntax and Style Checker I use syntastic to check for style and syntax whenever I save a file. syntastic is a vim plugin. My .vimrc configuration file contains the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \"For syntastic set laststatus=2 set statusline+=%#warningmsg# set statusline+=%{SyntasticStatuslineFlag()} set statusline+=%* let g:syntastic_error_symbol = '\u2717' let g:syntastic_warning_symbol = '\u26a0' let g:syntastic_always_populate_loc_list = 1 let g:syntastic_auto_loc_list = 1 let g:syntastic_check_on_open = 1 let g:syntastic_check_on_wq = 0 let g:syntastic_c_checkers = [ 'clang_tidy', 'clang' ] let g:syntastic_c_compiler = 'clang' let g:syntastic_c_clang_args = '-Wall -Werror -Wextra -Iinclude' let g:syntastic_c_clang_tidy_args = '-checks=*' let g:syntastic_c_compiler_options = '-Wall -Iinclude' let g:syntastic_c_include_dirs = [ '../include', 'include' ] let g:syntastic_c_clang_tidy_post_args = \"\" By default, clang-tidy does not know where to find the header files. So if you include non-standard C headers, it will complain that it cannot find headers. To resolve this, we need to tell clang-tidy the compilation flags that we use when compiling our program. We can do this by creating a file named compile_flags.txt in your working directory (where your C files are located), containing one compilation flag per line. For instance, if the header files are located in /home/course/cs1010/include , your compile_flags.txt should contain the following two lines: 1 2 -Wall -I/home/course/cs1010/include Note that syntastic is not one of the approved plugins during CS1010 practical exams.","title":"Vim"},{"location":"vim.html#vim-tips","text":"I collected some tips on vim that I find helpful. If you are new to vim , please try out the command vimtutor on any machine where vim is installed, and check out the nice article Learn vim Progressively .","title":"Vim Tips"},{"location":"vim.html#1-useful-configuration","text":"You can configure your vim by putting your configuration options and scripts in the ~/.vimrc file (a hidden file named .vimrc in your home directory). This file will be loaded whenever you start vim . You can copy a sample .vimrc file from ~cs1010/.vimrc to your home directory. You can edit this file ~/.vimrc just like any other file, using vim .","title":"1. Useful Configuration"},{"location":"vim.html#help","text":"In vim, the command :help <topic> shows help about a particular topic in vim . Example, :help backup .","title":"Help"},{"location":"vim.html#backup-files","text":"You can ask vim to automatically backup files that you edit. This has been a lifesaver for me on multiple occasions. In your ~/.vimrc file, 1 set backup will cause a copy of your file to be saved with suffix ~ appended to its name every time you save. I prefer not to clutter my working directory, so I set 1 set backupdir=~/.backup and create a directory named ~/.backup to store my backup files. So if you made changes to a file that you regretted, or if you accidentally deleted a file, you can check under ~/.backup to see if the backup can save you.","title":"Backup Files"},{"location":"vim.html#syntax-highlighting","text":"If for some reasons, syntax highlighting is not on by default, add this to your ~/.vimrc : 1 syntax on","title":"Syntax Highlighting"},{"location":"vim.html#ruler-and-numbers","text":"If you prefer to show the line number you are on and the column number you are on, adding the commands to ~/.vimrc 1 set ruler will display the line number and the column number on the lower right corner. You can also add 1 set number to label each line with a line number.","title":"Ruler and Numbers"},{"location":"vim.html#auto-indentation","text":"Proper indentation is important to make your code readable (to yourself and others). You should enable this in vim with: 1 2 set autoindent set smartindent Autoindent will cause the next line to have the same indentation as the previous line; while smartindent has some understanding of C-like syntax (such as recognizing { and } ) and indent your code accordingly. The size of the indentation is based on the setting shiftwidth . For CS1010, please set it to either 2 or 4 : 1 set shiftwidth=2","title":"Auto Indentation"},{"location":"vim.html#2-navigation","text":"","title":"2. Navigation"},{"location":"vim.html#basic-navigation","text":"Use K and J keys to move up and down (just like Gmail and Facebook!). H and L to move left and right. Other shortcuts (no need to memorize them now, just refer back when you feel like you are typing too many H J K L to see how you can navigate faster). W jump to the beginning of the next word B ump to the beginning of the previous word (reverse of w ) E jump to the end of the word (or next word when pressed again) F char: search forward in the line and sit on the next matching char T char: search forward in the line and sit on one space before the matching char Shift + 4 ($) jump to the end of line 0 jump to the beginning of the line Shift + 6 (^) jump to the first non-blank character of the line Shift + 5 (%) jump between matching parentheses Ctrl + D jump forward (Down) half page Ctrl + F jump Forward one page Ctrl + U jump backward (Up) half page Ctrl + B jump Backward half page","title":"Basic Navigation"},{"location":"vim.html#jumping-to-a-line","text":"If the compiler tells you there is an error on Line \\(x\\) , you can issue :<x> to jump to Line \\(x\\) . For instance, :40 will go to Line 40.","title":"Jumping to a Line"},{"location":"vim.html#3-editing-operations","text":"","title":"3. Editing Operations"},{"location":"vim.html#undo","text":"Since we are on the topic of correcting mistakes, U in command mode undo your changes. Prefix it with a number \\(n\\) to undo \\(n\\) times. If you want to undo your undo, Ctrl + R will redo.","title":"Undo"},{"location":"vim.html#navigation-editing","text":"vim is powerful because you can combine operations with navigation . For instance C to change, D to delete, Y to yank (copy). Since W is the navigation command to move over the current word, combining them we get: C W change the current word (delete the current word and enter insert mode) D W delete the current word Y W yank the current word (copy word into buffer) Can you guess what each of these do: D F Shift + 0 D F Shift + 0 C Shift + 4 Y 0 If you repeat the operation C , D , and Y , it applies to the whole line, so: C C change the whole line D D delete the whole line Y Y yank the whole line You can add a number before an operation to specify how many times you want to repeat an operation. So 5 D D deletes 5 lines, 5 D W deletes 5 words, etc. See the article Operator, the True Power of Vim for more details.","title":"Navigation + Editing"},{"location":"vim.html#swapping-lines","text":"Sometimes you want to swap the order of two lines of code, in command mode, D D P will do the trick. D D deletes the current line, P paste it after the current line, in effect swapping the order of the two lines.","title":"Swapping Lines"},{"location":"vim.html#commenting-blocks-of-code","text":"Sometimes we need to comment out a whole block of code in C for testing purposes. There are several ways to do it in vim : Place the cursor on the first line of the block of code you want to comment on. 0 to jump to the beginning of the line Shift + V enter visual mode Use the arrow key to select the block of code you want to comment on. Shift + I to insert at the beginning of the line (here, since we already selected the block, we will insert at the beginning of every selected) / / to insert the C comment character (you will see it inserted in the current line, but don't worry) Esc to escape from the visual code. To uncomment, Place the cursor on the first line of the block of code you want to comment. 0 to jump to the beginning of the line Ctrl + V enter block visual mode Use the arrow key to select the columns of text containing // X to delete them","title":"Commenting blocks of code"},{"location":"vim.html#4-other-advanced-features","text":"","title":"4. Other Advanced Features"},{"location":"vim.html#search-and-replace-in-vim","text":"1 :%s/oldWord/newWord/gc : enters the command mode. % means apply to the whole document, s means substitute, g means global (otherwise, only the first occurrence of each line is replaced). c is optional -- adding it cause vim to confirm with you before each replacement","title":"Search and Replace in vim"},{"location":"vim.html#shell-command","text":"If you need to issue a shell command quickly, you don't have to exit vim , run the command, and launch vim again. You can use ! , 1 :!<command> will issue the command to shell. E.g., 1 :!ls You can use this to compile your current file, without exiting vim . 1 :!make make is actually a builtin command for vim so you can also simply run 1 :make","title":"Shell Command"},{"location":"vim.html#abbreviation","text":"You can use the command ab to abbreviate frequently typed commands. E.g., in your ~/.vimrc , 1 ab pl cs1010_print_long( Now, when you type pl , it will be expanded into cs1010_print_long(","title":"Abbreviation"},{"location":"vim.html#auto-completion","text":"You can use Ctrl + P or Ctrl + N to auto-complete. By default, the autocomplete dictionary is based on the text in your current editing buffers. This is a very useful keystroke saver for long function and variable names.","title":"Auto-Completion"},{"location":"vim.html#auto-indent-the-whole-file","text":"You can G G = Shift + G in command mode to auto-indent the whole file. G G is the command to go to the beginning of the file. = is the command to indent. Shift + G is the command to go to the end of the file.","title":"Auto-Indent the Whole File"},{"location":"vim.html#splitting-vims-viewport","text":":sp file.c splits the vim window horizontally :vsp file.c splits the vim window vertically Ctrl + W Ctrl + W moves between the different vim viewports","title":"Splitting vim's Viewport"},{"location":"vim.html#5-color-schemes","text":"NEW We have installed vim-colorscheme bundle under ~cs1010/.vim/vim-colorschemes/colors . There are a few steps needed. First, the standard .vimrc is designed for 16 colors, and some of these color schemes are more colorful than that. You need to comment the following three lines from your ~/.vimrc 1 2 3 4 \" The following should give 16 colors \" set t_AB=^[[%?%p1%{8}%<%t%p1%{40}%+%e%p1%{92}%+%;%dm \" set t_AF=^[[%?%p1%{8}%<%t%p1%{30}%+%e%p1%{82}%+%;%dm \" set t_Co=16 Then, run 1 2 mkdir -p ~/.vim ln -s ~cs1010/.vim/vim-colorschemes/colors ~/.vim/colors After that, your can change your vim color scheme as usual. For instance, 1 :color gruvbox You can add the line color gruvbox to your ~/.vimrc so that the color scheme is loaded at the start of every vim session. The bundle includes some of the popular color schemes among students, such as molokai, solarized, and gruvbox. Some color schemes display differently depending on whether the background is set to dark or light Some examples, with set background=dark in ~/.vimrc : The default color scheme: The molokai color scheme: The gruvbox color scheme","title":"5. Color Schemes"},{"location":"vim.html#6-recovery-files","text":"NEW Vim automatically saves the files you are editing into temporary swap files, with extension .swp . These files are hidden so you don't normally see them when you run ls . (You need to run ls -a to view the hidden files) The swap files are useful if your editing session is disrupted before you save (e.g., the network is disconnected, you accidentally close the terminal, your OS crashes, etc.). When you launch vim to edit a file, say, foo.c . vim will check if a swap file .foo.c.swp exist. If it does, vim with display the following 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Found a swap file by the name \".foo.c.swp\" owned by: elsa dated: Sat Aug 21 15:01:04 2021 file name: ~elsa/foo.c modified: no user name: elsa host name: pe116 process ID: 7863 (STILL RUNNING) While opening file \"foo.c\" dated: Mon Jul 12 18:38:37 2021 (1) Another program may be editing the same file. If this is the case, be careful not to end up with two different instances of the same file when making changes. Quit, or continue with caution. (2) An edit session for this file crashed. If this is the case, use \":recover\" or \"vim -r a.c\" to recover the changes (see \":help recovery\"). If you did this already, delete the swap file \".a.c.swp\" to avoid this message. Swap file \".a.c.swp\" already exists! [O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit, (A)bort: The messages above is self-explanatory. Read it carefully. Most of the time, you want to choose \"R\" to recover your edits, so that you can continue editing. Remember to remove the file .foo.c.swp after you have recovered. Otherwise vim will prompt you the above messages every time you edit foo.c . Warning: if foo.c is newer than the state saved in .foo.c.swp , and you recover from .foo.c.swp , you will revert back to the state of the file as saved in the swap file. This can happen if (i) you edit the file without recovery, or (ii) you recover the file, continue editing, but did not remove the .foo.c.swp file after.","title":"6. Recovery Files"},{"location":"vim.html#7-approved-plugins","text":"UPDATED The following plugins are approved for use during practical exams. You will be given time to install them (only if you wish to use them) into your exam environment at the beginning of the practical exam.","title":"7. Approved Plugins"},{"location":"vim.html#delimitmate","text":"DelimitMate is a plugin that automatically inserts a closing } , ) , > , etc when you type the opening symbol. To install this plugin in the exam environment, run 1 ln -s ~cs1010/.vim/pack/plugins/start/delimitMate.vim ~/.vim/pack/plugins/start","title":"DelimitMate"},{"location":"vim.html#vim-rainbow","text":"vim-rainbow is a plugin that matches opening and closing brackets and colors the matching pairs with matching colors. To install this plugin in the exam environment, run 1 ln -s ~cs1010/.vim/pack/plugins/start/vim-rainbow ~/.vim/pack/plugins/start The following line will be added on your ~/.vimrc in the environment: 1 let g:rainbow_active = 1","title":"Vim-Rainbow"},{"location":"vim.html#nerdtree","text":"NERDTree provides a file browsing pane on the left (activated with :NERDTree ). To install this plugin in the exam environment, run 1 ln -s ~cs1010/.vim/pack/plugins/start/nerdtree ~/.vim/pack/plugins/start","title":"NERDTree"},{"location":"vim.html#lightline","text":"Lightline provides a more useful status line for vim . To install this plugin in the exam environment, run 1 ln -s ~cs1010/.vim/pack/plugins/start/lightline.vim ~/.vim/pack/plugins/start","title":"Lightline"},{"location":"vim.html#unavailable-plugins","text":"The following plugins are not allowed as they provide too much help for writing C programs. coc syntastic youcompleteme","title":"Unavailable Plugins"},{"location":"vim.html#8-other-useful-plugins-just-not-for-exams","text":"","title":"8. Other Useful Plugins (Just Not for Exams)"},{"location":"vim.html#syntax-and-style-checker","text":"I use syntastic to check for style and syntax whenever I save a file. syntastic is a vim plugin. My .vimrc configuration file contains the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \"For syntastic set laststatus=2 set statusline+=%#warningmsg# set statusline+=%{SyntasticStatuslineFlag()} set statusline+=%* let g:syntastic_error_symbol = '\u2717' let g:syntastic_warning_symbol = '\u26a0' let g:syntastic_always_populate_loc_list = 1 let g:syntastic_auto_loc_list = 1 let g:syntastic_check_on_open = 1 let g:syntastic_check_on_wq = 0 let g:syntastic_c_checkers = [ 'clang_tidy', 'clang' ] let g:syntastic_c_compiler = 'clang' let g:syntastic_c_clang_args = '-Wall -Werror -Wextra -Iinclude' let g:syntastic_c_clang_tidy_args = '-checks=*' let g:syntastic_c_compiler_options = '-Wall -Iinclude' let g:syntastic_c_include_dirs = [ '../include', 'include' ] let g:syntastic_c_clang_tidy_post_args = \"\" By default, clang-tidy does not know where to find the header files. So if you include non-standard C headers, it will complain that it cannot find headers. To resolve this, we need to tell clang-tidy the compilation flags that we use when compiling our program. We can do this by creating a file named compile_flags.txt in your working directory (where your C files are located), containing one compilation flag per line. For instance, if the header files are located in /home/course/cs1010/include , your compile_flags.txt should contain the following two lines: 1 2 -Wall -I/home/course/cs1010/include Note that syntastic is not one of the approved plugins during CS1010 practical exams.","title":"Syntax and Style Checker"},{"location":"zoom.html","text":"Using Zoom Logging into Zoom You can only join the sessions if you log in into Zoom nus-sg.zoom.us using your NUS account. To do so, you have to first log out of Zoom if you have already logged in using your non-NUS Zoom account. There are two options: Option 1 go to https://nus-sg.zoom.us/ directly and click \"Sign In\"; Follow the given instructions by entering your NUSNET ID and password. Option 2 If you get to Zoom through another link, you might be presented with the following screen. Do not enter your NUS email address and password on this screen. Instead, click on \"Sign in with SSO\". You will be presented with this screen: Enter nus-sg into the field \"Company Domain\" and click continue. You will be prompted to enter your NUSNET ID and password. Follow the instruction on the screen. Using Zoom Desktop Client Some students have reported issues when trying to join a breakout room when using Web version of Zoom (i.e., connecting through a Web browser). Please join the workshop by using the Zoom application instead of through a Web browser. Links to Join Zoom The Zoom session information is shared privately on Piazza .","title":"Zoom"},{"location":"zoom.html#using-zoom","text":"","title":"Using Zoom"},{"location":"zoom.html#logging-into-zoom","text":"You can only join the sessions if you log in into Zoom nus-sg.zoom.us using your NUS account. To do so, you have to first log out of Zoom if you have already logged in using your non-NUS Zoom account. There are two options:","title":"Logging into Zoom"},{"location":"zoom.html#option-1","text":"go to https://nus-sg.zoom.us/ directly and click \"Sign In\"; Follow the given instructions by entering your NUSNET ID and password.","title":"Option 1"},{"location":"zoom.html#option-2","text":"If you get to Zoom through another link, you might be presented with the following screen. Do not enter your NUS email address and password on this screen. Instead, click on \"Sign in with SSO\". You will be presented with this screen: Enter nus-sg into the field \"Company Domain\" and click continue. You will be prompted to enter your NUSNET ID and password. Follow the instruction on the screen.","title":"Option 2"},{"location":"zoom.html#using-zoom-desktop-client","text":"Some students have reported issues when trying to join a breakout room when using Web version of Zoom (i.e., connecting through a Web browser). Please join the workshop by using the Zoom application instead of through a Web browser.","title":"Using Zoom Desktop Client"},{"location":"zoom.html#links-to-join-zoom","text":"The Zoom session information is shared privately on Piazza .","title":"Links to Join Zoom"},{"location":"panopto/panopto.html","text":"Panopto Guide for CS1010 Installation In LumiNus, click CS1010 under My Modules > Enrolled Modules . Scroll down on the left-hand sidebar. Click Multimedia . Click on channel eExam Screen Recording . Click on the Create button at the top of your page. Select \" Panopto for Windows \" or \" Panopto for Mac \". A popup window appears. In the popup window, click on the Download Panopto button. Wait for the installer to be downloaded. Install Panopto. If you encounter any issues during installation, disable any anti-virus software and firewall, and try again. Panopto will be launched after the installation is complete. Close the launched Panopto window. Recording and Uploading Test In LumiNus, click CS1010 under My Modules > Enrolled Modules . Scroll down on the left-hand sidebar. Click Multimedia. Click on channel \"eExam Screen Recording\". Click on folder \"Panopto Testing\". Inside the folder, click on the Create button at the top of your page. Select \" Panopto for Windows \" or \" Panopto for Mac \". A popup window appears. In the popup window, click on the \" Open Panopto \" button. Panopto will launch. Configure Panopto Settings\uff1a Click Settings on the top of the Panopto window Under Basic Settings , uncheck \" Progressively upload while recording \". Under Advanced Settings , uncheck \"Enable no audio detected alerts\". Under Advanced Settings , check \" Capture in MP4 format \". Click Save at the bottom of the window. You should have returned to the default page Create New Recording . Configure new recording setups on Create New Recording page: Under Session Settings , set Name of your recording as \"your NUS user ID_Test\" e.g. \"E0008032_Test\". On the left panel of the window, under Primary Sources , Select Video sources to be None . Check Capture Computer Audio . On the left panel of the window, under Secondary Sources , Uncheck Capture PowerPoint . On the bottom of the right panel Main Screen , Set fps to be the minimum allowed (4). Set kbps to be the minimum allowed (340). Start recording by clicking on the Record button on top left of the Create New Recording page. Note that you have to select an audio source in order to enable the Record button , if your computer does not have an audio device, please approach your lab tutor on Week 6, 16 Sept. Click Stop on top left of the Create New Recording page. A popup will appear indicating Recording is Complete . Click Done on the popup. Your recording is currently being uploaded to the folder eExam Screen Recording > Panopto Testing . You should see the status of your recording similar to the screenshot below after the recording is uploaded successfully. Check the Luminus folder that your recording is now displayed in the Luminus folder. Congratulations you are done! You may delete your screen recording. Prepared by Song Kai, Luo Xinjian, Wang Chengxin","title":"Panopto"},{"location":"panopto/panopto.html#panopto-guide-for-cs1010","text":"","title":"Panopto Guide for CS1010"},{"location":"panopto/panopto.html#installation","text":"In LumiNus, click CS1010 under My Modules > Enrolled Modules . Scroll down on the left-hand sidebar. Click Multimedia . Click on channel eExam Screen Recording . Click on the Create button at the top of your page. Select \" Panopto for Windows \" or \" Panopto for Mac \". A popup window appears. In the popup window, click on the Download Panopto button. Wait for the installer to be downloaded. Install Panopto. If you encounter any issues during installation, disable any anti-virus software and firewall, and try again. Panopto will be launched after the installation is complete. Close the launched Panopto window.","title":"Installation"},{"location":"panopto/panopto.html#recording-and-uploading-test","text":"In LumiNus, click CS1010 under My Modules > Enrolled Modules . Scroll down on the left-hand sidebar. Click Multimedia. Click on channel \"eExam Screen Recording\". Click on folder \"Panopto Testing\". Inside the folder, click on the Create button at the top of your page. Select \" Panopto for Windows \" or \" Panopto for Mac \". A popup window appears. In the popup window, click on the \" Open Panopto \" button. Panopto will launch. Configure Panopto Settings\uff1a Click Settings on the top of the Panopto window Under Basic Settings , uncheck \" Progressively upload while recording \". Under Advanced Settings , uncheck \"Enable no audio detected alerts\". Under Advanced Settings , check \" Capture in MP4 format \". Click Save at the bottom of the window. You should have returned to the default page Create New Recording . Configure new recording setups on Create New Recording page: Under Session Settings , set Name of your recording as \"your NUS user ID_Test\" e.g. \"E0008032_Test\". On the left panel of the window, under Primary Sources , Select Video sources to be None . Check Capture Computer Audio . On the left panel of the window, under Secondary Sources , Uncheck Capture PowerPoint . On the bottom of the right panel Main Screen , Set fps to be the minimum allowed (4). Set kbps to be the minimum allowed (340). Start recording by clicking on the Record button on top left of the Create New Recording page. Note that you have to select an audio source in order to enable the Record button , if your computer does not have an audio device, please approach your lab tutor on Week 6, 16 Sept. Click Stop on top left of the Create New Recording page. A popup will appear indicating Recording is Complete . Click Done on the popup. Your recording is currently being uploaded to the folder eExam Screen Recording > Panopto Testing . You should see the status of your recording similar to the screenshot below after the recording is uploaded successfully. Check the Luminus folder that your recording is now displayed in the Luminus folder. Congratulations you are done! You may delete your screen recording. Prepared by Song Kai, Luo Xinjian, Wang Chengxin","title":"Recording and Uploading Test"}]}